        -:    0:Source:/home/workspace/lib/templatesimplifier.h
        -:    0:Graph:/home/workspace/build/lib/CMakeFiles/lib_objs.dir/token.gcno
        -:    0:Data:/home/workspace/build/lib/CMakeFiles/lib_objs.dir/token.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*
        -:    2: * Cppcheck - A tool for static C/C++ code analysis
        -:    3: * Copyright (C) 2007-2019 Cppcheck team.
        -:    4: *
        -:    5: * This program is free software: you can redistribute it and/or modify
        -:    6: * it under the terms of the GNU General Public License as published by
        -:    7: * the Free Software Foundation, either version 3 of the License, or
        -:    8: * (at your option) any later version.
        -:    9: *
        -:   10: * This program is distributed in the hope that it will be useful,
        -:   11: * but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   12: * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   13: * GNU General Public License for more details.
        -:   14: *
        -:   15: * You should have received a copy of the GNU General Public License
        -:   16: * along with this program.  If not, see <http://www.gnu.org/licenses/>.
        -:   17: */
        -:   18:
        -:   19:
        -:   20://---------------------------------------------------------------------------
        -:   21:#ifndef templatesimplifierH
        -:   22:#define templatesimplifierH
        -:   23://---------------------------------------------------------------------------
        -:   24:
        -:   25:#include "config.h"
        -:   26:
        -:   27:#include <ctime>
        -:   28:#include <list>
        -:   29:#include <map>
        -:   30:#include <set>
        -:   31:#include <string>
        -:   32:#include <unordered_map>
        -:   33:#include <vector>
        -:   34:
        -:   35:class ErrorLogger;
        -:   36:class Settings;
        -:   37:class Token;
        -:   38:class Tokenizer;
        -:   39:class TokenList;
        -:   40:
        -:   41:/// @addtogroup Core
        -:   42:/// @{
        -:   43:
        -:   44:/** @brief Simplify templates from the preprocessed and partially simplified code. */
        -:   45:class CPPCHECKLIB TemplateSimplifier {
        -:   46:public:
        -:   47:    explicit TemplateSimplifier(Tokenizer *tokenizer);
        -:   48:    ~TemplateSimplifier();
        -:   49:
        -:   50:    /**
        -:   51:     * Used after simplifyTemplates to perform a little cleanup.
        -:   52:     * Sometimes the simplifyTemplates isn't fully successful and then
        -:   53:     * there are function calls etc with "wrong" syntax.
        -:   54:     */
        -:   55:    void cleanupAfterSimplify();
        -:   56:
        -:   57:    /**
        -:   58:     */
        -:   59:    void checkComplicatedSyntaxErrorsInTemplates();
        -:   60:
        -:   61:    /**
        -:   62:     * is the token pointing at a template parameters block
        -:   63:     * < int , 3 > => yes
        -:   64:     * \param tok start token that must point at "<"
        -:   65:     * \return number of parameters (invalid parameters => 0)
        -:   66:     */
        -:   67:    static unsigned int templateParameters(const Token *tok);
        -:   68:
        -:   69:    /**
        -:   70:     * Token and its full scopename
        -:   71:     */
        -:   72:    class TokenAndName {
        -:   73:        Token *mToken;
        -:   74:        std::string mScope;
        -:   75:        std::string mName;
        -:   76:        std::string mFullName;
        -:   77:        const Token *mNameToken;
        -:   78:        const Token *mParamEnd;
        -:   79:        unsigned int mFlags;
        -:   80:
        -:   81:        enum {
        -:   82:            fIsClass                 = (1 << 0), // class template
        -:   83:            fIsFunction              = (1 << 1), // function template
        -:   84:            fIsVariable              = (1 << 2), // variable template
        -:   85:            fIsAlias                 = (1 << 3), // alias template
        -:   86:            fIsSpecialization        = (1 << 4), // user specialized template
        -:   87:            fIsPartialSpecialization = (1 << 5), // user partial specialized template
        -:   88:            fIsForwardDeclaration    = (1 << 6), // forward declaration
        -:   89:            fIsVariadic              = (1 << 7), // variadic template
        -:   90:            fIsFriend                = (1 << 8), // friend template
        -:   91:            fFamilyMask              = (fIsClass | fIsFunction | fIsVariable)
        -:   92:        };
        -:   93:
        -:   94:        void isClass(bool state) {
        -:   95:            setFlag(fIsClass, state);
        -:   96:        }
        -:   97:        void isFunction(bool state) {
        -:   98:            setFlag(fIsFunction, state);
        -:   99:        }
        -:  100:        void isVariable(bool state) {
        -:  101:            setFlag(fIsVariable, state);
        -:  102:        }
        -:  103:        void isAlias(bool state) {
        -:  104:            setFlag(fIsAlias, state);
        -:  105:        }
        -:  106:        void isSpecialization(bool state) {
        -:  107:            setFlag(fIsSpecialization, state);
        -:  108:        }
        -:  109:        void isPartialSpecialization(bool state) {
        -:  110:            setFlag(fIsPartialSpecialization, state);
        -:  111:        }
        -:  112:        void isForwardDeclaration(bool state) {
        -:  113:            setFlag(fIsForwardDeclaration, state);
        -:  114:        }
        -:  115:        void isVariadic(bool state) {
        -:  116:            setFlag(fIsVariadic, state);
        -:  117:        }
        -:  118:        void isFriend(bool state) {
        -:  119:            setFlag(fIsFriend, state);
        -:  120:        }
        -:  121:
        -:  122:        /**
        -:  123:         * Get specified flag state.
        -:  124:         * @param flag flag to get state of
        -:  125:         * @return true if flag set or false in flag not set
        -:  126:         */
        -:  127:        bool getFlag(unsigned int flag) const {
        -:  128:            return ((mFlags & flag) != 0);
        -:  129:        }
        -:  130:
        -:  131:        /**
        -:  132:         * Set specified flag state.
        -:  133:         * @param flag flag to set state
        -:  134:         * @param state new state of flag
        -:  135:         */
        -:  136:        void setFlag(unsigned int flag, bool state) {
        -:  137:            mFlags = state ? mFlags | flag : mFlags & ~flag;
        -:  138:        }
        -:  139:
        -:  140:    public:
        -:  141:        /**
        -:  142:         * Constructor used for instantiations.
        -:  143:         * \param tok template instantiation name token "name<...>"
        -:  144:         * \param s full qualification of template(scope)
        -:  145:         */
        -:  146:        TokenAndName(Token *token, const std::string &scope);
        -:  147:        /**
        -:  148:         * Constructor used for declarations.
        -:  149:         * \param tok template declaration token "template < ... >"
        -:  150:         * \param s full qualification of template(scope)
        -:  151:         * \param nt template name token "template < ... > class name"
        -:  152:         * \param pe template parameter end token ">"
        -:  153:         */
        -:  154:        TokenAndName(Token *token, const std::string &scope, const Token *nameToken, const Token *paramEnd);
        -:  155:        TokenAndName(const TokenAndName& other);
        -:  156:        ~TokenAndName();
        -:  157:
        -:  158:        bool operator == (const TokenAndName & rhs) const {
        -:  159:            return mToken == rhs.mToken && mScope == rhs.mScope && mName == rhs.mName && mFullName == rhs.mFullName &&
        -:  160:                   mNameToken == rhs.mNameToken && mParamEnd == rhs.mParamEnd && mFlags == rhs.mFlags;
        -:  161:        }
        -:  162:
        -:  163:        Token * token() const {
        -:  164:            return mToken;
        -:  165:        }
function _ZN18TemplateSimplifier12TokenAndName5tokenEP5Token called 0 returned 0% blocks executed 0%
    #####:  166:        void token(Token * token) {
    #####:  167:            mToken = token;
    #####:  168:        }
        -:  169:        const std::string & scope() const {
        -:  170:            return mScope;
        -:  171:        }
        -:  172:        const std::string & name() const {
        -:  173:            return mName;
        -:  174:        }
        -:  175:        const std::string & fullName() const {
        -:  176:            return mFullName;
        -:  177:        }
        -:  178:        const Token * nameToken() const  {
        -:  179:            return mNameToken;
        -:  180:        }
        -:  181:        const Token * paramEnd() const {
        -:  182:            return mParamEnd;
        -:  183:        }
        -:  184:        void paramEnd(const Token *end) {
        -:  185:            mParamEnd = end;
        -:  186:        }
        -:  187:
        -:  188:        bool isClass() const {
        -:  189:            return getFlag(fIsClass);
        -:  190:        }
        -:  191:        bool isFunction() const {
        -:  192:            return getFlag(fIsFunction);
        -:  193:        }
        -:  194:        bool isVariable() const {
        -:  195:            return getFlag(fIsVariable);
        -:  196:        }
        -:  197:        bool isAlias() const {
        -:  198:            return getFlag(fIsAlias);
        -:  199:        }
        -:  200:        bool isSpecialization() const {
        -:  201:            return getFlag(fIsSpecialization);
        -:  202:        }
        -:  203:        bool isPartialSpecialization() const {
        -:  204:            return getFlag(fIsPartialSpecialization);
        -:  205:        }
        -:  206:        bool isForwardDeclaration() const {
        -:  207:            return getFlag(fIsForwardDeclaration);
        -:  208:        }
        -:  209:        bool isVariadic() const {
        -:  210:            return getFlag(fIsVariadic);
        -:  211:        }
        -:  212:        bool isFriend() const {
        -:  213:            return getFlag(fIsFriend);
        -:  214:        }
        -:  215:
        -:  216:        /**
        -:  217:         * Get alias start token.
        -:  218:         * template < ... > using X = foo < ... >;
        -:  219:         *                            ^
        -:  220:         * @return alias start token
        -:  221:         */
        -:  222:        const Token * aliasStartToken() const;
        -:  223:
        -:  224:        /**
        -:  225:         * Get alias end token.
        -:  226:         * template < ... > using X = foo < ... >;
        -:  227:         *                                       ^
        -:  228:         * @return alias end token
        -:  229:         */
        -:  230:        const Token * aliasEndToken() const;
        -:  231:
        -:  232:        /**
        -:  233:         * Is token an alias token?
        -:  234:         * template < ... > using X = foo < ... >;
        -:  235:         *                                   ^
        -:  236:         * @param tok token to check
        -:  237:         * @return true if alias token, false if not
        -:  238:         */
        -:  239:        bool isAliasToken(const Token *tok) const;
        -:  240:
        -:  241:        /**
        -:  242:         * Is declaration the same family (class, function or variable).
        -:  243:         *
        -:  244:         * @param decl declaration to compare to
        -:  245:         * @return true if same family, false if different family
        -:  246:         */
        -:  247:        bool isSameFamily(const TemplateSimplifier::TokenAndName &decl) const {
        -:  248:            // Make sure a family flag is set and matches.
        -:  249:            // This works because at most only one flag will be set.
        -:  250:            return (mFlags & fFamilyMask) & (decl.mFlags & (fFamilyMask));
        -:  251:        }
        -:  252:    };
        -:  253:
        -:  254:    /**
        -:  255:     * Find last token of a template declaration.
        -:  256:     * @param tok start token of declaration "template" or token after "template < ... >"
        -:  257:     * @return last token of declaration or nullptr if syntax error
        -:  258:     */
        -:  259:    static Token *findTemplateDeclarationEnd(Token *tok);
        -:  260:    static const Token *findTemplateDeclarationEnd(const Token *tok);
        -:  261:
        -:  262:    /**
        -:  263:     * Match template declaration/instantiation
        -:  264:     * @param instance template instantiation
        -:  265:     * @param numberOfArguments number of template arguments
        -:  266:     * @param patternAfter pattern that must match the tokens after the ">"
        -:  267:     * @return match => true
        -:  268:     */
        -:  269:    static bool instantiateMatch(const Token *instance, const std::size_t numberOfArguments, const char patternAfter[]);
        -:  270:
        -:  271:    /**
        -:  272:     * Match template declaration/instantiation
        -:  273:     * @param tok The ">" token e.g. before "class"
        -:  274:     * @return -1 to bail out or positive integer to identity the position
        -:  275:     * of the template name.
        -:  276:     */
        -:  277:    int getTemplateNamePosition(const Token *tok);
        -:  278:
        -:  279:    /**
        -:  280:     * Get class template name position
        -:  281:     * @param tok The ">" token e.g. before "class"
        -:  282:     * @param namepos return offset to name
        -:  283:     * @return true if name found, false if not
        -:  284:     * */
        -:  285:    static bool getTemplateNamePositionTemplateClass(const Token *tok, int &namepos);
        -:  286:
        -:  287:    /**
        -:  288:     * Get function template name position
        -:  289:     * @param tok The ">" token
        -:  290:     * @param namepos return offset to name
        -:  291:     * @return true if name found, false if not
        -:  292:     * */
        -:  293:    static bool getTemplateNamePositionTemplateFunction(const Token *tok, int &namepos);
        -:  294:
        -:  295:    /**
        -:  296:     * Get variable template name position
        -:  297:     * @param tok The ">" token
        -:  298:     * @param namepos return offset to name
        -:  299:     * @return true if name found, false if not
        -:  300:     * */
        -:  301:    static bool getTemplateNamePositionTemplateVariable(const Token *tok, int &namepos);
        -:  302:
        -:  303:    /**
        -:  304:     * Simplify templates
        -:  305:     * @param maxtime time when the simplification should be stopped
        -:  306:     * @param codeWithTemplates output parameter that is set if code contains templates
        -:  307:     */
        -:  308:    void simplifyTemplates(
        -:  309:        const std::time_t maxtime,
        -:  310:        bool &codeWithTemplates);
        -:  311:
        -:  312:    /**
        -:  313:     * Simplify constant calculations such as "1+2" => "3"
        -:  314:     * @param tok start token
        -:  315:     * @return true if modifications to token-list are done.
        -:  316:     *         false if no modifications are done.
        -:  317:     */
        -:  318:    static bool simplifyNumericCalculations(Token *tok, bool isTemplate = true);
        -:  319:
        -:  320:    /**
        -:  321:     * Simplify constant calculations such as "1+2" => "3".
        -:  322:     * This also performs simple cleanup of parentheses etc.
        -:  323:     * @return true if modifications to token-list are done.
        -:  324:     *         false if no modifications are done.
        -:  325:     */
        -:  326:    bool simplifyCalculations(Token* frontToken = nullptr, Token *backToken = nullptr, bool isTemplate = true);
        -:  327:
        -:  328:    /** Simplify template instantiation arguments.
        -:  329:     * @param start first token of arguments
        -:  330:     * @param end token following last argument token
        -:  331:     */
        -:  332:    void simplifyTemplateArgs(Token *start, Token *end);
        -:  333:
        -:  334:    /** Fix angle brackets.
        -:  335:     * foo < bar < >> => foo < bar < > >
        -:  336:     */
        -:  337:    void fixAngleBrackets();
        -:  338:
        -:  339:private:
        -:  340:    /**
        -:  341:     * Get template declarations
        -:  342:     * @return true if code has templates.
        -:  343:     */
        -:  344:    bool getTemplateDeclarations();
        -:  345:
        -:  346:    /** Add template instantiation.
        -:  347:     * @param token first token of instantiation
        -:  348:     * @param scope scope of instantiation
        -:  349:     */
        -:  350:    void addInstantiation(Token *token, const std::string &scope);
        -:  351:
        -:  352:    /**
        -:  353:     * Get template instantiations
        -:  354:     */
        -:  355:    void getTemplateInstantiations();
        -:  356:
        -:  357:    /**
        -:  358:     * Fix forward declared default argument values by copying them
        -:  359:     * when they are not present in the declaration.
        -:  360:     */
        -:  361:    void fixForwardDeclaredDefaultArgumentValues();
        -:  362:
        -:  363:    /**
        -:  364:     * simplify template instantiations (use default argument values)
        -:  365:     */
        -:  366:    void useDefaultArgumentValues();
        -:  367:
        -:  368:    /**
        -:  369:     * simplify template instantiations (use default argument values)
        -:  370:     * @param declaration template declaration or forward declaration
        -:  371:     */
        -:  372:    void useDefaultArgumentValues(TokenAndName &declaration);
        -:  373:
        -:  374:    /**
        -:  375:     * Try to locate a matching declaration for each user defined
        -:  376:     * specialization.
        -:  377:     */
        -:  378:    void getSpecializations();
        -:  379:
        -:  380:    /**
        -:  381:     * Try to locate a matching declaration for each user defined
        -:  382:     * partial specialization.
        -:  383:     */
        -:  384:    void getPartialSpecializations();
        -:  385:
        -:  386:    /**
        -:  387:     * simplify template aliases
        -:  388:     */
        -:  389:    void simplifyTemplateAliases();
        -:  390:
        -:  391:    /**
        -:  392:     * Simplify templates : expand all instantiations for a template
        -:  393:     * @todo It seems that inner templates should be instantiated recursively
        -:  394:     * @param templateDeclaration template declaration
        -:  395:     * @param specializations template specializations (list each template name token)
        -:  396:     * @param maxtime time when the simplification will stop
        -:  397:     * @param expandedtemplates all templates that has been expanded so far. The full names are stored.
        -:  398:     * @return true if the template was instantiated
        -:  399:     */
        -:  400:    bool simplifyTemplateInstantiations(
        -:  401:        const TokenAndName &templateDeclaration,
        -:  402:        const std::list<const Token *> &specializations,
        -:  403:        const std::time_t maxtime,
        -:  404:        std::set<std::string> &expandedtemplates);
        -:  405:
        -:  406:    /**
        -:  407:     * Simplify templates : add namespace to template name
        -:  408:     * @param templateDeclaration template declaration
        -:  409:     * @param tok place to insert namespace
        -:  410:     */
        -:  411:    void addNamespace(const TokenAndName &templateDeclaration, const Token *tok);
        -:  412:
        -:  413:    /**
        -:  414:     * Simplify templates : check if namespace already present
        -:  415:     * @param templateDeclaration template declaration
        -:  416:     * @param tok place to start looking for namespace
        -:  417:     * @return true if namespace already present
        -:  418:     */
        -:  419:    static bool alreadyHasNamespace(const TokenAndName &templateDeclaration, const Token *tok);
        -:  420:
        -:  421:    /**
        -:  422:     * Expand a template. Create "expanded" class/function at end of tokenlist.
        -:  423:     * @param templateDeclaration               Template declaration information
        -:  424:     * @param templateInstantiation             Full name of template
        -:  425:     * @param typeParametersInDeclaration       The type parameters of the template
        -:  426:     * @param newName                           New name of class/function.
        -:  427:     * @param copy                              copy or expand in place
        -:  428:     */
        -:  429:    void expandTemplate(
        -:  430:        const TokenAndName &templateDeclaration,
        -:  431:        const TokenAndName &templateInstantiation,
        -:  432:        const std::vector<const Token *> &typeParametersInDeclaration,
        -:  433:        const std::string &newName,
        -:  434:        bool copy);
        -:  435:
        -:  436:    /**
        -:  437:     * Replace all matching template usages  'Foo < int >' => 'Foo<int>'
        -:  438:     * @param instantiation Template instantiation information.
        -:  439:     * @param typeStringsUsedInTemplateInstantiation template parameters. list of token strings.
        -:  440:     * @param newName The new type name
        -:  441:     */
        -:  442:    void replaceTemplateUsage(const TokenAndName &instantiation,
        -:  443:                              const std::list<std::string> &typeStringsUsedInTemplateInstantiation,
        -:  444:                              const std::string &newName);
        -:  445:
        -:  446:    /**
        -:  447:     * @brief TemplateParametersInDeclaration
        -:  448:     * @param tok  template < typename T, typename S >
        -:  449:     *                        ^ tok
        -:  450:     * @param typeParametersInDeclaration  template < typename T, typename S >
        -:  451:     *                                                         ^ [0]       ^ [1]
        -:  452:     * @return  template < typename T, typename S >
        -:  453:     *                                              ^ return
        -:  454:     */
        -:  455:    static const Token * getTemplateParametersInDeclaration(
        -:  456:        const Token * tok,
        -:  457:        std::vector<const Token *> & typeParametersInDeclaration);
        -:  458:
        -:  459:    /**
        -:  460:     * Remove a specific "template < ..." template class/function
        -:  461:     */
        -:  462:    static bool removeTemplate(Token *tok);
        -:  463:
        -:  464:    /** Syntax error */
        -:  465:    static void syntaxError(const Token *tok);
        -:  466:
        -:  467:    static bool matchSpecialization(
        -:  468:        const Token *templateDeclarationNameToken,
        -:  469:        const Token *templateInstantiationNameToken,
        -:  470:        const std::list<const Token *> & specializations);
        -:  471:
        -:  472:    /*
        -:  473:     * Same as Token::eraseTokens() but tries to fix up lists with pointers to the deleted tokens.
        -:  474:     * @param begin Tokens after this will be erased.
        -:  475:     * @param end Tokens before this will be erased.
        -:  476:     */
        -:  477:    static void eraseTokens(Token *begin, const Token *end);
        -:  478:
        -:  479:    /**
        -:  480:     * Delete specified token without invalidating pointer to following token.
        -:  481:     * tok will be invalidated.
        -:  482:     * @param tok token to delete
        -:  483:     */
        -:  484:    static void deleteToken(Token *tok);
        -:  485:
        -:  486:    /**
        -:  487:     * Get the new token name.
        -:  488:     * @param tok2 name token
        -:  489:     * @param typeStringsUsedInTemplateInstantiation type strings use in template instantiation
        -:  490:     * @return new token name
        -:  491:     */
        -:  492:    std::string getNewName(
        -:  493:        Token *tok2,
        -:  494:        std::list<std::string> &typeStringsUsedInTemplateInstantiation);
        -:  495:
        -:  496:    void printOut(
        -:  497:        const TokenAndName &tokenAndName,
        -:  498:        const std::string &indent = "    ") const;
        -:  499:    void printOut(const std::string &text = "") const;
        -:  500:
        -:  501:    Tokenizer *mTokenizer;
        -:  502:    TokenList &mTokenList;
        -:  503:    const Settings *mSettings;
        -:  504:    ErrorLogger *mErrorLogger;
        -:  505:    bool mChanged;
        -:  506:
        -:  507:    std::list<TokenAndName> mTemplateDeclarations;
        -:  508:    std::list<TokenAndName> mTemplateForwardDeclarations;
        -:  509:    std::map<Token *, Token *> mTemplateForwardDeclarationsMap;
        -:  510:    std::map<Token *, Token *> mTemplateSpecializationMap;
        -:  511:    std::map<Token *, Token *> mTemplatePartialSpecializationMap;
        -:  512:    std::list<TokenAndName> mTemplateInstantiations;
        -:  513:    std::list<TokenAndName> mInstantiatedTemplates;
        -:  514:    std::list<TokenAndName> mMemberFunctionsToDelete;
        -:  515:    std::vector<TokenAndName> mExplicitInstantiationsToDelete;
        -:  516:    std::vector<TokenAndName> mTypesUsedInTemplateInstantiation;
        -:  517:    std::unordered_map<const Token*, int> mTemplateNamePos;
        -:  518:};
        -:  519:
        -:  520:/// @}
        -:  521://---------------------------------------------------------------------------
        -:  522:#endif // templatesimplifierH
