        -:    0:Source:/home/workspace/lib/checkleakautovar.cpp
        -:    0:Graph:/home/workspace/build/lib/CMakeFiles/lib_objs.dir/checkleakautovar.gcno
        -:    0:Data:/home/workspace/build/lib/CMakeFiles/lib_objs.dir/checkleakautovar.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*
        -:    2: * Cppcheck - A tool for static C/C++ code analysis
        -:    3: * Copyright (C) 2007-2019 Cppcheck team.
        -:    4: *
        -:    5: * This program is free software: you can redistribute it and/or modify
        -:    6: * it under the terms of the GNU General Public License as published by
        -:    7: * the Free Software Foundation, either version 3 of the License, or
        -:    8: * (at your option) any later version.
        -:    9: *
        -:   10: * This program is distributed in the hope that it will be useful,
        -:   11: * but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   12: * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   13: * GNU General Public License for more details.
        -:   14: *
        -:   15: * You should have received a copy of the GNU General Public License
        -:   16: * along with this program.  If not, see <http://www.gnu.org/licenses/>.
        -:   17: */
        -:   18:
        -:   19://---------------------------------------------------------------------------
        -:   20:// Leaks when using auto variables
        -:   21://---------------------------------------------------------------------------
        -:   22:
        -:   23:#include "checkleakautovar.h"
        -:   24:
        -:   25:#include "astutils.h"
        -:   26:#include "checkmemoryleak.h"  // <- CheckMemoryLeak::memoryLeak
        -:   27:#include "checknullpointer.h" // <- CheckNullPointer::isPointerDeRef
        -:   28:#include "errorlogger.h"
        -:   29:#include "mathlib.h"
        -:   30:#include "settings.h"
        -:   31:#include "symboldatabase.h"
        -:   32:#include "token.h"
        -:   33:#include "tokenize.h"
        -:   34:#include "valueflow.h"
        -:   35:
        -:   36:#include <cstddef>
        -:   37:#include <iostream>
        -:   38:#include <list>
        -:   39:#include <stack>
        -:   40:#include <utility>
        -:   41:
        -:   42://---------------------------------------------------------------------------
        -:   43:
        -:   44:// Register this check class (by creating a static instance of it)
        -:   45:namespace {
        1:   46:    CheckLeakAutoVar instance;
call    0 returned 100%
call    1 returned 100%
        -:   47:}
        -:   48:
        1:   49:static const CWE CWE672(672U);
call    0 returned 100%
        1:   50:static const CWE CWE415(415U);
call    0 returned 100%
        -:   51:
        -:   52:// Hardcoded allocation types (not from library)
        -:   53:static const int NEW_ARRAY = -2;
        -:   54:static const int NEW = -1;
        -:   55:
        -:   56:
        -:   57:/**
        -:   58: * @brief Is variable type some class with automatic deallocation?
        -:   59: * @param vartok variable token
        -:   60: * @return true unless it can be seen there is no automatic deallocation
        -:   61: */
function _ZL13isAutoDeallocPK8Variable called 78 returned 100% blocks executed 57%
       78:   62:static bool isAutoDealloc(const Variable *var)
        -:   63:{
       78:   64:    if (var->valueType() && var->valueType()->type != ValueType::Type::RECORD && var->valueType()->type != ValueType::Type::UNKNOWN_TYPE)
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
call    6 returned 100%
branch  7 taken 83% (fallthrough)
branch  8 taken 17%
branch  9 taken 83% (fallthrough)
branch 10 taken 17%
       65:   65:        return false;
        -:   66:
        -:   67:    // return false if the type is a simple record type without side effects
        -:   68:    // a type that has no side effects (no constructors and no members with constructors)
        -:   69:    /** @todo false negative: check base class for side effects */
        -:   70:    /** @todo false negative: check constructors for side effects */
       26:   71:    if (var->typeScope() && var->typeScope()->numConstructors == 0 &&
call    0 returned 100%
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
       13:   72:        (var->typeScope()->varlist.empty() || var->type()->needInitialization == Type::NeedInitialization::True) &&
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
    #####:   73:        var->type()->derivedFrom.empty())
call    0 never executed
call    1 never executed
    #####:   74:        return false;
        -:   75:
       13:   76:    return true;
        -:   77:}
        -:   78:
        -:   79://---------------------------------------------------------------------------
        -:   80:
function _ZN7VarInfo5printEv called 0 returned 0% blocks executed 0%
    #####:   81:void VarInfo::print()
        -:   82:{
    #####:   83:    std::cout << "size=" << alloctype.size() << std::endl;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:   84:    for (std::map<int, AllocInfo>::const_iterator it = alloctype.begin(); it != alloctype.end(); ++it) {
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
    #####:   85:        std::string strusage;
call    0 never executed
call    1 never executed
call    2 never executed
        -:   86:        const std::map<int, std::string>::const_iterator use =
    #####:   87:            possibleUsage.find(it->first);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
    #####:   88:        if (use != possibleUsage.end())
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:   89:            strusage = use->second;
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:   90:
    #####:   91:        std::string status;
call    0 never executed
call    1 never executed
call    2 never executed
    #####:   92:        switch (it->second.status) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:   93:        case OWNED:
    #####:   94:            status = "owned";
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   95:            break;
    #####:   96:        case DEALLOC:
    #####:   97:            status = "dealloc";
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   98:            break;
    #####:   99:        case ALLOC:
    #####:  100:            status = "alloc";
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  101:            break;
    #####:  102:        case NOALLOC:
    #####:  103:            status = "noalloc";
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  104:            break;
    #####:  105:        default:
    #####:  106:            status = "?";
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  107:            break;
        -:  108:        };
        -:  109:
        -:  110:        std::cout << "status=" << status << " "
    #####:  111:                  << "alloctype='" << it->second.type << "' "
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
call    9 never executed
branch 10 never executed
branch 11 never executed
call   12 never executed
        -:  112:                  << "possibleUsage='" << strusage << "' "
    #####:  113:                  << "conditionalAlloc=" << (conditionalAlloc.find(it->first) != conditionalAlloc.end() ? "yes" : "no") << " "
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
    #####:  114:                  << "referenced=" << (referenced.find(it->first) != referenced.end() ? "yes" : "no") << " "
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
call    9 never executed
branch 10 never executed
branch 11 never executed
call   12 never executed
branch 13 never executed
branch 14 never executed
call   15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
call   20 never executed
branch 21 never executed
branch 22 never executed
call   23 never executed
branch 24 never executed
branch 25 never executed
call   26 never executed
branch 27 never executed
branch 28 never executed
call   29 never executed
call   30 never executed
call   31 never executed
branch 32 never executed
branch 33 never executed
call   34 never executed
branch 35 never executed
branch 36 never executed
call   37 never executed
branch 38 never executed
branch 39 never executed
call   40 never executed
branch 41 never executed
branch 42 never executed
call   43 never executed
call   44 never executed
call   45 never executed
call   46 never executed
    #####:  115:                  << std::endl;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  116:    }
    #####:  117:}
        -:  118:
function _ZN7VarInfo16possibleUsageAllERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 5 returned 100% blocks executed 89%
        5:  119:void VarInfo::possibleUsageAll(const std::string &functionName)
        -:  120:{
        5:  121:    possibleUsage.clear();
call    0 returned 100%
       10:  122:    for (std::map<int, AllocInfo>::const_iterator it = alloctype.begin(); it != alloctype.end(); ++it)
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
branch  6 taken 50% (fallthrough)
branch  7 taken 50%
call    8 returned 100%
call    9 returned 100%
call   10 never executed
        5:  123:        possibleUsage[it->first] = functionName;
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
        5:  124:}
        -:  125:
        -:  126:
function _ZN16CheckLeakAutoVar9leakErrorEPK5TokenRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEi called 21 returned 100% blocks executed 100%
       21:  127:void CheckLeakAutoVar::leakError(const Token *tok, const std::string &varname, int type)
        -:  128:{
       21:  129:    const CheckMemoryLeak checkmemleak(mTokenizer, mErrorLogger, mSettings);
call    0 returned 100%
       21:  130:    if (mSettings->library.isresource(type))
call    0 returned 100%
branch  1 taken 5% (fallthrough)
branch  2 taken 95%
        1:  131:        checkmemleak.resourceLeakError(tok, varname);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  132:    else
       20:  133:        checkmemleak.memleakError(tok, varname);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       21:  134:}
        -:  135:
function _ZN16CheckLeakAutoVar13mismatchErrorEPK5TokenRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 13 returned 100% blocks executed 62%
       13:  136:void CheckLeakAutoVar::mismatchError(const Token *tok, const std::string &varname)
        -:  137:{
       13:  138:    const CheckMemoryLeak c(mTokenizer, mErrorLogger, mSettings);
call    0 returned 100%
       26:  139:    const std::list<const Token *> callstack(1, tok);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
call    5 returned 100%
call    6 never executed
       13:  140:    c.mismatchAllocDealloc(callstack, varname);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       13:  141:}
call    0 never executed
        -:  142:
function _ZN16CheckLeakAutoVar15deallocUseErrorEPK5TokenRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 5 returned 100% blocks executed 100%
        5:  143:void CheckLeakAutoVar::deallocUseError(const Token *tok, const std::string &varname)
        -:  144:{
        5:  145:    const CheckMemoryLeak c(mTokenizer, mErrorLogger, mSettings);
call    0 returned 100%
        5:  146:    c.deallocuseError(tok, varname);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        5:  147:}
        -:  148:
function _ZN16CheckLeakAutoVar18deallocReturnErrorEPK5TokenRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 1 returned 100% blocks executed 58%
        1:  149:void CheckLeakAutoVar::deallocReturnError(const Token *tok, const std::string &varname)
        -:  150:{
        1:  151:    reportError(tok, Severity::error, "deallocret", "$symbol:" + varname + "\nReturning/dereferencing '$symbol' after it is deallocated / released", CWE672, false);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
        1:  152:}
        -:  153:
function _ZN16CheckLeakAutoVar17configurationInfoEPK5TokenRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 13 returned 100% blocks executed 68%
       13:  154:void CheckLeakAutoVar::configurationInfo(const Token* tok, const std::string &functionName)
        -:  155:{
       13:  156:    if (mSettings->checkLibrary && mSettings->isEnabled(Settings::INFORMATION)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 100% (fallthrough)
branch  6 taken 0%
       26:  157:        reportError(tok,
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  158:                    Severity::information,
        -:  159:                    "checkLibraryUseIgnore",
       26:  160:                    "--check-library: Function " + functionName + "() should have <use>/<leak-ignore> configuration");
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
call    5 returned 100%
call    6 never executed
call    7 never executed
        -:  161:    }
       13:  162:}
        -:  163:
function _ZN16CheckLeakAutoVar15doubleFreeErrorEPK5TokenRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEi called 20 returned 100% blocks executed 59%
       20:  164:void CheckLeakAutoVar::doubleFreeError(const Token *tok, const std::string &varname, int type)
        -:  165:{
       20:  166:    if (mSettings->library.isresource(type))
call    0 returned 100%
branch  1 taken 10% (fallthrough)
branch  2 taken 90%
        2:  167:        reportError(tok, Severity::error, "doubleFree", "$symbol:" + varname + "\nResource handle '$symbol' freed twice.", CWE415, false);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
call   11 never executed
        -:  168:    else
       18:  169:        reportError(tok, Severity::error, "doubleFree", "$symbol:" + varname + "\nMemory pointed to by '$symbol' is freed twice.", CWE415, false);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
       20:  170:}
        -:  171:
        -:  172:
function _ZN16CheckLeakAutoVar5checkEv called 194 returned 99% blocks executed 93%
      194:  173:void CheckLeakAutoVar::check()
        -:  174:{
      194:  175:    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
call    0 returned 100%
        -:  176:
        -:  177:    // Local variables that are known to be non-zero.
      388:  178:    const std::set<int> notzero;
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  179:
        -:  180:    // Check function scopes
      397:  181:    for (const Scope * scope : symbolDatabase->functionScopes) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 51% (fallthrough)
branch  4 taken 49%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 returned 100%
call   10 returned 100%
      203:  182:        if (scope->hasInlineOrLambdaFunction())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 1% (fallthrough)
branch  4 taken 99%
        1:  183:            continue;
        -:  184:
        -:  185:        // Empty variable info
      404:  186:        VarInfo varInfo;
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  187:
      203:  188:        checkScope(scope->bodyStart, &varInfo, notzero, 0);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 99% (fallthrough)
branch  5 taken 1% (throw)
call    6 returned 100%
call    7 returned 100%
        -:  189:
      201:  190:        varInfo.conditionalAlloc.clear();
call    0 returned 100%
        -:  191:
        -:  192:        // Clear reference arguments from varInfo..
      402:  193:        std::map<int, VarInfo::AllocInfo>::iterator it = varInfo.alloctype.begin();
call    0 returned 100%
call    1 returned 100%
call    2 never executed
      465:  194:        while (it != varInfo.alloctype.end()) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 40% (fallthrough)
branch  4 taken 60%
      132:  195:            const Variable *var = symbolDatabase->getVariableFromVarId(it->first);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
      261:  196:            if (!var ||
branch  0 taken 31% (fallthrough)
branch  1 taken 69%
branch  2 taken 5% (fallthrough)
branch  3 taken 95%
      308:  197:                (var->isArgument() && var->isReference()) ||
branch  0 taken 98% (fallthrough)
branch  1 taken 2%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 taken 69% (fallthrough)
branch  7 taken 31%
      218:  198:                (!var->isArgument() && !var->isLocal()))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
branch  4 taken 4% (fallthrough)
branch  5 taken 96%
        7:  199:                varInfo.alloctype.erase(it++);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
call    5 returned 100%
call    6 never executed
        -:  200:            else
      125:  201:                ++it;
call    0 returned 100%
        -:  202:        }
        -:  203:
      201:  204:        ret(scope->bodyEnd, varInfo);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  205:    }
      193:  206:}
        -:  207:
function _ZL15isVarUsedInTreePK5Tokeni called 1130 returned 100% blocks executed 100%
     1130:  208:static bool isVarUsedInTree(const Token *tok, nonneg int varid)
        -:  209:{
     1130:  210:    if (!tok)
branch  0 taken 56% (fallthrough)
branch  1 taken 44%
      634:  211:        return false;
      496:  212:    if (tok->varId() == varid)
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 99%
        4:  213:        return true;
      492:  214:    if (tok->str() == "(" && Token::simpleMatch(tok->astOperand1(), "sizeof"))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 22% (fallthrough)
branch  3 taken 78%
call    4 returned 100%
call    5 returned 100%
branch  6 taken 5% (fallthrough)
branch  7 taken 95%
branch  8 taken 1% (fallthrough)
branch  9 taken 99%
        6:  215:        return false;
      486:  216:    return isVarUsedInTree(tok->astOperand1(), varid) || isVarUsedInTree(tok->astOperand2(), varid);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 99% (fallthrough)
branch  3 taken 1%
call    4 returned 100%
call    5 returned 100%
branch  6 taken 1% (fallthrough)
branch  7 taken 99%
        -:  217:}
        -:  218:
function _ZL17isPointerReleasedPK5TokenS1_i called 21 returned 100% blocks executed 80%
       21:  219:static bool isPointerReleased(const Token *startToken, const Token *endToken, nonneg int varid)
        -:  220:{
      208:  221:    for (const Token *tok = startToken; tok && tok != endToken; tok = tok->next()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 91% (fallthrough)
branch  3 taken 9%
call    4 returned 100%
      189:  222:        if (tok->varId() != varid)
call    0 returned 100%
branch  1 taken 99% (fallthrough)
branch  2 taken 1%
      187:  223:            continue;
        2:  224:        if (Token::Match(tok, "%var% . release ( )"))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        2:  225:            return true;
    #####:  226:        if (Token::Match(tok, "%var% ="))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  227:            return false;
        -:  228:    }
       19:  229:    return false;
        -:  230:}
        -:  231:
function _ZL23isLocalVarNoAutoDeallocPK5Tokenb called 3407 returned 100% blocks executed 100%
     3407:  232:static bool isLocalVarNoAutoDealloc(const Token *varTok, const bool isCpp)
        -:  233:{
        -:  234:    // not a local variable nor argument?
     3407:  235:    const Variable *var = varTok->variable();
call    0 returned 100%
     3407:  236:    if (!var)
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
     3198:  237:        return true;
      209:  238:    if (!var->isArgument() && (!var->isLocal() || var->isStatic()))
call    0 returned 100%
branch  1 taken 86% (fallthrough)
branch  2 taken 14%
call    3 returned 100%
branch  4 taken 97% (fallthrough)
branch  5 taken 3%
call    6 returned 100%
branch  7 taken 2% (fallthrough)
branch  8 taken 98%
branch  9 taken 4% (fallthrough)
branch 10 taken 96%
        8:  239:        return false;
        -:  240:
        -:  241:    // Don't check reference variables
      201:  242:    if (var->isReference())
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 99%
        2:  243:        return false;
        -:  244:
        -:  245:    // non-pod variable
      199:  246:    if (isCpp) {
branch  0 taken 39% (fallthrough)
branch  1 taken 61%
        -:  247:        // Possibly automatically deallocated memory
       78:  248:        if (isAutoDealloc(var) && Token::Match(varTok, "%var% = new"))
call    0 returned 100%
branch  1 taken 17% (fallthrough)
branch  2 taken 83%
call    3 returned 100%
branch  4 taken 23% (fallthrough)
branch  5 taken 77%
branch  6 taken 4% (fallthrough)
branch  7 taken 96%
        3:  249:            return false;
       75:  250:        if (!var->isPointer() && !var->typeStartToken()->isStandardType())
call    0 returned 100%
branch  1 taken 15% (fallthrough)
branch  2 taken 85%
call    3 returned 100%
call    4 returned 100%
branch  5 taken 9% (fallthrough)
branch  6 taken 91%
branch  7 taken 1% (fallthrough)
branch  8 taken 99%
        1:  251:            return false;
        -:  252:    }
      195:  253:    return true;
        -:  254:}
        -:  255:
        -:  256:/** checks if nameToken is a name of a function in a function call:
        -:  257:*     func(arg)
        -:  258:* or
        -:  259:*     func<temp1_arg>(arg)
        -:  260:* @param nameToken Function name token
        -:  261:* @return opening parenthesis token or NULL if not a function call
        -:  262:*/
        -:  263:
function _ZL14isFunctionCallPK5Token called 11735 returned 100% blocks executed 100%
    11735:  264:static const Token * isFunctionCall(const Token * nameToken)
        -:  265:{
    11735:  266:    if (nameToken->isName()) {
call    0 returned 100%
branch  1 taken 9% (fallthrough)
branch  2 taken 91%
     1059:  267:        nameToken = nameToken->next();
call    0 returned 100%
        -:  268:        // check if function is a template
     1059:  269:        if (nameToken && nameToken->link() && nameToken->str() == "<") {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 50% (fallthrough)
branch  4 taken 50%
call    5 returned 100%
call    6 returned 100%
branch  7 taken 5% (fallthrough)
branch  8 taken 95%
branch  9 taken 3% (fallthrough)
branch 10 taken 97%
        -:  270:            // skip template arguments
       27:  271:            nameToken = nameToken->link()->next();
call    0 returned 100%
call    1 returned 100%
        -:  272:        }
        -:  273:        // check for '('
     1059:  274:        if (nameToken && nameToken->link() && nameToken->str() == "(") {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 48% (fallthrough)
branch  4 taken 52%
call    5 returned 100%
call    6 returned 100%
branch  7 taken 83% (fallthrough)
branch  8 taken 17%
branch  9 taken 40% (fallthrough)
branch 10 taken 60%
        -:  275:            // returning opening parenthesis pointer
      423:  276:            return nameToken;
        -:  277:        }
        -:  278:    }
    11312:  279:    return nullptr;
        -:  280:}
        -:  281:
function _ZN16CheckLeakAutoVar10checkScopeEPK5TokenP7VarInfoNSt7__debug3setIiSt4lessIiESaIiEEEi called 4279 returned 77% blocks executed 70%
     4279:  282:void CheckLeakAutoVar::checkScope(const Token * const startToken,
        -:  283:                                  VarInfo *varInfo,
        -:  284:                                  std::set<int> notzero,
        -:  285:                                  nonneg int recursiveCount)
        -:  286:{
        -:  287:#if ASAN
        -:  288:    static const nonneg int recursiveLimit = 300;
        -:  289:#else
        -:  290:    static const nonneg int recursiveLimit = 1000;
        -:  291:#endif
     4279:  292:    if (++recursiveCount > recursiveLimit)    // maximum number of "else if ()"
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        1:  293:        throw InternalError(startToken, "Internal limit: CheckLeakAutoVar::checkScope() Maximum recursive count of 1000 reached.", InternalError::LIMIT);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0% (throw)
call    8 returned 100%
call    9 returned 100%
call   10 returned 100%
call   11 never executed
call   12 never executed
call   13 never executed
        -:  294:
     4278:  295:    std::map<int, VarInfo::AllocInfo> &alloctype = varInfo->alloctype;
     4278:  296:    std::map<int, std::string> &possibleUsage = varInfo->possibleUsage;
     8556:  297:    const std::set<int> conditionalAlloc(varInfo->conditionalAlloc);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
call    4 returned 100%
        -:  298:
        -:  299:    // Parse all tokens
     4278:  300:    const Token * const endToken = startToken->link();
call    0 returned 100%
    11135:  301:    for (const Token *tok = startToken; tok && tok != endToken; tok = tok->next()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 71% (fallthrough)
branch  3 taken 29%
call    4 returned 100%
     7870:  302:        if (!tok->scope()->isExecutable()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 1% (fallthrough)
branch  3 taken 99%
        1:  303:            tok = tok->scope()->bodyEnd;
call    0 returned 100%
        1:  304:            if (!tok) // Ticket #6666 (crash upon invalid code)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  305:                break;
        -:  306:        }
        -:  307:
        -:  308:        // check each token
        -:  309:        {
     7870:  310:            const Token * nextTok = checkTokenInsideExpression(tok, varInfo);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
     7990:  311:            if (nextTok) {
branch  0 taken 2% (fallthrough)
branch  1 taken 98%
      120:  312:                tok = nextTok;
      120:  313:                continue;
        -:  314:            }
        -:  315:        }
        -:  316:
        -:  317:
        -:  318:        // look for end of statement
     7750:  319:        if (!Token::Match(tok, "[;{},]") || Token::Match(tok->next(), "[;{},]"))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 90% (fallthrough)
branch  4 taken 10%
call    5 returned 100%
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
branch  9 taken 47% (fallthrough)
branch 10 taken 53%
branch 11 taken 52% (fallthrough)
branch 12 taken 48%
     4060:  320:            continue;
        -:  321:
     3690:  322:        tok = tok->next();
call    0 returned 100%
     3690:  323:        if (!tok || tok == endToken)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -:  324:            break;
        -:  325:
        -:  326:        // parse statement, skip to last member
     3690:  327:        const Token *varTok = tok;
     3754:  328:        while (Token::Match(varTok, "%name% ::|. %name% !!("))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 1% (fallthrough)
branch  4 taken 99%
       32:  329:            varTok = varTok->tokAt(2);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  330:
     3690:  331:        const Token *ftok = tok;
     3690:  332:        if (ftok->str() == "::")
call    0 returned 100%
call    1 returned 100%
branch  2 taken 1% (fallthrough)
branch  3 taken 99%
        1:  333:            ftok = ftok->next();
call    0 returned 100%
     3744:  334:        while (Token::Match(ftok, "%name% :: %name%"))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 1% (fallthrough)
branch  4 taken 99%
       27:  335:            ftok = ftok->tokAt(2);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  336:
        -:  337:        // assignment..
     3690:  338:        if (Token::Match(varTok, "%var% =")) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 4% (fallthrough)
branch  4 taken 96%
      164:  339:            const Token* const tokAssignOp = varTok->next();
call    0 returned 100%
        -:  340:
        -:  341:            // taking address of another variable..
      164:  342:            if (Token::Match(tokAssignOp, "= %var% [+;]")) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 2% (fallthrough)
branch  4 taken 98%
        3:  343:                if (varTok->tokAt(2)->varId() != varTok->varId()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0%
        -:  344:                    // If variable points at allocated memory => error
        3:  345:                    leakIfAllocated(varTok, *varInfo);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  346:
        -:  347:                    // no multivariable checking currently => bail out for rhs variables
       14:  348:                    for (const Token *tok2 = varTok; tok2; tok2 = tok2->next()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
       14:  349:                        if (tok2->str() == ";") {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 21% (fallthrough)
branch  3 taken 79%
        3:  350:                            break;
        -:  351:                        }
       11:  352:                        if (tok2->varId()) {
call    0 returned 100%
branch  1 taken 55% (fallthrough)
branch  2 taken 45%
        6:  353:                            varInfo->erase(tok2->varId());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
        -:  354:                        }
        -:  355:                    }
        -:  356:                }
        -:  357:            }
        -:  358:
        -:  359:            // right ast part (after `=` operator)
      164:  360:            const Token* tokRightAstOperand = tokAssignOp->astOperand2();
call    0 returned 100%
      176:  361:            while (tokRightAstOperand && tokRightAstOperand->isCast())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
branch  5 taken 4% (fallthrough)
branch  6 taken 96%
branch  7 taken 4% (fallthrough)
branch  8 taken 96%
        6:  362:                tokRightAstOperand = tokRightAstOperand->astOperand2() ? tokRightAstOperand->astOperand2() : tokRightAstOperand->astOperand1();
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
call    4 returned 100%
        -:  363:
        -:  364:            // is variable used in rhs?
      164:  365:            if (isVarUsedInTree(tokRightAstOperand, varTok->varId()))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
branch  4 taken 2% (fallthrough)
branch  5 taken 98%
        4:  366:                continue;
        -:  367:
        -:  368:            // Variable has already been allocated => error
      160:  369:            if (conditionalAlloc.find(varTok->varId()) == conditionalAlloc.end())
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
branch  8 taken 99% (fallthrough)
branch  9 taken 1%
call   10 never executed
      159:  370:                leakIfAllocated(varTok, *varInfo);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
      160:  371:            varInfo->erase(varTok->varId());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
        -:  372:
      160:  373:            if (!isLocalVarNoAutoDealloc(varTok, mTokenizer->isCPP()))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
branch  4 taken 7% (fallthrough)
branch  5 taken 93%
       11:  374:                continue;
        -:  375:
        -:  376:            // allocation?
      149:  377:            const Token *const fTok = tokRightAstOperand ? tokRightAstOperand->previous() : nullptr;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
      149:  378:            if (Token::Match(fTok, "%type% (")) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 63% (fallthrough)
branch  4 taken 37%
       94:  379:                const Library::AllocFunc* f = mSettings->library.getAllocFuncInfo(fTok);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       94:  380:                if (f && f->arg == -1) {
branch  0 taken 86% (fallthrough)
branch  1 taken 14%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
       81:  381:                    VarInfo::AllocInfo& varAlloc = alloctype[varTok->varId()];
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
       81:  382:                    varAlloc.type = f->groupId;
       81:  383:                    varAlloc.status = VarInfo::ALLOC;
        -:  384:                }
        -:  385:
       94:  386:                changeAllocStatusIfRealloc(alloctype, fTok, varTok);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       55:  387:            } else if (mTokenizer->isCPP() && Token::Match(varTok->tokAt(2), "new !!(")) {
call    0 returned 100%
branch  1 taken 65% (fallthrough)
branch  2 taken 35%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
branch  9 taken 69% (fallthrough)
branch 10 taken 31%
branch 11 taken 45% (fallthrough)
branch 12 taken 55%
       25:  388:                const Token* tok2 = varTok->tokAt(2)->astOperand1();
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
       25:  389:                const bool arrayNew = (tok2 && (tok2->str() == "[" || (tok2->str() == "(" && tok2->astOperand1() && tok2->astOperand1()->str() == "[")));
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 64% (fallthrough)
branch  5 taken 36%
call    6 returned 100%
call    7 returned 100%
branch  8 taken 19% (fallthrough)
branch  9 taken 81%
call   10 returned 100%
branch 11 taken 100% (fallthrough)
branch 12 taken 0%
call   13 returned 100%
call   14 returned 100%
call   15 returned 100%
branch 16 taken 33% (fallthrough)
branch 17 taken 67%
       25:  390:                VarInfo::AllocInfo& varAlloc = alloctype[varTok->varId()];
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
       25:  391:                varAlloc.type = arrayNew ? NEW_ARRAY : NEW;
branch  0 taken 40% (fallthrough)
branch  1 taken 60%
       25:  392:                varAlloc.status = VarInfo::ALLOC;
        -:  393:            }
        -:  394:
        -:  395:            // Assigning non-zero value variable. It might be used to
        -:  396:            // track the execution for a later if condition.
      149:  397:            if (Token::Match(varTok->tokAt(2), "%num% ;") && MathLib::toLongNumber(varTok->strAt(2)) != 0)
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
branch  6 taken 3% (fallthrough)
branch  7 taken 97%
call    8 returned 100%
branch  9 taken 100% (fallthrough)
branch 10 taken 0% (throw)
call   11 returned 100%
branch 12 taken 100% (fallthrough)
branch 13 taken 0% (throw)
branch 14 taken 0% (fallthrough)
branch 15 taken 100%
branch 16 taken 0% (fallthrough)
branch 17 taken 100%
    #####:  398:                notzero.insert(varTok->varId());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
      149:  399:            else if (Token::Match(varTok->tokAt(2), "- %type% ;") && varTok->tokAt(3)->isUpperCaseName())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
branch  6 taken 1% (fallthrough)
branch  7 taken 99%
call    8 returned 100%
branch  9 taken 100% (fallthrough)
branch 10 taken 0% (throw)
call   11 returned 100%
branch 12 taken 100% (fallthrough)
branch 13 taken 0% (throw)
branch 14 taken 100% (fallthrough)
branch 15 taken 0%
branch 16 taken 1% (fallthrough)
branch 17 taken 99%
        1:  400:                notzero.insert(varTok->varId());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
        -:  401:            else
      148:  402:                notzero.erase(varTok->varId());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
        -:  403:        }
        -:  404:
        -:  405:        // if/else
     3526:  406:        else if (Token::simpleMatch(tok, "if (")) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 87% (fallthrough)
branch  4 taken 13%
        -:  407:            // Parse function calls inside the condition
        -:  408:
     3071:  409:            const Token * closingParenthesis = tok->linkAt(1);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
     6318:  410:            for (const Token *innerTok = tok->tokAt(2); innerTok && innerTok != closingParenthesis; innerTok = innerTok->next()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 51% (fallthrough)
branch  6 taken 49%
call    7 returned 100%
        -:  411:                // TODO: replace with checkTokenInsideExpression()
        -:  412:
     3247:  413:                if (!isLocalVarNoAutoDealloc(innerTok, mTokenizer->isCPP()))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
branch  4 taken 1% (fallthrough)
branch  5 taken 99%
        3:  414:                    continue;
        -:  415:
     3244:  416:                if (Token::Match(innerTok, "%var% =") && innerTok->astParent() == innerTok->next()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 1% (fallthrough)
branch  4 taken 99%
call    5 returned 100%
call    6 returned 100%
branch  7 taken 91% (fallthrough)
branch  8 taken 9%
branch  9 taken 1% (fallthrough)
branch 10 taken 99%
        -:  417:                    // allocation?
        -:  418:                    // right ast part (after `=` operator)
       10:  419:                    const Token* tokRightAstOperand = innerTok->next()->astOperand2();
call    0 returned 100%
call    1 returned 100%
       20:  420:                    while (tokRightAstOperand && tokRightAstOperand->isCast())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
branch  5 taken 33% (fallthrough)
branch  6 taken 67%
branch  7 taken 33% (fallthrough)
branch  8 taken 67%
        5:  421:                        tokRightAstOperand = tokRightAstOperand->astOperand2() ? tokRightAstOperand->astOperand2() : tokRightAstOperand->astOperand1();
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
call    4 returned 100%
       10:  422:                    if (tokRightAstOperand && Token::Match(tokRightAstOperand->previous(), "%type% (")) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
branch  6 taken 80% (fallthrough)
branch  7 taken 20%
branch  8 taken 80% (fallthrough)
branch  9 taken 20%
        8:  423:                        const Library::AllocFunc* f = mSettings->library.getAllocFuncInfo(tokRightAstOperand->previous());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
        8:  424:                        if (f && f->arg == -1) {
branch  0 taken 88% (fallthrough)
branch  1 taken 13%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        7:  425:                            VarInfo::AllocInfo& varAlloc = alloctype[innerTok->varId()];
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
        7:  426:                            varAlloc.type = f->groupId;
        7:  427:                            varAlloc.status = VarInfo::ALLOC;
        -:  428:                        } else {
        -:  429:                            // Fixme: warn about leak
        1:  430:                            alloctype.erase(innerTok->varId());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
        -:  431:                        }
        -:  432:
        8:  433:                        changeAllocStatusIfRealloc(alloctype, innerTok->tokAt(2), varTok);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        2:  434:                    } else if (mTokenizer->isCPP() && Token::Match(innerTok->tokAt(2), "new !!(")) {
call    0 returned 100%
branch  1 taken 50% (fallthrough)
branch  2 taken 50%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
branch  9 taken 100% (fallthrough)
branch 10 taken 0%
branch 11 taken 50% (fallthrough)
branch 12 taken 50%
        1:  435:                        const Token* tok2 = innerTok->tokAt(2)->astOperand1();
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
        1:  436:                        const bool arrayNew = (tok2 && (tok2->str() == "[" || (tok2->str() == "(" && tok2->astOperand1() && tok2->astOperand1()->str() == "[")));
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
call    6 never executed
call    7 never executed
branch  8 never executed
branch  9 never executed
call   10 never executed
branch 11 never executed
branch 12 never executed
call   13 never executed
call   14 never executed
call   15 never executed
branch 16 never executed
branch 17 never executed
        1:  437:                        VarInfo::AllocInfo& varAlloc = alloctype[innerTok->varId()];
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
        1:  438:                        varAlloc.type = arrayNew ? NEW_ARRAY : NEW;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  439:                        varAlloc.status = VarInfo::ALLOC;
        -:  440:                    }
        -:  441:                }
        -:  442:
        -:  443:                // check for function call
     3244:  444:                const Token * const openingPar = isFunctionCall(innerTok);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
     3244:  445:                if (openingPar) {
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        -:  446:                    // innerTok is a function name
       19:  447:                    const VarInfo::AllocInfo allocation(0, VarInfo::NOALLOC);
call    0 returned 100%
       19:  448:                    functionCall(innerTok, openingPar, varInfo, allocation, nullptr);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       19:  449:                    innerTok = openingPar->link();
call    0 returned 100%
        -:  450:                }
        -:  451:            }
        -:  452:
     3071:  453:            if (Token::simpleMatch(closingParenthesis, ") {")) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
     6142:  454:                VarInfo varInfo1(*varInfo);  // VarInfo for if code
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
call    4 returned 100%
     6142:  455:                VarInfo varInfo2(*varInfo);  // VarInfo for else code
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
call    4 returned 100%
        -:  456:
        -:  457:                // Recursively scan variable comparisons in condition
     6142:  458:                std::stack<const Token *> tokens;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
call    4 returned 100%
     3071:  459:                tokens.push(tok->next()->astOperand2());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
     9255:  460:                while (!tokens.empty()) {
call    0 returned 100%
branch  1 taken 50% (fallthrough)
branch  2 taken 50%
     3092:  461:                    const Token *tok3 = tokens.top();
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
     3092:  462:                    tokens.pop();
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
     3092:  463:                    if (!tok3)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
       16:  464:                        continue;
     3102:  465:                    if (tok3->str() == "&&" || tok3->str() == "||") {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 99% (fallthrough)
branch  3 taken 1%
call    4 returned 100%
call    5 returned 100%
branch  6 taken 1% (fallthrough)
branch  7 taken 99%
branch  8 taken 1% (fallthrough)
branch  9 taken 99%
        -:  466:                        // FIXME: handle && ! || better
       10:  467:                        tokens.push(tok3->astOperand1());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
       10:  468:                        tokens.push(tok3->astOperand2());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
       10:  469:                        continue;
        -:  470:                    }
     3083:  471:                    if (tok3->str() == "(" && Token::Match(tok3->astOperand1(), "UNLIKELY|LIKELY")) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 1% (fallthrough)
branch  3 taken 99%
call    4 returned 100%
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0% (throw)
branch  8 taken 17% (fallthrough)
branch  9 taken 83%
branch 10 taken 1% (fallthrough)
branch 11 taken 99%
        1:  472:                        tokens.push(tok3->astOperand2());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
        1:  473:                        continue;
     3081:  474:                    } else if (tok3->str() == "(" && Token::Match(tok3->previous(), "%name%")) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 1% (fallthrough)
branch  3 taken 99%
call    4 returned 100%
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0% (throw)
branch  8 taken 100% (fallthrough)
branch  9 taken 0%
branch 10 taken 1% (fallthrough)
branch 11 taken 99%
       10:  475:                        const std::vector<const Token *> params = getArguments(tok3->previous());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
call    5 never executed
       11:  476:                        for (const Token *par : params) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 55% (fallthrough)
branch  4 taken 45%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
        6:  477:                            if (!par->isComparisonOp())
call    0 returned 100%
branch  1 taken 83% (fallthrough)
branch  2 taken 17%
        5:  478:                                continue;
        1:  479:                            const Token *vartok = nullptr;
        7:  480:                            if (astIsVariableComparison(par, "!=", "0", &vartok) ||
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0% (throw)
call    8 returned 100%
branch  9 taken 100% (fallthrough)
branch 10 taken 0% (throw)
branch 11 taken 0% (fallthrough)
branch 12 taken 100%
branch 13 taken 100% (fallthrough)
branch 14 taken 0%
call   15 returned 100%
branch 16 taken 100% (fallthrough)
branch 17 taken 0%
call   18 returned 100%
branch 19 taken 100% (fallthrough)
branch 20 taken 0%
call   21 returned 100%
branch 22 taken 100% (fallthrough)
branch 23 taken 0%
call   24 returned 100%
branch 25 taken 100% (fallthrough)
branch 26 taken 0%
branch 27 never executed
branch 28 never executed
call   29 never executed
branch 30 never executed
branch 31 never executed
call   32 never executed
branch 33 never executed
branch 34 never executed
call   35 never executed
branch 36 never executed
branch 37 never executed
call   38 never executed
        4:  481:                                astIsVariableComparison(par, "==", "0", &vartok) ||
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0% (throw)
call    8 returned 100%
branch  9 taken 100% (fallthrough)
branch 10 taken 0% (throw)
branch 11 never executed
branch 12 never executed
branch 13 taken 100% (fallthrough)
branch 14 taken 0%
call   15 returned 100%
branch 16 taken 100% (fallthrough)
branch 17 taken 0%
call   18 returned 100%
branch 19 taken 100% (fallthrough)
branch 20 taken 0%
call   21 returned 100%
branch 22 taken 100% (fallthrough)
branch 23 taken 0%
call   24 returned 100%
branch 25 never executed
branch 26 never executed
call   27 never executed
branch 28 never executed
branch 29 never executed
call   30 never executed
branch 31 never executed
branch 32 never executed
call   33 never executed
branch 34 never executed
branch 35 never executed
call   36 never executed
        1:  482:                                astIsVariableComparison(par, "<", "0", &vartok) ||
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
call    8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 taken 0% (fallthrough)
branch 14 taken 100%
call   15 never executed
branch 16 taken 0% (fallthrough)
branch 17 taken 100%
call   18 never executed
branch 19 taken 0% (fallthrough)
branch 20 taken 100%
call   21 never executed
branch 22 taken 0% (fallthrough)
branch 23 taken 100%
call   24 never executed
branch 25 never executed
branch 26 never executed
call   27 never executed
branch 28 never executed
branch 29 never executed
call   30 never executed
branch 31 never executed
branch 32 never executed
call   33 never executed
branch 34 never executed
branch 35 never executed
call   36 never executed
        1:  483:                                astIsVariableComparison(par, ">", "0", &vartok) ||
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
call    8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 taken 0% (fallthrough)
branch 14 taken 100%
call   15 never executed
branch 16 taken 0% (fallthrough)
branch 17 taken 100%
call   18 never executed
branch 19 taken 0% (fallthrough)
branch 20 taken 100%
call   21 never executed
branch 22 taken 0% (fallthrough)
branch 23 taken 100%
call   24 never executed
branch 25 never executed
branch 26 never executed
call   27 never executed
branch 28 never executed
branch 29 never executed
call   30 never executed
branch 31 never executed
branch 32 never executed
call   33 never executed
branch 34 never executed
branch 35 never executed
call   36 never executed
        5:  484:                                astIsVariableComparison(par, "==", "-1", &vartok) ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
call    7 never executed
branch  8 never executed
branch  9 never executed
call   10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 taken 0% (fallthrough)
branch 16 taken 100%
call   17 never executed
branch 18 taken 0% (fallthrough)
branch 19 taken 100%
call   20 never executed
branch 21 taken 0% (fallthrough)
branch 22 taken 100%
call   23 never executed
branch 24 taken 0% (fallthrough)
branch 25 taken 100%
call   26 never executed
branch 27 never executed
branch 28 never executed
call   29 never executed
branch 30 never executed
branch 31 never executed
call   32 never executed
branch 33 never executed
branch 34 never executed
call   35 never executed
branch 36 never executed
branch 37 never executed
call   38 never executed
        1:  485:                                astIsVariableComparison(par, "!=", "-1", &vartok)) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
call    8 never executed
branch  9 never executed
branch 10 never executed
branch 11 taken 0% (fallthrough)
branch 12 taken 100%
call   13 never executed
branch 14 taken 0% (fallthrough)
branch 15 taken 100%
call   16 never executed
branch 17 taken 0% (fallthrough)
branch 18 taken 100%
call   19 never executed
branch 20 taken 0% (fallthrough)
branch 21 taken 100%
call   22 never executed
branch 23 never executed
branch 24 never executed
call   25 never executed
branch 26 never executed
branch 27 never executed
call   28 never executed
branch 29 never executed
branch 30 never executed
call   31 never executed
branch 32 never executed
branch 33 never executed
call   34 never executed
        1:  486:                                varInfo1.erase(vartok->varId());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
        1:  487:                                varInfo2.erase(vartok->varId());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
        -:  488:                            }
        -:  489:                        }
        5:  490:                        continue;
        -:  491:                    }
        -:  492:
     3076:  493:                    const Token *vartok = nullptr;
     3076:  494:                    if (astIsVariableComparison(tok3, "!=", "0", &vartok)) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0% (throw)
call    8 returned 100%
branch  9 taken 100% (fallthrough)
branch 10 taken 0% (throw)
call   11 returned 100%
call   12 returned 100%
call   13 returned 100%
call   14 returned 100%
branch 15 taken 1% (fallthrough)
branch 16 taken 99%
call   17 never executed
call   18 never executed
call   19 never executed
call   20 never executed
       29:  495:                        varInfo2.erase(vartok->varId());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
       29:  496:                        if (notzero.find(vartok->varId()) != notzero.end())
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
branch  8 taken 3% (fallthrough)
branch  9 taken 97%
call   10 never executed
        1:  497:                            varInfo2.clear();
call    0 returned 100%
     3047:  498:                    } else if (astIsVariableComparison(tok3, "==", "0", &vartok)) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0% (throw)
call    8 returned 100%
branch  9 taken 100% (fallthrough)
branch 10 taken 0% (throw)
call   11 returned 100%
call   12 returned 100%
call   13 returned 100%
call   14 returned 100%
branch 15 taken 1% (fallthrough)
branch 16 taken 99%
call   17 never executed
call   18 never executed
call   19 never executed
call   20 never executed
       15:  499:                        varInfo1.erase(vartok->varId());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
     3032:  500:                    } else if (astIsVariableComparison(tok3, "<", "0", &vartok)) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0% (throw)
call    8 returned 100%
branch  9 taken 100% (fallthrough)
branch 10 taken 0% (throw)
call   11 returned 100%
call   12 returned 100%
call   13 returned 100%
call   14 returned 100%
branch 15 taken 1% (fallthrough)
branch 16 taken 99%
call   17 never executed
call   18 never executed
call   19 never executed
call   20 never executed
        1:  501:                        varInfo1.erase(vartok->varId());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
     3031:  502:                    } else if (astIsVariableComparison(tok3, ">", "0", &vartok)) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0% (throw)
call    8 returned 100%
branch  9 taken 100% (fallthrough)
branch 10 taken 0% (throw)
call   11 returned 100%
call   12 returned 100%
call   13 returned 100%
call   14 returned 100%
branch 15 taken 0% (fallthrough)
branch 16 taken 100%
call   17 never executed
call   18 never executed
call   19 never executed
call   20 never executed
    #####:  503:                        varInfo2.erase(vartok->varId());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
     3031:  504:                    } else if (astIsVariableComparison(tok3, "==", "-1", &vartok)) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0% (throw)
call    8 returned 100%
branch  9 taken 100% (fallthrough)
branch 10 taken 0% (throw)
call   11 returned 100%
call   12 returned 100%
call   13 returned 100%
call   14 returned 100%
branch 15 taken 1% (fallthrough)
branch 16 taken 99%
call   17 never executed
call   18 never executed
call   19 never executed
call   20 never executed
        3:  505:                        varInfo1.erase(vartok->varId());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
        -:  506:                    }
        -:  507:                }
        -:  508:
     3072:  509:                checkScope(closingParenthesis->next(), &varInfo1, notzero, recursiveCount);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
call    4 returned 100%
branch  5 taken 99% (fallthrough)
branch  6 taken 1% (throw)
call    7 returned 100%
call    8 returned 100%
     3070:  510:                closingParenthesis = closingParenthesis->linkAt(1);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
     3070:  511:                if (Token::simpleMatch(closingParenthesis, "} else {")) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 33% (fallthrough)
branch  4 taken 67%
     2005:  512:                    checkScope(closingParenthesis->tokAt(2), &varInfo2, notzero, recursiveCount);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 1% (fallthrough)
branch  8 taken 99% (throw)
call    9 returned 100%
call   10 returned 100%
        7:  513:                    tok = closingParenthesis->linkAt(2)->previous();
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
        -:  514:                } else {
     2064:  515:                    tok = closingParenthesis->previous();
call    0 returned 100%
        -:  516:                }
        -:  517:
     4142:  518:                VarInfo old;
call    0 returned 100%
call    1 returned 100%
call    2 never executed
     2071:  519:                old.swap(*varInfo);
call    0 returned 100%
        -:  520:
     4142:  521:                std::map<int, VarInfo::AllocInfo>::const_iterator it;
call    0 returned 100%
call    1 returned 100%
call    2 never executed
        -:  522:
     2112:  523:                for (it = old.alloctype.begin(); it != old.alloctype.end(); ++it) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
branch  8 taken 2% (fallthrough)
branch  9 taken 98%
call   10 returned 100%
       41:  524:                    const int varId = it->first;
call    0 returned 100%
       41:  525:                    if (old.conditionalAlloc.find(varId) == old.conditionalAlloc.end())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
call    5 returned 100%
call    6 returned 100%
branch  7 taken 90% (fallthrough)
branch  8 taken 10%
call    9 never executed
       37:  526:                        continue;
       11:  527:                    if (varInfo1.alloctype.find(varId) == varInfo1.alloctype.end() ||
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 25% (fallthrough)
branch  6 taken 75%
branch  7 taken 0% (fallthrough)
branch  8 taken 100%
branch  9 taken 100% (fallthrough)
branch 10 taken 0%
call   11 returned 100%
branch 12 taken 100% (fallthrough)
branch 13 taken 0%
call   14 returned 100%
branch 15 taken 75% (fallthrough)
branch 16 taken 25%
branch 17 never executed
branch 18 never executed
call   19 never executed
branch 20 never executed
branch 21 never executed
call   22 never executed
        7:  528:                        varInfo2.alloctype.find(varId) == varInfo2.alloctype.end()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 25% (fallthrough)
branch  6 taken 75%
call    7 returned 100%
branch  8 taken 25% (fallthrough)
branch  9 taken 75%
call   10 returned 100%
branch 11 never executed
branch 12 never executed
call   13 never executed
branch 14 never executed
branch 15 never executed
call   16 never executed
        3:  529:                        varInfo1.erase(varId);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        3:  530:                        varInfo2.erase(varId);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  531:                    }
        -:  532:                }
        -:  533:
        -:  534:                // Conditional allocation in varInfo1
     2102:  535:                for (it = varInfo1.alloctype.begin(); it != varInfo1.alloctype.end(); ++it) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
branch  8 taken 1% (fallthrough)
branch  9 taken 99%
call   10 returned 100%
      128:  536:                    if (varInfo2.alloctype.find(it->first) == varInfo2.alloctype.end() &&
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
call    5 returned 100%
branch  6 taken 71% (fallthrough)
branch  7 taken 29%
branch  8 taken 50% (fallthrough)
branch  9 taken 50%
branch 10 taken 100% (fallthrough)
branch 11 taken 0%
call   12 returned 100%
branch 13 taken 100% (fallthrough)
branch 14 taken 0%
call   15 returned 100%
branch 16 taken 35% (fallthrough)
branch 17 taken 65%
branch 18 never executed
branch 19 never executed
call   20 never executed
branch 21 never executed
branch 22 never executed
call   23 never executed
       97:  537:                        old.alloctype.find(it->first) == old.alloctype.end()) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
call    5 returned 100%
branch  6 taken 71% (fallthrough)
branch  7 taken 29%
call    8 returned 100%
branch  9 taken 71% (fallthrough)
branch 10 taken 29%
call   11 returned 100%
branch 12 never executed
branch 13 never executed
call   14 never executed
branch 15 never executed
branch 16 never executed
call   17 never executed
       11:  538:                        varInfo->conditionalAlloc.insert(it->first);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
        -:  539:                    }
        -:  540:                }
        -:  541:
        -:  542:                // Conditional allocation in varInfo2
     2098:  543:                for (it = varInfo2.alloctype.begin(); it != varInfo2.alloctype.end(); ++it) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
branch  8 taken 1% (fallthrough)
branch  9 taken 99%
call   10 returned 100%
      108:  544:                    if (varInfo1.alloctype.find(it->first) == varInfo1.alloctype.end() &&
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
call    5 returned 100%
branch  6 taken 67% (fallthrough)
branch  7 taken 33%
branch  8 taken 0% (fallthrough)
branch  9 taken 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0%
call   12 returned 100%
branch 13 taken 100% (fallthrough)
branch 14 taken 0%
call   15 returned 100%
branch 16 taken 0% (fallthrough)
branch 17 taken 100%
branch 18 never executed
branch 19 never executed
call   20 never executed
branch 21 never executed
branch 22 never executed
call   23 never executed
       81:  545:                        old.alloctype.find(it->first) == old.alloctype.end()) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
call    5 returned 100%
branch  6 taken 67% (fallthrough)
branch  7 taken 33%
call    8 returned 100%
branch  9 taken 67% (fallthrough)
branch 10 taken 33%
call   11 returned 100%
branch 12 never executed
branch 13 never executed
call   14 never executed
branch 15 never executed
branch 16 never executed
call   17 never executed
    #####:  546:                        varInfo->conditionalAlloc.insert(it->first);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -:  547:                    }
        -:  548:                }
        -:  549:
        -:  550:                // Conditional allocation/deallocation
     2102:  551:                for (it = varInfo1.alloctype.begin(); it != varInfo1.alloctype.end(); ++it) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
branch  8 taken 1% (fallthrough)
branch  9 taken 99%
call   10 returned 100%
       31:  552:                    if (it->second.managed() && conditionalAlloc.find(it->first) != conditionalAlloc.end()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 55% (fallthrough)
branch  3 taken 45%
call    4 returned 100%
call    5 returned 100%
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 0% (fallthrough)
branch 11 taken 100%
branch 12 taken 55% (fallthrough)
branch 13 taken 45%
call   14 returned 100%
branch 15 taken 55% (fallthrough)
branch 16 taken 45%
call   17 returned 100%
branch 18 taken 0% (fallthrough)
branch 19 taken 100%
branch 20 never executed
branch 21 never executed
call   22 never executed
branch 23 never executed
branch 24 never executed
call   25 never executed
    #####:  553:                        varInfo->conditionalAlloc.erase(it->first);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  554:                        varInfo2.erase(it->first);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  555:                    }
        -:  556:                }
     2098:  557:                for (it = varInfo2.alloctype.begin(); it != varInfo2.alloctype.end(); ++it) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
branch  8 taken 1% (fallthrough)
branch  9 taken 99%
call   10 returned 100%
       27:  558:                    if (it->second.managed() && conditionalAlloc.find(it->first) != conditionalAlloc.end()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 11% (fallthrough)
branch  3 taken 89%
call    4 returned 100%
call    5 returned 100%
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 0% (fallthrough)
branch 11 taken 100%
branch 12 taken 11% (fallthrough)
branch 13 taken 89%
call   14 returned 100%
branch 15 taken 11% (fallthrough)
branch 16 taken 89%
call   17 returned 100%
branch 18 taken 0% (fallthrough)
branch 19 taken 100%
branch 20 never executed
branch 21 never executed
call   22 never executed
branch 23 never executed
branch 24 never executed
call   25 never executed
    #####:  559:                        varInfo->conditionalAlloc.erase(it->first);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  560:                        varInfo1.erase(it->first);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  561:                    }
        -:  562:                }
        -:  563:
     2071:  564:                alloctype.insert(varInfo1.alloctype.begin(), varInfo1.alloctype.end());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
call    5 returned 100%
call    6 returned 100%
call    7 never executed
call    8 never executed
     2071:  565:                alloctype.insert(varInfo2.alloctype.begin(), varInfo2.alloctype.end());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
call    5 returned 100%
call    6 returned 100%
call    7 never executed
call    8 never executed
        -:  566:
     2071:  567:                possibleUsage.insert(varInfo1.possibleUsage.begin(), varInfo1.possibleUsage.end());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
call    5 returned 100%
call    6 returned 100%
call    7 never executed
call    8 never executed
     2071:  568:                possibleUsage.insert(varInfo2.possibleUsage.begin(), varInfo2.possibleUsage.end());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
call    5 returned 100%
call    6 returned 100%
call    7 never executed
call    8 never executed
        -:  569:            }
        -:  570:        }
        -:  571:
        -:  572:        // unknown control.. (TODO: handle loops)
      455:  573:        else if ((Token::Match(tok, "%type% (") && Token::simpleMatch(tok->linkAt(1), ") {")) || Token::simpleMatch(tok, "do {")) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 33% (fallthrough)
branch  4 taken 67%
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0% (throw)
call    8 returned 100%
branch  9 taken 100% (fallthrough)
branch 10 taken 0% (throw)
branch 11 taken 93% (fallthrough)
branch 12 taken 7%
call   13 returned 100%
branch 14 taken 100% (fallthrough)
branch 15 taken 0% (throw)
branch 16 taken 1% (fallthrough)
branch 17 taken 99%
branch 18 taken 3% (fallthrough)
branch 19 taken 97%
       13:  574:            varInfo->clear();
call    0 returned 100%
       13:  575:            break;
        -:  576:        }
        -:  577:
        -:  578:        // return
      442:  579:        else if (tok->str() == "return") {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 10% (fallthrough)
branch  3 taken 90%
       45:  580:            ret(tok, *varInfo);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       45:  581:            varInfo->clear();
call    0 returned 100%
        -:  582:        }
        -:  583:
        -:  584:        // throw
      397:  585:        else if (mTokenizer->isCPP() && tok->str() == "throw") {
call    0 returned 100%
branch  1 taken 47% (fallthrough)
branch  2 taken 53%
call    3 returned 100%
call    4 returned 100%
branch  5 taken 4% (fallthrough)
branch  6 taken 96%
branch  7 taken 2% (fallthrough)
branch  8 taken 98%
        7:  586:            bool tryFound = false;
        7:  587:            const Scope* scope = tok->scope();
call    0 returned 100%
       31:  588:            while (scope && scope->isExecutable()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 63% (fallthrough)
branch  4 taken 37%
branch  5 taken 63% (fallthrough)
branch  6 taken 37%
       12:  589:                if (scope->type == Scope::eTry)
branch  0 taken 8% (fallthrough)
branch  1 taken 92%
        1:  590:                    tryFound = true;
       12:  591:                scope = scope->nestedIn;
        -:  592:            }
        -:  593:            // If the execution leaves the function then treat it as return
        7:  594:            if (!tryFound)
branch  0 taken 86% (fallthrough)
branch  1 taken 14%
        6:  595:                ret(tok, *varInfo);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        7:  596:            varInfo->clear();
call    0 returned 100%
        -:  597:        }
        -:  598:
        -:  599:        // delete
      390:  600:        else if (mTokenizer->isCPP() && tok->str() == "delete") {
call    0 returned 100%
branch  1 taken 46% (fallthrough)
branch  2 taken 54%
call    3 returned 100%
call    4 returned 100%
branch  5 taken 28% (fallthrough)
branch  6 taken 72%
branch  7 taken 13% (fallthrough)
branch  8 taken 87%
       50:  601:            const bool arrayDelete = Token::simpleMatch(tok->next(), "[ ]");
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
       50:  602:            if (arrayDelete)
branch  0 taken 30% (fallthrough)
branch  1 taken 70%
       15:  603:                tok = tok->tokAt(3);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  604:            else
       35:  605:                tok = tok->next();
call    0 returned 100%
       50:  606:            if (tok->str() == "(")
call    0 returned 100%
call    1 returned 100%
branch  2 taken 2% (fallthrough)
branch  3 taken 98%
        1:  607:                tok = tok->next();
call    0 returned 100%
       58:  608:            while (Token::Match(tok, "%name% ::|."))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 7% (fallthrough)
branch  4 taken 93%
        4:  609:                tok = tok->tokAt(2);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       50:  610:            const bool isnull = tok->hasKnownIntValue() && tok->values().front().intvalue == 0;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 4% (fallthrough)
branch  4 taken 96%
call    5 returned 100%
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0%
       50:  611:            if (!isnull && tok->varId() && tok->strAt(1) != "[") {
branch  0 taken 96% (fallthrough)
branch  1 taken 4%
call    2 returned 100%
branch  3 taken 96% (fallthrough)
branch  4 taken 4%
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0% (throw)
call    8 returned 100%
branch  9 taken 96% (fallthrough)
branch 10 taken 4%
branch 11 taken 88% (fallthrough)
branch 12 taken 12%
       44:  612:                const VarInfo::AllocInfo allocation(arrayDelete ? NEW_ARRAY : NEW, VarInfo::DEALLOC);
branch  0 taken 32% (fallthrough)
branch  1 taken 68%
call    2 returned 100%
       44:  613:                changeAllocStatus(varInfo, allocation, tok, tok);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  614:            }
        -:  615:        }
        -:  616:
        -:  617:        // Function call..
      340:  618:        else if (isFunctionCall(ftok)) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 40% (fallthrough)
branch  4 taken 60%
      136:  619:            const Token * openingPar = isFunctionCall(ftok);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
      136:  620:            const Library::AllocFunc* af = mSettings->library.getDeallocFuncInfo(ftok);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
      136:  621:            VarInfo::AllocInfo allocation(af ? af->groupId : 0, VarInfo::DEALLOC);
branch  0 taken 81% (fallthrough)
branch  1 taken 19%
call    2 returned 100%
      136:  622:            if (allocation.type == 0)
branch  0 taken 19% (fallthrough)
branch  1 taken 81%
       26:  623:                allocation.status = VarInfo::NOALLOC;
      136:  624:            functionCall(ftok, openingPar, varInfo, allocation, af);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  625:
      136:  626:            tok = ftok->next()->link();
call    0 returned 100%
call    1 returned 100%
        -:  627:
        -:  628:            // Handle scopes that might be noreturn
      136:  629:            if (allocation.status == VarInfo::NOALLOC && Token::simpleMatch(tok, ") ; }")) {
branch  0 taken 19% (fallthrough)
branch  1 taken 81%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
branch  5 taken 42% (fallthrough)
branch  6 taken 58%
branch  7 taken 8% (fallthrough)
branch  8 taken 92%
       11:  630:                const std::string &functionName(tok->link()->previous()->str());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
       11:  631:                bool unknown = false;
       11:  632:                if (mTokenizer->IsScopeNoReturn(tok->tokAt(2), &unknown)) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
branch  6 taken 100% (fallthrough)
branch  7 taken 0%
       11:  633:                    if (!unknown)
branch  0 taken 55% (fallthrough)
branch  1 taken 45%
        6:  634:                        varInfo->clear();
call    0 returned 100%
        5:  635:                    else if (!mSettings->library.isLeakIgnore(functionName) && !mSettings->library.isUse(functionName))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0% (throw)
branch  8 taken 100% (fallthrough)
branch  9 taken 0%
branch 10 taken 100% (fallthrough)
branch 11 taken 0%
        5:  636:                        varInfo->possibleUsageAll(functionName);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  637:                }
        -:  638:            }
        -:  639:
      136:  640:            continue;
        -:  641:        }
        -:  642:
        -:  643:        // goto => weird execution path
      204:  644:        else if (tok->str() == "goto") {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 1% (fallthrough)
branch  3 taken 99%
        1:  645:            varInfo->clear();
call    0 returned 100%
        -:  646:        }
        -:  647:
        -:  648:        // continue/break
      203:  649:        else if (Token::Match(tok, "continue|break ;")) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####:  650:            varInfo->clear();
call    0 never executed
        -:  651:        }
        -:  652:
        -:  653:        // Check smart pointer
      203:  654:        else if (Token::Match(ftok, "%name% <") && mSettings->library.isSmartPointer(tok)) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 11% (fallthrough)
branch  4 taken 89%
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0% (throw)
branch  8 taken 100% (fallthrough)
branch  9 taken 0%
branch 10 taken 11% (fallthrough)
branch 11 taken 89%
       23:  655:            const Token * typeEndTok = ftok->linkAt(1);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       23:  656:            if (!Token::Match(typeEndTok, "> %var% {|( %var% ,|)|}"))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 9% (fallthrough)
branch  4 taken 91%
        6:  657:                continue;
        -:  658:
       21:  659:            tok = typeEndTok->linkAt(2);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  660:
       21:  661:            const int varid = typeEndTok->next()->varId();
call    0 returned 100%
call    1 returned 100%
       21:  662:            if (isPointerReleased(typeEndTok->tokAt(2), endToken, varid))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
branch  6 taken 10% (fallthrough)
branch  7 taken 90%
        2:  663:                continue;
        -:  664:
       19:  665:            bool arrayDelete = false;
       19:  666:            if (Token::findsimplematch(ftok->next(), "[ ]", typeEndTok))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
branch  4 taken 11% (fallthrough)
branch  5 taken 89%
        2:  667:                arrayDelete = true;
        -:  668:
        -:  669:            // Check deleter
       19:  670:            const Token * deleterToken = nullptr;
       19:  671:            const Token * endDeleterToken = nullptr;
       19:  672:            const Library::AllocFunc* af = nullptr;
       19:  673:            if (Token::Match(ftok, "unique_ptr < %type% ,")) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 11% (fallthrough)
branch  4 taken 89%
        2:  674:                deleterToken = ftok->tokAt(4);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        2:  675:                endDeleterToken = typeEndTok;
       17:  676:            } else if (Token::Match(typeEndTok, "> %var% {|( %var% ,")) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 41% (fallthrough)
branch  4 taken 59%
        7:  677:                deleterToken = typeEndTok->tokAt(5);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        7:  678:                endDeleterToken = typeEndTok->linkAt(2);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  679:            }
       19:  680:            if (deleterToken) {
branch  0 taken 47% (fallthrough)
branch  1 taken 53%
        -:  681:                // Skip the decaying plus in expressions like +[](T*){}
        9:  682:                if (deleterToken->str() == "+") {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  683:                    deleterToken = deleterToken->next();
call    0 never executed
        -:  684:                }
        -:  685:                // Check if its a pointer to a function
        9:  686:                const Token * dtok = Token::findmatch(deleterToken, "& %name%", endDeleterToken);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        9:  687:                if (dtok) {
branch  0 taken 22% (fallthrough)
branch  1 taken 78%
        2:  688:                    af = mSettings->library.getDeallocFuncInfo(dtok->tokAt(1));
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        -:  689:                } else {
        7:  690:                    const Token * tscopeStart = nullptr;
        7:  691:                    const Token * tscopeEnd = nullptr;
        -:  692:                    // If the deleter is a lambda, check if it calls the dealloc function
       20:  693:                    if (deleterToken->str() == "[" &&
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 86% (fallthrough)
branch  5 taken 14%
       13:  694:                        Token::simpleMatch(deleterToken->link(), "] (") &&
branch  0 taken 86% (fallthrough)
branch  1 taken 14%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
branch  6 taken 100% (fallthrough)
branch  7 taken 0%
        -:  695:                        // TODO: Check for mutable keyword
        6:  696:                        Token::simpleMatch(deleterToken->link()->linkAt(1), ") {")) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
        6:  697:                        tscopeStart = deleterToken->link()->linkAt(1)->tokAt(1);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
        6:  698:                        tscopeEnd = tscopeStart->link();
call    0 returned 100%
        -:  699:                        // If the deleter is a class, check if class calls the dealloc function
        1:  700:                    } else if ((dtok = Token::findmatch(deleterToken, "%type%", endDeleterToken)) && dtok->type()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0%
branch  8 taken 100% (fallthrough)
branch  9 taken 0%
        1:  701:                        const Scope * tscope = dtok->type()->classScope;
call    0 returned 100%
        1:  702:                        if (tscope) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  703:                            tscopeStart = tscope->bodyStart;
        1:  704:                            tscopeEnd = tscope->bodyEnd;
        -:  705:                        }
        -:  706:                    }
        -:  707:
        7:  708:                    if (tscopeStart && tscopeEnd) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
       25:  709:                        for (const Token *tok2 = tscopeStart; tok2 != tscopeEnd; tok2 = tok2->next()) {
branch  0 taken 88% (fallthrough)
branch  1 taken 12%
call    2 returned 100%
       22:  710:                            af = mSettings->library.getDeallocFuncInfo(tok2);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       22:  711:                            if (af)
branch  0 taken 18% (fallthrough)
branch  1 taken 82%
        4:  712:                                break;
        -:  713:                        }
        -:  714:                    }
        -:  715:                }
        -:  716:            }
        -:  717:
       19:  718:            const Token * vtok = typeEndTok->tokAt(3);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       19:  719:            const VarInfo::AllocInfo allocation(af ? af->groupId : (arrayDelete ? NEW_ARRAY : NEW), VarInfo::OWNED);
branch  0 taken 32% (fallthrough)
branch  1 taken 68%
branch  2 taken 15% (fallthrough)
branch  3 taken 85%
call    4 returned 100%
       19:  720:            changeAllocStatus(varInfo, allocation, vtok, vtok);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  721:        }
        -:  722:    }
     3278:  723:}
        -:  724:
        -:  725:
function _ZN16CheckLeakAutoVar26checkTokenInsideExpressionEPK5TokenP7VarInfo called 8015 returned 100% blocks executed 76%
     8015:  726:const Token * CheckLeakAutoVar::checkTokenInsideExpression(const Token * const tok, VarInfo *varInfo)
        -:  727:{
        -:  728:    // Deallocation and then dereferencing pointer..
     8015:  729:    if (tok->varId() > 0) {
call    0 returned 100%
branch  1 taken 2% (fallthrough)
branch  2 taken 98%
        -:  730:        // TODO : Write a separate checker for this that uses valueFlowForward.
      386:  731:        const std::map<int, VarInfo::AllocInfo>::const_iterator var = varInfo->alloctype.find(tok->varId());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
call    5 returned 100%
call    6 returned 100%
call    7 never executed
call    8 never executed
      193:  732:        if (var != varInfo->alloctype.end()) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 7% (fallthrough)
branch  4 taken 93%
       13:  733:            bool unknown = false;
       13:  734:            if (var->second.status == VarInfo::DEALLOC && CheckNullPointer::isPointerDeRef(tok, unknown, mSettings) && !unknown) {
call    0 returned 100%
branch  1 taken 69% (fallthrough)
branch  2 taken 31%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
branch  6 taken 56% (fallthrough)
branch  7 taken 44%
branch  8 taken 100% (fallthrough)
branch  9 taken 0%
branch 10 taken 38% (fallthrough)
branch 11 taken 62%
        5:  735:                deallocUseError(tok, tok->str());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
        8:  736:            } else if (Token::simpleMatch(tok->tokAt(-2), "= &")) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
branch  6 taken 13% (fallthrough)
branch  7 taken 88%
        1:  737:                varInfo->erase(tok->varId());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
        7:  738:            } else if (Token::Match(tok->previous(), "= %var% [;,)]")) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
    #####:  739:                varInfo->erase(tok->varId());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  740:            }
      180:  741:        } else if (Token::Match(tok->previous(), "& %name% = %var% ;")) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
    #####:  742:            varInfo->referenced.insert(tok->tokAt(2)->varId());
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
        -:  743:        }
        -:  744:    }
        -:  745:
        -:  746:    // check for function call
     8015:  747:    const Token * const openingPar = isFunctionCall(tok);
call    0 returned 100%
     8015:  748:    if (openingPar) {
branch  0 taken 2% (fallthrough)
branch  1 taken 98%
      132:  749:        const Library::AllocFunc* allocFunc = mSettings->library.getDeallocFuncInfo(tok);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
      132:  750:        VarInfo::AllocInfo alloc(allocFunc ? allocFunc->groupId : 0, VarInfo::DEALLOC);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
      132:  751:        if (alloc.type == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
      132:  752:            alloc.status = VarInfo::NOALLOC;
      132:  753:        functionCall(tok, openingPar, varInfo, alloc, nullptr);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
      132:  754:        return openingPar->link();
call    0 returned 100%
        -:  755:    }
        -:  756:
     7883:  757:    return nullptr;
        -:  758:}
        -:  759:
        -:  760:
function _ZN16CheckLeakAutoVar26changeAllocStatusIfReallocERNSt7__debug3mapIiN7VarInfo9AllocInfoESt4lessIiESaISt4pairIKiS3_EEEEPK5TokenSE_ called 102 returned 100% blocks executed 85%
      102:  761:void CheckLeakAutoVar::changeAllocStatusIfRealloc(std::map<int, VarInfo::AllocInfo> &alloctype, const Token *fTok, const Token *retTok)
        -:  762:{
      102:  763:    const Library::AllocFunc* f = mSettings->library.getReallocFuncInfo(fTok);
call    0 returned 100%
      102:  764:    if (f && f->arg == -1 && f->reallocArg > 0 && f->reallocArg <= numberOfArguments(fTok)) {
branch  0 taken 8% (fallthrough)
branch  1 taken 92%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0%
branch  9 taken 8% (fallthrough)
branch 10 taken 92%
        8:  765:        const Token* argTok = getArguments(fTok).at(f->reallocArg - 1);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
call    5 never executed
call    6 never executed
        8:  766:        VarInfo::AllocInfo& argAlloc = alloctype[argTok->varId()];
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 never executed
        8:  767:        VarInfo::AllocInfo& retAlloc = alloctype[retTok->varId()];
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
        8:  768:        if (argAlloc.type != 0 && argAlloc.type != f->groupId)
branch  0 taken 88% (fallthrough)
branch  1 taken 13%
branch  2 taken 29% (fallthrough)
branch  3 taken 71%
        2:  769:            mismatchError(fTok, argTok->str());
call    0 returned 100%
call    1 returned 100%
        8:  770:        argAlloc.status = VarInfo::DEALLOC;
        8:  771:        retAlloc.type = f->groupId;
        8:  772:        retAlloc.status = VarInfo::ALLOC;
        -:  773:    }
      102:  774:}
        -:  775:
        -:  776:
function _ZN16CheckLeakAutoVar17changeAllocStatusEP7VarInfoRKNS0_9AllocInfoEPK5TokenS7_ called 197 returned 100% blocks executed 89%
      197:  777:void CheckLeakAutoVar::changeAllocStatus(VarInfo *varInfo, const VarInfo::AllocInfo& allocation, const Token* tok, const Token* arg)
        -:  778:{
      197:  779:    std::map<int, VarInfo::AllocInfo> &alloctype = varInfo->alloctype;
      394:  780:    const std::map<int, VarInfo::AllocInfo>::iterator var = alloctype.find(arg->varId());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
call    5 never executed
      197:  781:    if (var != alloctype.end()) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 57% (fallthrough)
branch  4 taken 43%
      112:  782:        if (allocation.status == VarInfo::NOALLOC) {
branch  0 taken 18% (fallthrough)
branch  1 taken 82%
        -:  783:            // possible usage
       20:  784:            varInfo->possibleUsage[arg->varId()] = tok->str();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0% (throw)
       20:  785:            if (var->second.status == VarInfo::DEALLOC && arg->previous()->str() == "&")
call    0 returned 100%
branch  1 taken 35% (fallthrough)
branch  2 taken 65%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
branch  6 taken 71% (fallthrough)
branch  7 taken 29%
branch  8 taken 25% (fallthrough)
branch  9 taken 75%
        5:  786:                varInfo->erase(arg->varId());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
       92:  787:        } else if (var->second.managed()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 22% (fallthrough)
branch  3 taken 78%
       20:  788:            doubleFreeError(tok, arg->str(), allocation.type);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
       72:  789:        } else if (var->second.type != allocation.type) {
call    0 returned 100%
branch  1 taken 15% (fallthrough)
branch  2 taken 85%
        -:  790:            // mismatching allocation and deallocation
       11:  791:            mismatchError(tok, arg->str());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
       11:  792:            varInfo->erase(arg->varId());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
        -:  793:        } else {
        -:  794:            // deallocation
       61:  795:            var->second.status = allocation.status;
call    0 returned 100%
       61:  796:            var->second.type = allocation.type;
call    0 returned 100%
        -:  797:        }
       85:  798:    } else if (allocation.status != VarInfo::NOALLOC) {
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
       76:  799:        alloctype[arg->varId()].status = VarInfo::DEALLOC;
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
        -:  800:    }
      197:  801:}
        -:  802:
function _ZN16CheckLeakAutoVar12functionCallEPK5TokenS2_P7VarInfoRKNS3_9AllocInfoEPKN7Library9AllocFuncE called 287 returned 100% blocks executed 76%
      287:  803:void CheckLeakAutoVar::functionCall(const Token *tokName, const Token *tokOpeningPar, VarInfo *varInfo, const VarInfo::AllocInfo& allocation, const Library::AllocFunc* af)
        -:  804:{
        -:  805:    // Ignore function call?
      287:  806:    if (mSettings->library.isLeakIgnore(tokName->str()))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  807:        return;
      287:  808:    if (mSettings->library.getReallocFuncInfo(tokName))
call    0 returned 100%
branch  1 taken 3% (fallthrough)
branch  2 taken 97%
        8:  809:        return;
        -:  810:
      279:  811:    const Token * const tokFirstArg = tokOpeningPar->next();
call    0 returned 100%
      279:  812:    if (!tokFirstArg || tokFirstArg->str() == ")") {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 8% (fallthrough)
branch  5 taken 92%
branch  6 taken 8% (fallthrough)
branch  7 taken 92%
        -:  813:        // no arguments
       21:  814:        return;
        -:  815:    }
        -:  816:
      258:  817:    int argNr = 1;
      539:  818:    for (const Token *arg = tokFirstArg; arg; arg = arg->nextArgument()) {
branch  0 taken 52% (fallthrough)
branch  1 taken 48%
call    2 returned 100%
      281:  819:        if (mTokenizer->isCPP() && arg->str() == "new") {
call    0 returned 100%
branch  1 taken 27% (fallthrough)
branch  2 taken 73%
call    3 returned 100%
call    4 returned 100%
branch  5 taken 4% (fallthrough)
branch  6 taken 96%
branch  7 taken 1% (fallthrough)
branch  8 taken 99%
        3:  820:            arg = arg->next();
call    0 returned 100%
        3:  821:            if (Token::simpleMatch(arg, "( std :: nothrow )"))
call    0 returned 100%
branch  1 taken 33% (fallthrough)
branch  2 taken 67%
        1:  822:                arg = arg->tokAt(5);
call    0 returned 100%
        -:  823:        }
        -:  824:
        -:  825:        // Skip casts
      285:  826:        while (arg && arg->isCast())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 1% (fallthrough)
branch  4 taken 99%
branch  5 taken 1% (fallthrough)
branch  6 taken 99%
        2:  827:            arg = arg->astOperand2() ? arg->astOperand2() : arg->astOperand1();
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
call    4 returned 100%
      281:  828:        const Token * const argTypeStartTok = arg;
        -:  829:
      293:  830:        while (Token::Match(arg, "%name% .|:: %name%"))
call    0 returned 100%
branch  1 taken 2% (fallthrough)
branch  2 taken 98%
        6:  831:            arg = arg->tokAt(2);
call    0 returned 100%
        -:  832:
      281:  833:        if (Token::Match(arg, "%var% [-,)] !!.") || Token::Match(arg, "& %var%")) {
call    0 returned 100%
branch  1 taken 54% (fallthrough)
branch  2 taken 46%
call    3 returned 100%
branch  4 taken 4% (fallthrough)
branch  5 taken 96%
branch  6 taken 48% (fallthrough)
branch  7 taken 52%
        -:  834:            // goto variable
      135:  835:            if (arg->str() == "&")
call    0 returned 100%
call    1 returned 100%
branch  2 taken 4% (fallthrough)
branch  3 taken 96%
        6:  836:                arg = arg->next();
call    0 returned 100%
        -:  837:
      135:  838:            const bool isnull = arg->hasKnownIntValue() && arg->values().front().intvalue == 0;
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 99%
call    3 returned 100%
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0%
        -:  839:
        -:  840:            // Is variable allocated?
      135:  841:            if (!isnull && (!af || af->arg == argNr))
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
branch  2 taken 78% (fallthrough)
branch  3 taken 22%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
      133:  842:                changeAllocStatus(varInfo, allocation, tokName, arg);
call    0 returned 100%
        -:  843:        }
        -:  844:        // Check smart pointer
      146:  845:        else if (Token::Match(arg, "%name% < %type%") && mSettings->library.isSmartPointer(argTypeStartTok)) {
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 99%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 taken 1% (fallthrough)
branch  7 taken 99%
        1:  846:            const Token * typeEndTok = arg->linkAt(1);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:  847:            if (!Token::Match(typeEndTok, "> {|( %var% ,|)|}"))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####:  848:                continue;
        -:  849:
        1:  850:            bool arrayDelete = false;
        1:  851:            if (Token::findsimplematch(arg->next(), "[ ]", typeEndTok))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
    #####:  852:                arrayDelete = true;
        -:  853:
        -:  854:            // Check deleter
        1:  855:            const Token * deleterToken = nullptr;
        1:  856:            const Token * endDeleterToken = nullptr;
        1:  857:            const Library::AllocFunc* sp_af = nullptr;
        1:  858:            if (Token::Match(arg, "unique_ptr < %type% ,")) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####:  859:                deleterToken = arg->tokAt(4);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  860:                endDeleterToken = typeEndTok;
        1:  861:            } else if (Token::Match(typeEndTok, "> {|( %var% ,")) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####:  862:                deleterToken = typeEndTok->tokAt(4);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  863:                endDeleterToken = typeEndTok->linkAt(1);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  864:            }
        1:  865:            if (deleterToken) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  866:                // Check if its a pointer to a function
    #####:  867:                const Token * dtok = Token::findmatch(deleterToken, "& %name%", endDeleterToken);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  868:                if (dtok) {
branch  0 never executed
branch  1 never executed
    #####:  869:                    sp_af = mSettings->library.getDeallocFuncInfo(dtok->tokAt(1));
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -:  870:                } else {
        -:  871:                    // If the deleter is a class, check if class calls the dealloc function
    #####:  872:                    dtok = Token::findmatch(deleterToken, "%type%", endDeleterToken);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  873:                    if (dtok && dtok->type()) {
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:  874:                        const Scope * tscope = dtok->type()->classScope;
call    0 never executed
    #####:  875:                        for (const Token *tok2 = tscope->bodyStart; tok2 != tscope->bodyEnd; tok2 = tok2->next()) {
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  876:                            sp_af = mSettings->library.getDeallocFuncInfo(tok2);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  877:                            if (sp_af)
branch  0 never executed
branch  1 never executed
    #####:  878:                                break;
        -:  879:                        }
        -:  880:                    }
        -:  881:                }
        -:  882:            }
        -:  883:
        1:  884:            const Token * vtok = typeEndTok->tokAt(2);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:  885:            const VarInfo::AllocInfo sp_allocation(sp_af ? sp_af->groupId : (arrayDelete ? NEW_ARRAY : NEW), VarInfo::OWNED);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 returned 100%
        1:  886:            changeAllocStatus(varInfo, sp_allocation, vtok, vtok);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  887:        } else {
      145:  888:            checkTokenInsideExpression(arg, varInfo);
call    0 returned 100%
        -:  889:        }
        -:  890:        // TODO: check each token in argument expression (could contain multiple variables)
      281:  891:        argNr++;
        -:  892:    }
        -:  893:}
        -:  894:
        -:  895:
function _ZN16CheckLeakAutoVar15leakIfAllocatedEPK5TokenRK7VarInfo called 162 returned 100% blocks executed 71%
      162:  896:void CheckLeakAutoVar::leakIfAllocated(const Token *vartok,
        -:  897:                                       const VarInfo &varInfo)
        -:  898:{
      162:  899:    const std::map<int, VarInfo::AllocInfo> &alloctype = varInfo.alloctype;
      162:  900:    const std::map<int, std::string> &possibleUsage = varInfo.possibleUsage;
        -:  901:
      324:  902:    const std::map<int, VarInfo::AllocInfo>::const_iterator var = alloctype.find(vartok->varId());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
call    5 never executed
      162:  903:    if (var != alloctype.end() && var->second.status == VarInfo::ALLOC) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 9% (fallthrough)
branch  3 taken 91%
call    4 returned 100%
branch  5 taken 14% (fallthrough)
branch  6 taken 86%
branch  7 taken 100% (fallthrough)
branch  8 taken 0%
call    9 returned 100%
branch 10 taken 1% (fallthrough)
branch 11 taken 99%
        4:  904:        const std::map<int, std::string>::const_iterator use = possibleUsage.find(vartok->varId());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
call    5 never executed
        2:  905:        if (use == possibleUsage.end()) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
        2:  906:            leakError(vartok, vartok->str(), var->second.type);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
        -:  907:        } else {
    #####:  908:            configurationInfo(vartok, use->second);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  909:        }
        -:  910:    }
      162:  911:}
        -:  912:
function _ZN16CheckLeakAutoVar3retEPK5TokenRK7VarInfo called 252 returned 100% blocks executed 82%
      252:  913:void CheckLeakAutoVar::ret(const Token *tok, const VarInfo &varInfo)
        -:  914:{
      252:  915:    const std::map<int, VarInfo::AllocInfo> &alloctype = varInfo.alloctype;
      252:  916:    const std::map<int, std::string> &possibleUsage = varInfo.possibleUsage;
        -:  917:
      252:  918:    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
call    0 returned 100%
      403:  919:    for (std::map<int, VarInfo::AllocInfo>::const_iterator it = alloctype.begin(); it != alloctype.end(); ++it) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 37% (fallthrough)
branch  5 taken 63%
call    6 returned 100%
call    7 returned 100%
call    8 never executed
        -:  920:        // don't warn if variable is conditionally allocated
      151:  921:        if (!it->second.managed() && varInfo.conditionalAlloc.find(it->first) != varInfo.conditionalAlloc.end())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 26% (fallthrough)
branch  3 taken 74%
call    4 returned 100%
call    5 returned 100%
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 3% (fallthrough)
branch 11 taken 97%
branch 12 taken 26% (fallthrough)
branch 13 taken 74%
call   14 returned 100%
branch 15 taken 26% (fallthrough)
branch 16 taken 74%
call   17 returned 100%
branch 18 taken 1% (fallthrough)
branch 19 taken 99%
branch 20 never executed
branch 21 never executed
call   22 never executed
branch 23 never executed
branch 24 never executed
call   25 never executed
        2:  922:            continue;
        -:  923:
        -:  924:        // don't warn if there is a reference of the variable
      150:  925:        if (varInfo.referenced.find(it->first) != varInfo.referenced.end())
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
branch  8 taken 0% (fallthrough)
branch  9 taken 100%
call   10 never executed
    #####:  926:            continue;
        -:  927:
      150:  928:        const int varid = it->first;
call    0 returned 100%
      150:  929:        const Variable *var = symbolDatabase->getVariableFromVarId(varid);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
      150:  930:        if (var) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
      150:  931:            bool used = false;
      324:  932:            for (const Token *tok2 = tok; tok2; tok2 = tok2->next()) {
branch  0 taken 62% (fallthrough)
branch  1 taken 38%
call    2 returned 100%
      200:  933:                if (tok2->str() == ";")
call    0 returned 100%
call    1 returned 100%
branch  2 taken 10% (fallthrough)
branch  3 taken 91%
       19:  934:                    break;
      181:  935:                if (Token::Match(tok2, "return|(|{|, %varid% [});,]", varid)) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 3% (fallthrough)
branch  4 taken 97%
        6:  936:                    used = true;
        6:  937:                    break;
        -:  938:                }
      175:  939:                if (Token::Match(tok2, "return|(|{|, & %varid% . %name% [});,]", varid)) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 1% (fallthrough)
branch  4 taken 99%
        1:  940:                    used = true;
        1:  941:                    break;
        -:  942:                }
        -:  943:            }
        -:  944:
        -:  945:            // return deallocated pointer
      150:  946:            if (used && it->second.status == VarInfo::DEALLOC)
branch  0 taken 5% (fallthrough)
branch  1 taken 95%
call    2 returned 100%
branch  3 taken 14% (fallthrough)
branch  4 taken 86%
branch  5 taken 1% (fallthrough)
branch  6 taken 99%
        1:  947:                deallocReturnError(tok, var->name());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
        -:  948:
      149:  949:            else if (!used && !it->second.managed()) {
branch  0 taken 96% (fallthrough)
branch  1 taken 4%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 22% (fallthrough)
branch  5 taken 78%
branch  6 taken 21% (fallthrough)
branch  7 taken 79%
       64:  950:                const std::map<int, std::string>::const_iterator use = possibleUsage.find(varid);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
call    4 never executed
       32:  951:                if (use == possibleUsage.end()) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 59% (fallthrough)
branch  4 taken 41%
       19:  952:                    leakError(tok, var->name(), it->second.type);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
        -:  953:                } else {
       13:  954:                    configurationInfo(tok, use->second);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
        -:  955:                }
        -:  956:            }
        -:  957:        }
        -:  958:    }
function _GLOBAL__sub_I__ZN7VarInfo5printEv called 1 returned 100% blocks executed 100%
function _Z41__static_initialization_and_destruction_0ii called 1 returned 100% blocks executed 100%
      255:  959:}
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
