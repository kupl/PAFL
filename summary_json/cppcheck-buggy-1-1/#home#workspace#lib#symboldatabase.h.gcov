        -:    0:Source:/home/workspace/lib/symboldatabase.h
        -:    0:Graph:/home/workspace/build/lib/CMakeFiles/lib_objs.dir/valueflow.gcno
        -:    0:Data:/home/workspace/build/lib/CMakeFiles/lib_objs.dir/valueflow.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*
        -:    2: * Cppcheck - A tool for static C/C++ code analysis
        -:    3: * Copyright (C) 2007-2019 Cppcheck team.
        -:    4: *
        -:    5: * This program is free software: you can redistribute it and/or modify
        -:    6: * it under the terms of the GNU General Public License as published by
        -:    7: * the Free Software Foundation, either version 3 of the License, or
        -:    8: * (at your option) any later version.
        -:    9: *
        -:   10: * This program is distributed in the hope that it will be useful,
        -:   11: * but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   12: * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   13: * GNU General Public License for more details.
        -:   14: *
        -:   15: * You should have received a copy of the GNU General Public License
        -:   16: * along with this program.  If not, see <http://www.gnu.org/licenses/>.
        -:   17: */
        -:   18:
        -:   19://---------------------------------------------------------------------------
        -:   20:#ifndef symboldatabaseH
        -:   21:#define symboldatabaseH
        -:   22://---------------------------------------------------------------------------
        -:   23:
        -:   24:#include "config.h"
        -:   25:#include "library.h"
        -:   26:#include "mathlib.h"
        -:   27:#include "platform.h"
        -:   28:#include "token.h"
        -:   29:
        -:   30:#include <cstddef>
        -:   31:#include <list>
        -:   32:#include <map>
        -:   33:#include <set>
        -:   34:#include <string>
        -:   35:#include <utility>
        -:   36:#include <vector>
        -:   37:
        -:   38:class ErrorLogger;
        -:   39:class Function;
        -:   40:class Scope;
        -:   41:class Settings;
        -:   42:class SymbolDatabase;
        -:   43:class Tokenizer;
        -:   44:class ValueType;
        -:   45:
        -:   46:/**
        -:   47: * @brief Access control enumerations.
        -:   48: */
        -:   49:enum class AccessControl { Public, Protected, Private, Global, Namespace, Argument, Local, Throw };
        -:   50:
        -:   51:/**
        -:   52: * @brief Array dimension information.
        -:   53: */
        -:   54:struct Dimension {
        -:   55:    Dimension() : tok(nullptr), num(0), known(true) { }
        -:   56:
        -:   57:    const Token *tok;    ///< size token
        -:   58:    MathLib::bigint num; ///< (assumed) dimension length when size is a number, 0 if not known
        -:   59:    bool known;          ///< Known size
        -:   60:};
        -:   61:
        -:   62:/** @brief Information about a class type. */
        -:   63:class CPPCHECKLIB Type {
        -:   64:public:
        -:   65:    const Token* classDef;     ///< Points to "class" token
        -:   66:    const Scope* classScope;
        -:   67:    const Scope* enclosingScope;
        -:   68:    enum class NeedInitialization {
        -:   69:        Unknown, True, False
        -:   70:    } needInitialization;
        -:   71:
        -:   72:    class BaseInfo {
        -:   73:    public:
        -:   74:        BaseInfo() :
        -:   75:            type(nullptr), nameTok(nullptr), access(AccessControl::Public), isVirtual(false) {
        -:   76:        }
        -:   77:
        -:   78:        std::string name;
        -:   79:        const Type* type;
        -:   80:        const Token* nameTok;
        -:   81:        AccessControl access;  // public/protected/private
        -:   82:        bool isVirtual;
        -:   83:        // allow ordering within containers
        -:   84:        bool operator<(const BaseInfo& rhs) const {
        -:   85:            return this->type < rhs.type;
        -:   86:        }
        -:   87:    };
        -:   88:
        -:   89:    struct FriendInfo {
        -:   90:        FriendInfo() :
        -:   91:            nameStart(nullptr), nameEnd(nullptr), type(nullptr) {
        -:   92:        }
        -:   93:
        -:   94:        const Token* nameStart;
        -:   95:        const Token* nameEnd;
        -:   96:        const Type* type;
        -:   97:    };
        -:   98:
        -:   99:    std::vector<BaseInfo> derivedFrom;
        -:  100:    std::vector<FriendInfo> friendList;
        -:  101:
        -:  102:    const Token * typeStart;
        -:  103:    const Token * typeEnd;
        -:  104:
        -:  105:    Type(const Token* classDef_ = nullptr, const Scope* classScope_ = nullptr, const Scope* enclosingScope_ = nullptr) :
        -:  106:        classDef(classDef_),
        -:  107:        classScope(classScope_),
        -:  108:        enclosingScope(enclosingScope_),
        -:  109:        needInitialization(NeedInitialization::Unknown),
        -:  110:        typeStart(nullptr),
        -:  111:        typeEnd(nullptr) {
        -:  112:        if (classDef_ && classDef_->str() == "enum")
        -:  113:            needInitialization = NeedInitialization::True;
        -:  114:        else if (classDef_ && classDef_->str() == "using") {
        -:  115:            typeStart = classDef->tokAt(3);
        -:  116:            typeEnd = typeStart;
        -:  117:            while (typeEnd->next() && typeEnd->next()->str() != ";")
        -:  118:                typeEnd = typeEnd->next();
        -:  119:        }
        -:  120:    }
        -:  121:
        -:  122:    const std::string& name() const;
        -:  123:
        -:  124:    const std::string& type() const {
        -:  125:        return classDef ? classDef->str() : emptyString;
        -:  126:    }
        -:  127:
function _ZNK4Type11isClassTypeEv called 0 returned 0% blocks executed 0%
    #####:  128:    bool isClassType() const {
    #####:  129:        return classDef && classDef->str() == "class";
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -:  130:    }
        -:  131:
function _ZNK4Type10isEnumTypeEv called 0 returned 0% blocks executed 0%
    #####:  132:    bool isEnumType() const {
    #####:  133:        return classDef && classDef->str() == "enum";
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -:  134:    }
        -:  135:
        -:  136:    bool isTypeAlias() const {
        -:  137:        return classDef && classDef->str() == "using";
        -:  138:    }
        -:  139:
function _ZNK4Type12isStructTypeEv called 0 returned 0% blocks executed 0%
    #####:  140:    bool isStructType() const {
    #####:  141:        return classDef && classDef->str() == "struct";
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -:  142:    }
        -:  143:
        -:  144:    const Token *initBaseInfo(const Token *tok, const Token *tok1);
        -:  145:
        -:  146:    const Function* getFunction(const std::string& funcName) const;
        -:  147:
        -:  148:    /**
        -:  149:    * Check for circulare dependencies, i.e. loops within the class hierarchy
        -:  150:    * @param ancestors list of ancestors. For internal usage only, clients should not supply this argument.
        -:  151:    * @return true if there is a circular dependency
        -:  152:    */
        -:  153:    bool hasCircularDependencies(std::set<BaseInfo>* ancestors = nullptr) const;
        -:  154:
        -:  155:    /**
        -:  156:    * Check for dependency
        -:  157:    * @param ancestor potential ancestor
        -:  158:    * @return true if there is a dependency
        -:  159:    */
        -:  160:    bool findDependency(const Type* ancestor) const;
        -:  161:
        -:  162:    bool isDerivedFrom(const std::string & ancestor) const;
        -:  163:};
        -:  164:
        -:  165:class CPPCHECKLIB Enumerator {
        -:  166:public:
        -:  167:    explicit Enumerator(const Scope * scope_) : scope(scope_), name(nullptr), value(0), start(nullptr), end(nullptr), value_known(false) { }
        -:  168:    const Scope * scope;
        -:  169:    const Token * name;
        -:  170:    MathLib::bigint value;
        -:  171:    const Token * start;
        -:  172:    const Token * end;
        -:  173:    bool value_known;
        -:  174:};
        -:  175:
        -:  176:/** @brief Information about a member variable. */
        -:  177:class CPPCHECKLIB Variable {
        -:  178:    /** @brief flags mask used to access specific bit. */
        -:  179:    enum {
        -:  180:        fIsMutable    = (1 << 0),   /** @brief mutable variable */
        -:  181:        fIsStatic     = (1 << 1),   /** @brief static variable */
        -:  182:        fIsConst      = (1 << 2),   /** @brief const variable */
        -:  183:        fIsExtern     = (1 << 3),   /** @brief extern variable */
        -:  184:        fIsClass      = (1 << 4),   /** @brief user defined type */
        -:  185:        fIsArray      = (1 << 5),   /** @brief array variable */
        -:  186:        fIsPointer    = (1 << 6),   /** @brief pointer variable */
        -:  187:        fIsReference  = (1 << 7),   /** @brief reference variable */
        -:  188:        fIsRValueRef  = (1 << 8),   /** @brief rvalue reference variable */
        -:  189:        fHasDefault   = (1 << 9),   /** @brief function argument with default value */
        -:  190:        fIsStlType    = (1 << 10),  /** @brief STL type ('std::') */
        -:  191:        fIsStlString  = (1 << 11),  /** @brief std::string|wstring|basic_string&lt;T&gt;|u16string|u32string */
        -:  192:        fIsFloatType  = (1 << 12),  /** @brief Floating point type */
        -:  193:        fIsVolatile   = (1 << 13),  /** @brief volatile */
        -:  194:        fIsSmartPointer = (1 << 14)   /** @brief std::shared_ptr|unique_ptr */
        -:  195:    };
        -:  196:
        -:  197:    /**
        -:  198:     * Get specified flag state.
        -:  199:     * @param flag_ flag to get state of
        -:  200:     * @return true if flag set or false in flag not set
        -:  201:     */
function _ZNK8Variable7getFlagEj called 0 returned 0% blocks executed 0%
    #####:  202:    bool getFlag(unsigned int flag_) const {
    #####:  203:        return ((mFlags & flag_) != 0);
        -:  204:    }
        -:  205:
        -:  206:    /**
        -:  207:     * Set specified flag state.
        -:  208:     * @param flag_ flag to set state
        -:  209:     * @param state_ new state of flag
        -:  210:     */
        -:  211:    void setFlag(unsigned int flag_, bool state_) {
        -:  212:        mFlags = state_ ? mFlags | flag_ : mFlags & ~flag_;
        -:  213:    }
        -:  214:
        -:  215:    /**
        -:  216:     * @brief parse and save array dimension information
        -:  217:     * @param settings Platform settings and library
        -:  218:     * @return true if array, false if not
        -:  219:     */
        -:  220:    bool arrayDimensions(const Settings* settings);
        -:  221:
        -:  222:public:
        -:  223:    Variable(const Token *name_, const Token *start_, const Token *end_,
        -:  224:             nonneg int index_, AccessControl access_, const Type *type_,
        -:  225:             const Scope *scope_, const Settings* settings)
        -:  226:        : mNameToken(name_),
        -:  227:          mTypeStartToken(start_),
        -:  228:          mTypeEndToken(end_),
        -:  229:          mIndex(index_),
        -:  230:          mAccess(access_),
        -:  231:          mFlags(0),
        -:  232:          mType(type_),
        -:  233:          mScope(scope_),
        -:  234:          mValueType(nullptr) {
        -:  235:        evaluate(settings);
        -:  236:    }
        -:  237:
        -:  238:    ~Variable();
        -:  239:
        -:  240:    /**
        -:  241:     * Get name token.
        -:  242:     * @return name token
        -:  243:     */
function _ZNK8Variable9nameTokenEv called 0 returned 0% blocks executed 0%
    #####:  244:    const Token *nameToken() const {
    #####:  245:        return mNameToken;
        -:  246:    }
        -:  247:
        -:  248:    /**
        -:  249:     * Get type start token.
        -:  250:     * The type start token doesn't account 'static' and 'const' qualifiers
        -:  251:     * E.g.:
        -:  252:     *     static const int * const p = ...;
        -:  253:     * type start token ^
        -:  254:     * @return type start token
        -:  255:     */
function _ZNK8Variable14typeStartTokenEv called 0 returned 0% blocks executed 0%
    #####:  256:    const Token *typeStartToken() const {
    #####:  257:        return mTypeStartToken;
        -:  258:    }
        -:  259:
        -:  260:    /**
        -:  261:     * Get type end token.
        -:  262:     * The type end token doesn't account the forward 'const' qualifier
        -:  263:     * E.g.:
        -:  264:     *     static const int * const p = ...;
        -:  265:     *       type end token ^
        -:  266:     * @return type end token
        -:  267:     */
function _ZNK8Variable12typeEndTokenEv called 0 returned 0% blocks executed 0%
    #####:  268:    const Token *typeEndToken() const {
    #####:  269:        return mTypeEndToken;
        -:  270:    }
        -:  271:
        -:  272:    /**
        -:  273:     * Get end token of variable declaration
        -:  274:     * E.g.
        -:  275:     * int i[2][3] = ...
        -:  276:     *   end token ^
        -:  277:     * @return variable declaration end token
        -:  278:     */
        -:  279:    const Token *declEndToken() const;
        -:  280:
        -:  281:    /**
        -:  282:     * Get name string.
        -:  283:     * @return name string
        -:  284:     */
function _ZNK8Variable4nameB5cxx11Ev called 0 returned 0% blocks executed 0%
    #####:  285:    const std::string &name() const {
        -:  286:        // name may not exist for function arguments
    #####:  287:        if (mNameToken)
branch  0 never executed
branch  1 never executed
    #####:  288:            return mNameToken->str();
call    0 never executed
        -:  289:
    #####:  290:        return emptyString;
        -:  291:    }
        -:  292:
        -:  293:    /**
        -:  294:     * Get declaration ID (varId used for variable in its declaration).
        -:  295:     * @return declaration ID
        -:  296:     */
function _ZNK8Variable13declarationIdEv called 0 returned 0% blocks executed 0%
    #####:  297:    nonneg int declarationId() const {
        -:  298:        // name may not exist for function arguments
    #####:  299:        if (mNameToken)
branch  0 never executed
branch  1 never executed
    #####:  300:            return mNameToken->varId();
call    0 never executed
        -:  301:
    #####:  302:        return 0;
        -:  303:    }
        -:  304:
        -:  305:    /**
        -:  306:     * Get index of variable in declared order.
        -:  307:     * @return variable index
        -:  308:     */
        -:  309:    nonneg int index() const {
        -:  310:        return mIndex;
        -:  311:    }
        -:  312:
        -:  313:    /**
        -:  314:     * Is variable public.
        -:  315:     * @return true if public, false if not
        -:  316:     */
        -:  317:    bool isPublic() const {
        -:  318:        return mAccess == AccessControl::Public;
        -:  319:    }
        -:  320:
        -:  321:    /**
        -:  322:     * Is variable protected.
        -:  323:     * @return true if protected, false if not
        -:  324:     */
        -:  325:    bool isProtected() const {
        -:  326:        return mAccess == AccessControl::Protected;
        -:  327:    }
        -:  328:
        -:  329:    /**
        -:  330:     * Is variable private.
        -:  331:     * @return true if private, false if not
        -:  332:     */
        -:  333:    bool isPrivate() const {
        -:  334:        return mAccess == AccessControl::Private;
        -:  335:    }
        -:  336:
        -:  337:    /**
        -:  338:     * Is variable global.
        -:  339:     * @return true if global, false if not
        -:  340:     */
function _ZNK8Variable8isGlobalEv called 0 returned 0% blocks executed 0%
    #####:  341:    bool isGlobal() const {
    #####:  342:        return mAccess == AccessControl::Global;
        -:  343:    }
        -:  344:
        -:  345:    /**
        -:  346:     * Is variable in a namespace.
        -:  347:     * @return true if in a namespace, false if not
        -:  348:     */
        -:  349:    bool isNamespace() const {
        -:  350:        return mAccess == AccessControl::Namespace;
        -:  351:    }
        -:  352:
        -:  353:    /**
        -:  354:     * Is variable a function argument.
        -:  355:     * @return true if a function argument, false if not
        -:  356:     */
function _ZNK8Variable10isArgumentEv called 0 returned 0% blocks executed 0%
    #####:  357:    bool isArgument() const {
    #####:  358:        return mAccess == AccessControl::Argument;
        -:  359:    }
        -:  360:
        -:  361:    /**
        -:  362:     * Is variable local.
        -:  363:     * @return true if local, false if not
        -:  364:     */
function _ZNK8Variable7isLocalEv called 0 returned 0% blocks executed 0%
    #####:  365:    bool isLocal() const {
    #####:  366:        return (mAccess == AccessControl::Local) && !isExtern();
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  367:    }
        -:  368:
        -:  369:    /**
        -:  370:     * Is variable mutable.
        -:  371:     * @return true if mutable, false if not
        -:  372:     */
        -:  373:    bool isMutable() const {
        -:  374:        return getFlag(fIsMutable);
        -:  375:    }
        -:  376:
        -:  377:    /**
        -:  378:     * Is variable volatile.
        -:  379:     * @return true if volatile, false if not
        -:  380:     */
function _ZNK8Variable10isVolatileEv called 0 returned 0% blocks executed 0%
    #####:  381:    bool isVolatile() const {
    #####:  382:        return getFlag(fIsVolatile);
call    0 never executed
        -:  383:    }
        -:  384:
        -:  385:    /**
        -:  386:     * Is variable static.
        -:  387:     * @return true if static, false if not
        -:  388:     */
function _ZNK8Variable8isStaticEv called 0 returned 0% blocks executed 0%
    #####:  389:    bool isStatic() const {
    #####:  390:        return getFlag(fIsStatic);
call    0 never executed
        -:  391:    }
        -:  392:
        -:  393:    /**
        -:  394:     * Is variable extern.
        -:  395:     * @return true if extern, false if not
        -:  396:     */
function _ZNK8Variable8isExternEv called 0 returned 0% blocks executed 0%
    #####:  397:    bool isExtern() const {
    #####:  398:        return getFlag(fIsExtern);
call    0 never executed
        -:  399:    }
        -:  400:
        -:  401:    /**
        -:  402:     * Is variable const.
        -:  403:     * @return true if const, false if not
        -:  404:     */
function _ZNK8Variable7isConstEv called 0 returned 0% blocks executed 0%
    #####:  405:    bool isConst() const {
    #####:  406:        return getFlag(fIsConst);
call    0 never executed
        -:  407:    }
        -:  408:
        -:  409:    /**
        -:  410:     * Is variable a throw type.
        -:  411:     * @return true if throw type, false if not
        -:  412:     */
function _ZNK8Variable7isThrowEv called 0 returned 0% blocks executed 0%
    #####:  413:    bool isThrow() const {
    #####:  414:        return mAccess == AccessControl::Throw;
        -:  415:    }
        -:  416:
        -:  417:    /**
        -:  418:     * Is variable a user defined (or unknown) type.
        -:  419:     * @return true if user defined type, false if not
        -:  420:     */
function _ZNK8Variable7isClassEv called 0 returned 0% blocks executed 0%
    #####:  421:    bool isClass() const {
    #####:  422:        return getFlag(fIsClass);
call    0 never executed
        -:  423:    }
        -:  424:
        -:  425:    /**
        -:  426:     * Is variable an array.
        -:  427:     * @return true if array, false if not
        -:  428:     */
function _ZNK8Variable7isArrayEv called 0 returned 0% blocks executed 0%
    #####:  429:    bool isArray() const {
    #####:  430:        return getFlag(fIsArray) && !getFlag(fIsPointer);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -:  431:    }
        -:  432:
        -:  433:    /**
        -:  434:     * Is pointer variable.
        -:  435:     * @return true if pointer, false otherwise
        -:  436:     */
function _ZNK8Variable9isPointerEv called 0 returned 0% blocks executed 0%
    #####:  437:    bool isPointer() const {
    #####:  438:        return getFlag(fIsPointer);
call    0 never executed
        -:  439:    }
        -:  440:
        -:  441:    /**
        -:  442:     * Is variable a pointer to an array
        -:  443:     * @return true if pointer to array, false otherwise
        -:  444:     */
        -:  445:    bool isPointerToArray() const {
        -:  446:        return isPointer() && getFlag(fIsArray);
        -:  447:    }
        -:  448:
        -:  449:    /**
        -:  450:     * Is variable an array of pointers
        -:  451:     * @return true if array or pointers, false otherwise
        -:  452:     */
        -:  453:    bool isPointerArray() const;
        -:  454:
        -:  455:    /**
        -:  456:     * Is array or pointer variable.
        -:  457:     * @return true if pointer or array, false otherwise
        -:  458:     */
        -:  459:    bool isArrayOrPointer() const {
        -:  460:        return getFlag(fIsArray) || getFlag(fIsPointer);
        -:  461:    }
        -:  462:
        -:  463:    /**
        -:  464:     * Is reference variable.
        -:  465:     * @return true if reference, false otherwise
        -:  466:     */
function _ZNK8Variable11isReferenceEv called 0 returned 0% blocks executed 0%
    #####:  467:    bool isReference() const {
    #####:  468:        return getFlag(fIsReference);
call    0 never executed
        -:  469:    }
        -:  470:
        -:  471:    /**
        -:  472:     * Is reference variable.
        -:  473:     * @return true if reference, false otherwise
        -:  474:     */
function _ZNK8Variable17isRValueReferenceEv called 0 returned 0% blocks executed 0%
    #####:  475:    bool isRValueReference() const {
    #####:  476:        return getFlag(fIsRValueRef);
call    0 never executed
        -:  477:    }
        -:  478:
        -:  479:    /**
        -:  480:     * Does variable have a default value.
        -:  481:     * @return true if has a default falue, false if not
        -:  482:     */
function _ZNK8Variable10hasDefaultEv called 0 returned 0% blocks executed 0%
    #####:  483:    bool hasDefault() const {
    #####:  484:        return getFlag(fHasDefault);
call    0 never executed
        -:  485:    }
        -:  486:
        -:  487:    /**
        -:  488:     * Get Type pointer of known type.
        -:  489:     * @return pointer to type if known, NULL if not known
        -:  490:     */
function _ZNK8Variable4typeEv called 0 returned 0% blocks executed 0%
    #####:  491:    const Type *type() const {
    #####:  492:        return mType;
        -:  493:    }
        -:  494:
        -:  495:    /**
        -:  496:     * Get Scope pointer of known type.
        -:  497:     * @return pointer to type scope if known, NULL if not known
        -:  498:     */
        -:  499:    const Scope *typeScope() const {
        -:  500:        return mType ? mType->classScope : nullptr;
        -:  501:    }
        -:  502:
        -:  503:    /**
        -:  504:     * Get Scope pointer of enclosing scope.
        -:  505:     * @return pointer to enclosing scope
        -:  506:     */
function _ZNK8Variable5scopeEv called 0 returned 0% blocks executed 0%
    #####:  507:    const Scope *scope() const {
    #####:  508:        return mScope;
        -:  509:    }
        -:  510:
        -:  511:    /**
        -:  512:     * Get array dimensions.
        -:  513:     * @return array dimensions vector
        -:  514:     */
function _ZNK8Variable10dimensionsEv called 0 returned 0% blocks executed 0%
    #####:  515:    const std::vector<Dimension> &dimensions() const {
    #####:  516:        return mDimensions;
        -:  517:    }
        -:  518:
        -:  519:    /**
        -:  520:     * Get array dimension length.
        -:  521:     * @return length of dimension
        -:  522:     */
function _ZNK8Variable9dimensionEi called 0 returned 0% blocks executed 0%
    #####:  523:    MathLib::bigint dimension(nonneg int index_) const {
    #####:  524:        return mDimensions[index_].num;
call    0 never executed
        -:  525:    }
        -:  526:
        -:  527:    /**
        -:  528:     * Get array dimension known.
        -:  529:     * @return length of dimension known
        -:  530:     */
function _ZNK8Variable14dimensionKnownEi called 0 returned 0% blocks executed 0%
    #####:  531:    bool dimensionKnown(nonneg int index_) const {
    #####:  532:        return mDimensions[index_].known;
call    0 never executed
        -:  533:    }
        -:  534:
        -:  535:    /**
        -:  536:    * Checks if the variable is an STL type ('std::')
        -:  537:    * E.g.:
        -:  538:    *   std::string s;
        -:  539:    *   ...
        -:  540:    *   sVar->isStlType() == true
        -:  541:    * @return true if it is an stl type and its type matches any of the types in 'stlTypes'
        -:  542:    */
function _ZNK8Variable9isStlTypeEv called 0 returned 0% blocks executed 0%
    #####:  543:    bool isStlType() const {
    #####:  544:        return getFlag(fIsStlType);
call    0 never executed
        -:  545:    }
        -:  546:
        -:  547:    /**
        -:  548:     * Checks if the variable is an STL type ('std::')
        -:  549:     * E.g.:
        -:  550:     *   std::string s;
        -:  551:     *   ...
        -:  552:     *   sVar->isStlType() == true
        -:  553:     * @return true if it is an stl type and its type matches any of the types in 'stlTypes'
        -:  554:     */
        -:  555:    bool isStlStringType() const {
        -:  556:        return getFlag(fIsStlString);
        -:  557:    }
        -:  558:
function _ZNK8Variable14isSmartPointerEv called 0 returned 0% blocks executed 0%
    #####:  559:    bool isSmartPointer() const {
    #####:  560:        return getFlag(fIsSmartPointer);
call    0 never executed
        -:  561:    }
        -:  562:
        -:  563:    const Type *smartPointerType() const;
        -:  564:
        -:  565:    /**
        -:  566:     * Checks if the variable is of any of the STL types passed as arguments ('std::')
        -:  567:     * E.g.:
        -:  568:     *   std::string s;
        -:  569:     *   ...
        -:  570:     *   const char *str[] = {"string", "wstring"};
        -:  571:     *   sVar->isStlType(str) == true
        -:  572:     * @param stlType stl type
        -:  573:     * @return true if it is an stl type and its type matches any of the types in 'stlTypes'
        -:  574:     */
        -:  575:    bool isStlType(const std::string& stlType) const {
        -:  576:        return isStlType() && stlType==mTypeStartToken->strAt(2);
        -:  577:    }
        -:  578:
        -:  579:    /**
        -:  580:     * Checks if the variable is of any of the STL types passed as arguments ('std::')
        -:  581:     * E.g.:
        -:  582:     *   std::string s;
        -:  583:     *   ...
        -:  584:     *   const std::set<std::string> str = make_container< std::set<std::string> >() << "string" << "wstring";
        -:  585:     *   sVar->isStlType(str) == true
        -:  586:     * @param stlTypes set of stl types
        -:  587:     * @return true if it is an stl type and its type matches any of the types in 'stlTypes'
        -:  588:     */
        -:  589:    bool isStlType(const std::set<std::string>& stlTypes) const {
        -:  590:        return isStlType() && stlTypes.find(mTypeStartToken->strAt(2))!=stlTypes.end();
        -:  591:    }
        -:  592:
        -:  593:    /**
        -:  594:    * Determine whether it's a floating number type
        -:  595:    * @return true if the type is known and it's a floating type (float, double and long double) or a pointer/array to it
        -:  596:    */
        -:  597:    bool isFloatingType() const {
        -:  598:        return getFlag(fIsFloatType);
        -:  599:    }
        -:  600:
        -:  601:    /**
        -:  602:    * Determine whether it's an enumeration type
        -:  603:    * @return true if the type is known and it's an enumeration type
        -:  604:    */
function _ZNK8Variable10isEnumTypeEv called 0 returned 0% blocks executed 0%
    #####:  605:    bool isEnumType() const {
    #####:  606:        return type() && type()->isEnumType();
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
        -:  607:    }
        -:  608:
function _ZNK8Variable9valueTypeEv called 0 returned 0% blocks executed 0%
    #####:  609:    const ValueType *valueType() const {
    #####:  610:        return mValueType;
        -:  611:    }
        -:  612:
        -:  613:    void setValueType(const ValueType &valueType);
        -:  614:
        -:  615:    AccessControl accessControl() const {
        -:  616:        return mAccess;
        -:  617:    }
        -:  618:
        -:  619:private:
        -:  620:    // only symbol database can change the type
        -:  621:    friend class SymbolDatabase;
        -:  622:
        -:  623:    /**
        -:  624:     * Set Type pointer to known type.
        -:  625:     * @param t type
        -:  626:     */
        -:  627:    void type(const Type * t) {
        -:  628:        mType = t;
        -:  629:    }
        -:  630:
        -:  631:    /** @brief variable name token */
        -:  632:    const Token *mNameToken;
        -:  633:
        -:  634:    /** @brief variable type start token */
        -:  635:    const Token *mTypeStartToken;
        -:  636:
        -:  637:    /** @brief variable type end token */
        -:  638:    const Token *mTypeEndToken;
        -:  639:
        -:  640:    /** @brief order declared */
        -:  641:    nonneg int mIndex;
        -:  642:
        -:  643:    /** @brief what section is this variable declared in? */
        -:  644:    AccessControl mAccess;  // public/protected/private
        -:  645:
        -:  646:    /** @brief flags */
        -:  647:    unsigned int mFlags;
        -:  648:
        -:  649:    /** @brief pointer to user defined type info (for known types) */
        -:  650:    const Type *mType;
        -:  651:
        -:  652:    /** @brief pointer to scope this variable is in */
        -:  653:    const Scope *mScope;
        -:  654:
        -:  655:    ValueType *mValueType;
        -:  656:
        -:  657:    /** @brief array dimensions */
        -:  658:    std::vector<Dimension> mDimensions;
        -:  659:
        -:  660:    /** @brief fill in information, depending on Tokens given at instantiation */
        -:  661:    void evaluate(const Settings* settings);
        -:  662:};
        -:  663:
        -:  664:class CPPCHECKLIB Function {
        -:  665:    /** @brief flags mask used to access specific bit. */
        -:  666:    enum {
        -:  667:        fHasBody               = (1 << 0),  ///< @brief has implementation
        -:  668:        fIsInline              = (1 << 1),  ///< @brief implementation in class definition
        -:  669:        fIsConst               = (1 << 2),  ///< @brief is const
        -:  670:        fHasVirtualSpecifier   = (1 << 3),  ///< @brief does declaration contain 'virtual' specifier
        -:  671:        fIsPure                = (1 << 4),  ///< @brief is pure virtual
        -:  672:        fIsStatic              = (1 << 5),  ///< @brief is static
        -:  673:        fIsStaticLocal         = (1 << 6),  ///< @brief is static local
        -:  674:        fIsExtern              = (1 << 7),  ///< @brief is extern
        -:  675:        fIsFriend              = (1 << 8),  ///< @brief is friend
        -:  676:        fIsExplicit            = (1 << 9),  ///< @brief is explicit
        -:  677:        fIsDefault             = (1 << 10), ///< @brief is default
        -:  678:        fIsDelete              = (1 << 11), ///< @brief is delete
        -:  679:        fHasOverrideSpecifier  = (1 << 12), ///< @brief does declaration contain 'override' specifier?
        -:  680:        fHasFinalSpecifier     = (1 << 13), ///< @brief does declaration contain 'final' specifier?
        -:  681:        fIsNoExcept            = (1 << 14), ///< @brief is noexcept
        -:  682:        fIsThrow               = (1 << 15), ///< @brief is throw
        -:  683:        fIsOperator            = (1 << 16), ///< @brief is operator
        -:  684:        fHasLvalRefQual        = (1 << 17), ///< @brief has & lvalue ref-qualifier
        -:  685:        fHasRvalRefQual        = (1 << 18), ///< @brief has && rvalue ref-qualifier
        -:  686:        fIsVariadic            = (1 << 19), ///< @brief is variadic
        -:  687:        fIsVolatile            = (1 << 20), ///< @brief is volatile
        -:  688:        fHasTrailingReturnType = (1 << 21), ///< @brief has trailing return type
        -:  689:        fIsEscapeFunction      = (1 << 22), ///< @brief Function throws or exits
        -:  690:    };
        -:  691:
        -:  692:    /**
        -:  693:     * Get specified flag state.
        -:  694:     * @param flag flag to get state of
        -:  695:     * @return true if flag set or false in flag not set
        -:  696:     */
function _ZNK8Function7getFlagEj called 0 returned 0% blocks executed 0%
    #####:  697:    bool getFlag(unsigned int flag) const {
    #####:  698:        return ((mFlags & flag) != 0);
        -:  699:    }
        -:  700:
        -:  701:    /**
        -:  702:     * Set specified flag state.
        -:  703:     * @param flag flag to set state
        -:  704:     * @param state new state of flag
        -:  705:     */
        -:  706:    void setFlag(unsigned int flag, bool state) {
        -:  707:        mFlags = state ? mFlags | flag : mFlags & ~flag;
        -:  708:    }
        -:  709:
        -:  710:public:
        -:  711:    enum Type { eConstructor, eCopyConstructor, eMoveConstructor, eOperatorEqual, eDestructor, eFunction, eLambda };
        -:  712:
        -:  713:    Function(const Tokenizer *mTokenizer, const Token *tok, const Scope *scope, const Token *tokDef, const Token *tokArgDef);
        -:  714:
function _ZNK8Function4nameB5cxx11Ev called 0 returned 0% blocks executed 0%
    #####:  715:    const std::string &name() const {
    #####:  716:        return tokenDef->str();
call    0 never executed
        -:  717:    }
        -:  718:
function _ZNK8Function8argCountEv called 0 returned 0% blocks executed 0%
    #####:  719:    nonneg int argCount() const {
    #####:  720:        return argumentList.size();
call    0 never executed
        -:  721:    }
function _ZNK8Function11minArgCountEv called 0 returned 0% blocks executed 0%
    #####:  722:    nonneg int minArgCount() const {
    #####:  723:        return argumentList.size() - initArgCount;
call    0 never executed
        -:  724:    }
        -:  725:    const Variable* getArgumentVar(nonneg int num) const;
        -:  726:    nonneg int initializedArgCount() const {
        -:  727:        return initArgCount;
        -:  728:    }
        -:  729:    void addArguments(const SymbolDatabase *symbolDatabase, const Scope *scope);
        -:  730:
        -:  731:    /** @brief check if this function is virtual in the base classes */
        -:  732:    bool isImplicitlyVirtual(bool defaultVal = false) const;
        -:  733:
        -:  734:    /** @brief get function in base class that is overridden */
        -:  735:    const Function *getOverriddenFunction(bool *foundAllBaseClasses = nullptr) const;
        -:  736:
        -:  737:    bool isLambda() const {
        -:  738:        return type==eLambda;
        -:  739:    }
        -:  740:
        -:  741:    bool isConstructor() const {
        -:  742:        return type==eConstructor ||
        -:  743:               type==eCopyConstructor ||
        -:  744:               type==eMoveConstructor;
        -:  745:    }
        -:  746:
        -:  747:    bool isDestructor() const {
        -:  748:        return type==eDestructor;
        -:  749:    }
        -:  750:    bool isAttributeConstructor() const {
        -:  751:        return tokenDef->isAttributeConstructor();
        -:  752:    }
        -:  753:    bool isAttributeDestructor() const {
        -:  754:        return tokenDef->isAttributeDestructor();
        -:  755:    }
        -:  756:    bool isAttributePure() const {
        -:  757:        return tokenDef->isAttributePure();
        -:  758:    }
        -:  759:    bool isAttributeConst() const {
        -:  760:        return tokenDef->isAttributeConst();
        -:  761:    }
        -:  762:    bool isAttributeNoreturn() const {
        -:  763:        return tokenDef->isAttributeNoreturn();
        -:  764:    }
        -:  765:    bool isAttributeNothrow() const {
        -:  766:        return tokenDef->isAttributeNothrow();
        -:  767:    }
        -:  768:    bool isAttributeNodiscard() const {
        -:  769:        return tokenDef->isAttributeNodiscard();
        -:  770:    }
        -:  771:
        -:  772:    bool hasBody() const {
        -:  773:        return getFlag(fHasBody);
        -:  774:    }
        -:  775:    bool isInline() const {
        -:  776:        return getFlag(fIsInline);
        -:  777:    }
        -:  778:    bool isConst() const {
        -:  779:        return getFlag(fIsConst);
        -:  780:    }
function _ZNK8Function19hasVirtualSpecifierEv called 0 returned 0% blocks executed 0%
    #####:  781:    bool hasVirtualSpecifier() const {
    #####:  782:        return getFlag(fHasVirtualSpecifier);
call    0 never executed
        -:  783:    }
        -:  784:    bool isPure() const {
        -:  785:        return getFlag(fIsPure);
        -:  786:    }
        -:  787:    bool isStatic() const {
        -:  788:        return getFlag(fIsStatic);
        -:  789:    }
        -:  790:    bool isStaticLocal() const {
        -:  791:        return getFlag(fIsStaticLocal);
        -:  792:    }
        -:  793:    bool isExtern() const {
        -:  794:        return getFlag(fIsExtern);
        -:  795:    }
        -:  796:    bool isFriend() const {
        -:  797:        return getFlag(fIsFriend);
        -:  798:    }
        -:  799:    bool isExplicit() const {
        -:  800:        return getFlag(fIsExplicit);
        -:  801:    }
        -:  802:    bool isDefault() const {
        -:  803:        return getFlag(fIsDefault);
        -:  804:    }
        -:  805:    bool isDelete() const {
        -:  806:        return getFlag(fIsDelete);
        -:  807:    }
        -:  808:    bool isNoExcept() const {
        -:  809:        return getFlag(fIsNoExcept);
        -:  810:    }
        -:  811:    bool isThrow() const {
        -:  812:        return getFlag(fIsThrow);
        -:  813:    }
        -:  814:    bool hasOverrideSpecifier() const {
        -:  815:        return getFlag(fHasOverrideSpecifier);
        -:  816:    }
        -:  817:    bool hasFinalSpecifier() const {
        -:  818:        return getFlag(fHasFinalSpecifier);
        -:  819:    }
        -:  820:    bool isOperator() const {
        -:  821:        return getFlag(fIsOperator);
        -:  822:    }
        -:  823:    bool hasLvalRefQualifier() const {
        -:  824:        return getFlag(fHasLvalRefQual);
        -:  825:    }
        -:  826:    bool hasRvalRefQualifier() const {
        -:  827:        return getFlag(fHasRvalRefQual);
        -:  828:    }
        -:  829:    bool isVariadic() const {
        -:  830:        return getFlag(fIsVariadic);
        -:  831:    }
        -:  832:    bool isVolatile() const {
        -:  833:        return getFlag(fIsVolatile);
        -:  834:    }
        -:  835:    bool hasTrailingReturnType() const {
        -:  836:        return getFlag(fHasTrailingReturnType);
        -:  837:    }
        -:  838:    void hasBody(bool state) {
        -:  839:        setFlag(fHasBody, state);
        -:  840:    }
        -:  841:
        -:  842:    bool isEscapeFunction() const {
        -:  843:        return getFlag(fIsEscapeFunction);
        -:  844:    }
        -:  845:    void isEscapeFunction(bool state) {
        -:  846:        setFlag(fIsEscapeFunction, state);
        -:  847:    }
        -:  848:    bool isSafe(const Settings *settings) const;
        -:  849:
        -:  850:    const Token *tokenDef;            ///< function name token in class definition
        -:  851:    const Token *argDef;              ///< function argument start '(' in class definition
        -:  852:    const Token *token;               ///< function name token in implementation
        -:  853:    const Token *arg;                 ///< function argument start '('
        -:  854:    const Token *retDef;              ///< function return type token
        -:  855:    const ::Type *retType;            ///< function return type
        -:  856:    const Scope *functionScope;       ///< scope of function body
        -:  857:    const Scope* nestedIn;            ///< Scope the function is declared in
        -:  858:    std::list<Variable> argumentList; ///< argument list
        -:  859:    nonneg int initArgCount;        ///< number of args with default values
        -:  860:    Type type;                        ///< constructor, destructor, ...
        -:  861:    AccessControl access;             ///< public/protected/private
        -:  862:    const Token *noexceptArg;         ///< noexcept token
        -:  863:    const Token *throwArg;            ///< throw token
        -:  864:    const Token *templateDef;         ///< points to 'template <' before function
        -:  865:
        -:  866:    static bool argsMatch(const Scope *scope, const Token *first, const Token *second, const std::string &path, nonneg int path_length);
        -:  867:
        -:  868:    static bool returnsReference(const Function *function);
        -:  869:
        -:  870:    const Token* returnDefEnd() const {
        -:  871:        if (this->hasTrailingReturnType()) {
        -:  872:            return Token::findsimplematch(retDef, "{");
        -:  873:        } else {
        -:  874:            return tokenDef;
        -:  875:        }
        -:  876:    }
        -:  877:
        -:  878:    /**
        -:  879:     * @return token to ":" if the function is a constructor
        -:  880:     * and it contains member initialization otherwise a nullptr is returned
        -:  881:     */
        -:  882:    const Token * constructorMemberInitialization() const;
        -:  883:
        -:  884:private:
        -:  885:    /** Recursively determine if this function overrides a virtual function in a base class */
        -:  886:    const Function * getOverriddenFunctionRecursive(const ::Type* baseType, bool *foundAllBaseClasses) const;
        -:  887:
        -:  888:    unsigned int mFlags;
        -:  889:
        -:  890:    void isInline(bool state) {
        -:  891:        setFlag(fIsInline, state);
        -:  892:    }
        -:  893:    void isConst(bool state) {
        -:  894:        setFlag(fIsConst, state);
        -:  895:    }
        -:  896:    void hasVirtualSpecifier(bool state) {
        -:  897:        setFlag(fHasVirtualSpecifier, state);
        -:  898:    }
        -:  899:    void isPure(bool state) {
        -:  900:        setFlag(fIsPure, state);
        -:  901:    }
        -:  902:    void isStatic(bool state) {
        -:  903:        setFlag(fIsStatic, state);
        -:  904:    }
        -:  905:    void isStaticLocal(bool state) {
        -:  906:        setFlag(fIsStaticLocal, state);
        -:  907:    }
        -:  908:    void isExtern(bool state) {
        -:  909:        setFlag(fIsExtern, state);
        -:  910:    }
        -:  911:    void isFriend(bool state) {
        -:  912:        setFlag(fIsFriend, state);
        -:  913:    }
        -:  914:    void isExplicit(bool state) {
        -:  915:        setFlag(fIsExplicit, state);
        -:  916:    }
        -:  917:    void isDefault(bool state) {
        -:  918:        setFlag(fIsDefault, state);
        -:  919:    }
        -:  920:    void isDelete(bool state) {
        -:  921:        setFlag(fIsDelete, state);
        -:  922:    }
        -:  923:    void isNoExcept(bool state) {
        -:  924:        setFlag(fIsNoExcept, state);
        -:  925:    }
        -:  926:    void isThrow(bool state) {
        -:  927:        setFlag(fIsThrow, state);
        -:  928:    }
        -:  929:    void isOperator(bool state) {
        -:  930:        setFlag(fIsOperator, state);
        -:  931:    }
        -:  932:    void hasLvalRefQualifier(bool state) {
        -:  933:        setFlag(fHasLvalRefQual, state);
        -:  934:    }
        -:  935:    void hasRvalRefQualifier(bool state) {
        -:  936:        setFlag(fHasRvalRefQual, state);
        -:  937:    }
        -:  938:    void isVariadic(bool state) {
        -:  939:        setFlag(fIsVariadic, state);
        -:  940:    }
        -:  941:    void isVolatile(bool state) {
        -:  942:        setFlag(fIsVolatile, state);
        -:  943:    }
        -:  944:    void hasTrailingReturnType(bool state) {
        -:  945:        return setFlag(fHasTrailingReturnType, state);
        -:  946:    }
        -:  947:};
        -:  948:
        -:  949:class CPPCHECKLIB Scope {
        -:  950:    // let tests access private function for testing
        -:  951:    friend class TestSymbolDatabase;
        -:  952:
        -:  953:public:
        -:  954:    struct UsingInfo {
        -:  955:        const Token *start;
        -:  956:        const Scope *scope;
        -:  957:    };
        -:  958:
        -:  959:    enum ScopeType { eGlobal, eClass, eStruct, eUnion, eNamespace, eFunction, eIf, eElse, eFor, eWhile, eDo, eSwitch, eUnconditional, eTry, eCatch, eLambda, eEnum };
        -:  960:
        -:  961:    Scope(const SymbolDatabase *check_, const Token *classDef_, const Scope *nestedIn_);
        -:  962:    Scope(const SymbolDatabase *check_, const Token *classDef_, const Scope *nestedIn_, ScopeType type_, const Token *start_);
        -:  963:
        -:  964:    const SymbolDatabase *check;
        -:  965:    std::string className;
        -:  966:    const Token *classDef;   ///< class/struct/union/namespace token
        -:  967:    const Token *bodyStart;  ///< '{' token
        -:  968:    const Token *bodyEnd;    ///< '}' token
        -:  969:    std::list<Function> functionList;
        -:  970:    std::multimap<std::string, const Function *> functionMap;
        -:  971:    std::list<Variable> varlist;
        -:  972:    const Scope *nestedIn;
        -:  973:    std::list<Scope *> nestedList;
        -:  974:    nonneg int numConstructors;
        -:  975:    nonneg int numCopyOrMoveConstructors;
        -:  976:    std::list<UsingInfo> usingList;
        -:  977:    ScopeType type;
        -:  978:    Type* definedType;
        -:  979:    std::map<std::string, Type*> definedTypesMap;
        -:  980:
        -:  981:    // function specific fields
        -:  982:    const Scope *functionOf; ///< scope this function belongs to
        -:  983:    Function *function; ///< function info for this function
        -:  984:
        -:  985:    // enum specific fields
        -:  986:    const Token * enumType;
        -:  987:    bool enumClass;
        -:  988:
        -:  989:    std::vector<Enumerator> enumeratorList;
        -:  990:
        -:  991:    const Enumerator * findEnumerator(const std::string & name) const {
        -:  992:        for (const Enumerator & i : enumeratorList) {
        -:  993:            if (i.name->str() == name)
        -:  994:                return &i;
        -:  995:        }
        -:  996:        return nullptr;
        -:  997:    }
        -:  998:
function _ZNK5Scope10isNestedInEPKS_ called 0 returned 0% blocks executed 0%
    #####:  999:    bool isNestedIn(const Scope * outer) const {
    #####: 1000:        if (!outer)
branch  0 never executed
branch  1 never executed
    #####: 1001:            return false;
    #####: 1002:        if (outer == this)
branch  0 never executed
branch  1 never executed
    #####: 1003:            return true;
    #####: 1004:        const Scope * parent = nestedIn;
    #####: 1005:        while (outer != parent && parent)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1006:            parent = parent->nestedIn;
    #####: 1007:        if (parent && parent == outer)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1008:            return true;
    #####: 1009:        return false;
        -: 1010:    }
        -: 1011:
        -: 1012:    bool isClassOrStruct() const {
        -: 1013:        return (type == eClass || type == eStruct);
        -: 1014:    }
        -: 1015:
        -: 1016:    bool isClassOrStructOrUnion() const {
        -: 1017:        return (type == eClass || type == eStruct || type == eUnion);
        -: 1018:    }
        -: 1019:
function _ZNK5Scope12isExecutableEv called 0 returned 0% blocks executed 0%
    #####: 1020:    bool isExecutable() const {
    #####: 1021:        return type != eClass && type != eStruct && type != eUnion && type != eGlobal && type != eNamespace && type != eEnum;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
        -: 1022:    }
        -: 1023:
function _ZNK5Scope7isLocalEv called 0 returned 0% blocks executed 0%
    #####: 1024:    bool isLocal() const {
    #####: 1025:        return (type == eIf || type == eElse ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1026:                type == eFor || type == eWhile || type == eDo ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1027:                type == eSwitch || type == eUnconditional ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1028:                type == eTry || type == eCatch);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1029:    }
        -: 1030:
        -: 1031:    // Is there lambda/inline function(s) in this scope?
        -: 1032:    bool hasInlineOrLambdaFunction() const;
        -: 1033:
        -: 1034:    /**
        -: 1035:     * @brief find a function
        -: 1036:     * @param tok token of function call
        -: 1037:     * @param requireConst if const refers to a const variable only const methods should be matched
        -: 1038:     * @return pointer to function if found or NULL if not found
        -: 1039:     */
        -: 1040:    const Function *findFunction(const Token *tok, bool requireConst=false) const;
        -: 1041:
        -: 1042:    /**
        -: 1043:     * @brief find if name is in nested list
        -: 1044:     * @param name name of nested scope
        -: 1045:     */
        -: 1046:    Scope *findInNestedList(const std::string & name);
        -: 1047:
        -: 1048:    const Scope *findRecordInNestedList(const std::string & name) const;
        -: 1049:    Scope *findRecordInNestedList(const std::string & name) {
        -: 1050:        return const_cast<Scope *>(const_cast<const Scope *>(this)->findRecordInNestedList(name));
        -: 1051:    }
        -: 1052:
        -: 1053:    const Type* findType(const std::string& name) const;
        -: 1054:    Type* findType(const std::string& name) {
        -: 1055:        return const_cast<Type*>(const_cast<const Scope *>(this)->findType(name));
        -: 1056:    }
        -: 1057:
        -: 1058:    /**
        -: 1059:     * @brief find if name is in nested list
        -: 1060:     * @param name name of nested scope
        -: 1061:     */
        -: 1062:    Scope *findInNestedListRecursive(const std::string & name);
        -: 1063:
        -: 1064:    void addVariable(const Token *token_, const Token *start_,
        -: 1065:                     const Token *end_, AccessControl access_, const Type *type_,
        -: 1066:                     const Scope *scope_, const Settings* settings) {
        -: 1067:        varlist.emplace_back(token_, start_, end_, varlist.size(),
        -: 1068:                             access_,
        -: 1069:                             type_, scope_, settings);
        -: 1070:    }
        -: 1071:
        -: 1072:    /** @brief initialize varlist */
        -: 1073:    void getVariableList(const Settings* settings);
        -: 1074:
        -: 1075:    const Function *getDestructor() const;
        -: 1076:
        -: 1077:    void addFunction(const Function & func) {
        -: 1078:        functionList.push_back(func);
        -: 1079:
        -: 1080:        const Function * back = &functionList.back();
        -: 1081:
        -: 1082:        functionMap.insert(make_pair(back->tokenDef->str(), back));
        -: 1083:    }
        -: 1084:
        -: 1085:    bool hasDefaultConstructor() const;
        -: 1086:
        -: 1087:    AccessControl defaultAccess() const;
        -: 1088:
        -: 1089:    /**
        -: 1090:     * @brief check if statement is variable declaration and add it if it is
        -: 1091:     * @param tok pointer to start of statement
        -: 1092:     * @param varaccess access control of statement
        -: 1093:     * @param settings Settings
        -: 1094:     * @return pointer to last token
        -: 1095:     */
        -: 1096:    const Token *checkVariable(const Token *tok, AccessControl varaccess, const Settings* settings);
        -: 1097:
        -: 1098:    /**
        -: 1099:     * @brief get variable from name
        -: 1100:     * @param varname name of variable
        -: 1101:     * @return pointer to variable
        -: 1102:     */
        -: 1103:    const Variable *getVariable(const std::string &varname) const;
        -: 1104:
        -: 1105:    const Token * addEnum(const Token * tok, bool isCpp);
        -: 1106:
        -: 1107:private:
        -: 1108:    /**
        -: 1109:     * @brief helper function for getVariableList()
        -: 1110:     * @param tok pointer to token to check
        -: 1111:     * @param vartok populated with pointer to the variable token, if found
        -: 1112:     * @param typetok populated with pointer to the type token, if found
        -: 1113:     * @return true if tok points to a variable declaration, false otherwise
        -: 1114:     */
        -: 1115:    bool isVariableDeclaration(const Token* const tok, const Token*& vartok, const Token*& typetok) const;
        -: 1116:
        -: 1117:    void findFunctionInBase(const std::string & name, nonneg int args, std::vector<const Function *> & matches) const;
        -: 1118:};
        -: 1119:
        -: 1120:
        -: 1121:/** Value type */
function _ZN9ValueTypeD2Ev called 0 returned 0% blocks executed 0%
    #####: 1122:class CPPCHECKLIB ValueType {
call    0 never executed
        -: 1123:public:
        -: 1124:    enum Sign { UNKNOWN_SIGN, SIGNED, UNSIGNED } sign;
        -: 1125:    enum Type { UNKNOWN_TYPE, NONSTD, RECORD, CONTAINER, ITERATOR, VOID, BOOL, CHAR, SHORT, WCHAR_T, INT, LONG, LONGLONG, UNKNOWN_INT, FLOAT, DOUBLE, LONGDOUBLE } type;
        -: 1126:    nonneg int bits;                    ///< bitfield bitcount
        -: 1127:    nonneg int pointer;                 ///< 0=>not pointer, 1=>*, 2=>**, 3=>***, etc
        -: 1128:    nonneg int constness;               ///< bit 0=data, bit 1=*, bit 2=**
        -: 1129:    const Scope *typeScope;               ///< if the type definition is seen this point out the type scope
        -: 1130:    const ::Type *smartPointerType;       ///< Smart pointer type
        -: 1131:    const Library::Container *container;  ///< If the type is a container defined in a cfg file, this is the used container
        -: 1132:    const Token *containerTypeToken;      ///< The container type token. the template argument token that defines the container element type.
        -: 1133:    std::string originalTypeName;         ///< original type name as written in the source code. eg. this might be "uint8_t" when type is CHAR.
        -: 1134:
        -: 1135:    ValueType() : sign(UNKNOWN_SIGN), type(UNKNOWN_TYPE), bits(0), pointer(0U), constness(0U), typeScope(nullptr), smartPointerType(nullptr), container(nullptr), containerTypeToken(nullptr) {}
        -: 1136:    ValueType(const ValueType &vt) : sign(vt.sign), type(vt.type), bits(vt.bits), pointer(vt.pointer), constness(vt.constness), typeScope(vt.typeScope), smartPointerType(vt.smartPointerType), container(vt.container), containerTypeToken(vt.containerTypeToken), originalTypeName(vt.originalTypeName) {}
        -: 1137:    ValueType(enum Sign s, enum Type t, nonneg int p) : sign(s), type(t), bits(0), pointer(p), constness(0U), typeScope(nullptr), smartPointerType(nullptr), container(nullptr), containerTypeToken(nullptr) {}
        -: 1138:    ValueType(enum Sign s, enum Type t, nonneg int p, nonneg int c) : sign(s), type(t), bits(0), pointer(p), constness(c), typeScope(nullptr), smartPointerType(nullptr), container(nullptr), containerTypeToken(nullptr) {}
        -: 1139:    ValueType(enum Sign s, enum Type t, nonneg int p, nonneg int c, const std::string &otn) : sign(s), type(t), bits(0), pointer(p), constness(c), typeScope(nullptr), smartPointerType(nullptr), container(nullptr), containerTypeToken(nullptr), originalTypeName(otn) {}
        -: 1140:    ValueType &operator=(const ValueType &other) = delete;
        -: 1141:
        -: 1142:    static ValueType parseDecl(const Token *type, const Settings *settings);
        -: 1143:
        -: 1144:    static Type typeFromString(const std::string &typestr, bool longType);
        -: 1145:
        -: 1146:    enum class MatchResult { UNKNOWN, SAME, FALLBACK1, FALLBACK2, NOMATCH };
        -: 1147:    static MatchResult matchParameter(const ValueType *call, const ValueType *func);
        -: 1148:    static MatchResult matchParameter(const ValueType *call, const Variable *callVar, const Variable *funcVar);
        -: 1149:
function _ZNK9ValueType10isIntegralEv called 0 returned 0% blocks executed 0%
    #####: 1150:    bool isIntegral() const {
    #####: 1151:        return (type >= ValueType::Type::BOOL && type <= ValueType::Type::UNKNOWN_INT);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1152:    }
        -: 1153:
        -: 1154:    bool isFloat() const {
        -: 1155:        return (type >= ValueType::Type::FLOAT && type <= ValueType::Type::LONGDOUBLE);
        -: 1156:    }
        -: 1157:
        -: 1158:    bool fromLibraryType(const std::string &typestr, const Settings *settings);
        -: 1159:
        -: 1160:    bool isEnum() const {
        -: 1161:        return typeScope && typeScope->type == Scope::eEnum;
        -: 1162:    }
        -: 1163:
        -: 1164:    MathLib::bigint typeSize(const cppcheck::Platform &platform) const;
        -: 1165:
        -: 1166:    std::string str() const;
        -: 1167:    std::string dump() const;
        -: 1168:};
        -: 1169:
        -: 1170:
        -: 1171:class CPPCHECKLIB SymbolDatabase {
        -: 1172:    friend class TestSymbolDatabase;
        -: 1173:public:
        -: 1174:    SymbolDatabase(const Tokenizer *tokenizer, const Settings *settings, ErrorLogger *errorLogger);
        -: 1175:    ~SymbolDatabase();
        -: 1176:
        -: 1177:    /** @brief Information about all namespaces/classes/structrues */
        -: 1178:    std::list<Scope> scopeList;
        -: 1179:
        -: 1180:    /** @brief Fast access to function scopes */
        -: 1181:    std::vector<const Scope *> functionScopes;
        -: 1182:
        -: 1183:    /** @brief Fast access to class and struct scopes */
        -: 1184:    std::vector<const Scope *> classAndStructScopes;
        -: 1185:
        -: 1186:    /** @brief Fast access to types */
        -: 1187:    std::list<Type> typeList;
        -: 1188:
        -: 1189:    /**
        -: 1190:     * @brief find a variable type if it's a user defined type
        -: 1191:     * @param start scope to start looking in
        -: 1192:     * @param typeTok token containing variable type
        -: 1193:     * @return pointer to type if found or NULL if not found
        -: 1194:     */
        -: 1195:    const Type *findVariableType(const Scope *start, const Token *typeTok) const;
        -: 1196:
        -: 1197:    /**
        -: 1198:     * @brief find a function
        -: 1199:     * @param tok token of function call
        -: 1200:     * @return pointer to function if found or NULL if not found
        -: 1201:     */
        -: 1202:    const Function *findFunction(const Token *tok) const;
        -: 1203:
        -: 1204:    const Scope *findScopeByName(const std::string& name) const;
        -: 1205:
        -: 1206:    const Type* findType(const Token *startTok, const Scope *startScope) const;
        -: 1207:    Type* findType(const Token *startTok, Scope *startScope) const {
        -: 1208:        return const_cast<Type*>(this->findType(startTok, const_cast<const Scope *>(startScope)));
        -: 1209:    }
        -: 1210:
        -: 1211:    const Scope *findScope(const Token *tok, const Scope *startScope) const;
        -: 1212:    Scope *findScope(const Token *tok, Scope *startScope) const {
        -: 1213:        return const_cast<Scope *>(this->findScope(tok, const_cast<const Scope *>(startScope)));
        -: 1214:    }
        -: 1215:
        -: 1216:    const Variable *getVariableFromVarId(nonneg int varId) const {
        -: 1217:        return mVariableList.at(varId);
        -: 1218:    }
        -: 1219:
function _ZNK14SymbolDatabase12variableListEv called 0 returned 0% blocks executed 0%
    #####: 1220:    const std::vector<const Variable *> & variableList() const {
    #####: 1221:        return mVariableList;
        -: 1222:    }
        -: 1223:
        -: 1224:    /**
        -: 1225:     * @brief output a debug message
        -: 1226:     */
        -: 1227:    void debugMessage(const Token *tok, const std::string &msg) const;
        -: 1228:
        -: 1229:    void printOut(const char * title = nullptr) const;
        -: 1230:    void printVariable(const Variable *var, const char *indent) const;
        -: 1231:    void printXml(std::ostream &out) const;
        -: 1232:
        -: 1233:    bool isCPP() const;
        -: 1234:
        -: 1235:    /*
        -: 1236:     * @brief Do a sanity check
        -: 1237:     */
        -: 1238:    void validate() const;
        -: 1239:
        -: 1240:    void validateExecutableScopes() const;
        -: 1241:    /**
        -: 1242:     * @brief Check variable list, e.g. variables w/o scope
        -: 1243:     */
        -: 1244:    void validateVariables() const;
        -: 1245:
        -: 1246:    /** Set valuetype in provided tokenlist */
        -: 1247:    void setValueTypeInTokenList(bool reportDebugWarnings);
        -: 1248:
        -: 1249:    /**
        -: 1250:     * Calculates sizeof value for given type.
        -: 1251:     * @param type Token which will contain e.g. "int", "*", or string.
        -: 1252:     * @return sizeof for given type, or 0 if it can't be calculated.
        -: 1253:     */
        -: 1254:    nonneg int sizeOfType(const Token *type) const;
        -: 1255:
        -: 1256:    /** Set array dimensions when valueflow analysis is completed */
        -: 1257:    void setArrayDimensionsUsingValueFlow();
        -: 1258:
        -: 1259:private:
        -: 1260:    friend class Scope;
        -: 1261:    friend class Function;
        -: 1262:
        -: 1263:    // Create symboldatabase...
        -: 1264:    void createSymbolDatabaseFindAllScopes();
        -: 1265:    void createSymbolDatabaseClassInfo();
        -: 1266:    void createSymbolDatabaseVariableInfo();
        -: 1267:    void createSymbolDatabaseCopyAndMoveConstructors();
        -: 1268:    void createSymbolDatabaseFunctionScopes();
        -: 1269:    void createSymbolDatabaseClassAndStructScopes();
        -: 1270:    void createSymbolDatabaseFunctionReturnTypes();
        -: 1271:    void createSymbolDatabaseNeedInitialization();
        -: 1272:    void createSymbolDatabaseVariableSymbolTable();
        -: 1273:    void createSymbolDatabaseSetScopePointers();
        -: 1274:    void createSymbolDatabaseSetFunctionPointers(bool firstPass);
        -: 1275:    void createSymbolDatabaseSetVariablePointers();
        -: 1276:    void createSymbolDatabaseSetTypePointers();
        -: 1277:    void createSymbolDatabaseEnums();
        -: 1278:    void createSymbolDatabaseEscapeFunctions();
        -: 1279:    void createSymbolDatabaseIncompleteVars();
        -: 1280:
        -: 1281:    void addClassFunction(Scope **scope, const Token **tok, const Token *argStart);
        -: 1282:    Function *addGlobalFunctionDecl(Scope*& scope, const Token* tok, const Token *argStart, const Token* funcStart);
        -: 1283:    Function *addGlobalFunction(Scope*& scope, const Token*& tok, const Token *argStart, const Token* funcStart);
        -: 1284:    void addNewFunction(Scope **scope, const Token **tok);
        -: 1285:    bool isFunction(const Token *tok, const Scope* outerScope, const Token **funcStart, const Token **argStart, const Token** declEnd) const;
        -: 1286:    const Type *findTypeInNested(const Token *startTok, const Scope *startScope) const;
        -: 1287:    const Scope *findNamespace(const Token * tok, const Scope * scope) const;
        -: 1288:    Function *findFunctionInScope(const Token *func, const Scope *ns, const std::string & path, nonneg int path_length);
        -: 1289:    const Type *findVariableTypeInBase(const Scope *scope, const Token *typeTok) const;
        -: 1290:
        -: 1291:    typedef std::map<unsigned int, unsigned int> MemberIdMap;
        -: 1292:    typedef std::map<unsigned int, MemberIdMap> VarIdMap;
        -: 1293:
        -: 1294:    void fixVarId(VarIdMap & varIds, const Token * vartok, Token * membertok, const Variable * membervar);
        -: 1295:
        -: 1296:    /** Whether iName is a keyword as defined in http://en.cppreference.com/w/c/keyword and http://en.cppreference.com/w/cpp/keyword*/
        -: 1297:    bool isReservedName(const std::string& iName) const;
        -: 1298:
        -: 1299:    const Enumerator * findEnumerator(const Token * tok) const;
        -: 1300:
        -: 1301:    void setValueType(Token *tok, const ValueType &valuetype);
        -: 1302:    void setValueType(Token *tok, const Variable &var);
        -: 1303:    void setValueType(Token *tok, const Enumerator &enumerator);
        -: 1304:
        -: 1305:    const Tokenizer *mTokenizer;
        -: 1306:    const Settings *mSettings;
        -: 1307:    ErrorLogger *mErrorLogger;
        -: 1308:
        -: 1309:    /** variable symbol table */
        -: 1310:    std::vector<const Variable *> mVariableList;
        -: 1311:
        -: 1312:    /** list for missing types */
        -: 1313:    std::list<Type> mBlankTypes;
        -: 1314:
        -: 1315:    bool mIsCpp;
        -: 1316:    ValueType::Sign mDefaultSignedness;
        -: 1317:
        -: 1318:    /** "negative cache" list of tokens that we find are not enumeration values */
        -: 1319:    mutable std::set<std::string> mTokensThatAreNotEnumeratorValues;
        -: 1320:};
        -: 1321:
        -: 1322:
        -: 1323://---------------------------------------------------------------------------
        -: 1324:#endif // symboldatabaseH
