        -:    0:Source:/home/workspace/lib/astutils.h
        -:    0:Graph:/home/workspace/build/lib/CMakeFiles/lib_objs.dir/valueflow.gcno
        -:    0:Data:/home/workspace/build/lib/CMakeFiles/lib_objs.dir/valueflow.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*
        -:    2: * Cppcheck - A tool for static C/C++ code analysis
        -:    3: * Copyright (C) 2007-2019 Cppcheck team.
        -:    4: *
        -:    5: * This program is free software: you can redistribute it and/or modify
        -:    6: * it under the terms of the GNU General Public License as published by
        -:    7: * the Free Software Foundation, either version 3 of the License, or
        -:    8: * (at your option) any later version.
        -:    9: *
        -:   10: * This program is distributed in the hope that it will be useful,
        -:   11: * but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   12: * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   13: * GNU General Public License for more details.
        -:   14: *
        -:   15: * You should have received a copy of the GNU General Public License
        -:   16: * along with this program.  If not, see <http://www.gnu.org/licenses/>.
        -:   17: */
        -:   18:
        -:   19:
        -:   20://---------------------------------------------------------------------------
        -:   21:#ifndef astutilsH
        -:   22:#define astutilsH
        -:   23://---------------------------------------------------------------------------
        -:   24:
        -:   25:#include <functional>
        -:   26:#include <string>
        -:   27:#include <vector>
        -:   28:
        -:   29:#include "errorlogger.h"
        -:   30:#include "utils.h"
        -:   31:
        -:   32:class Library;
        -:   33:class Settings;
        -:   34:class Scope;
        -:   35:class Token;
        -:   36:class Variable;
        -:   37:
        -:   38:enum class ChildrenToVisit {
        -:   39:    none,
        -:   40:    op1,
        -:   41:    op2,
        -:   42:    op1_and_op2,
        -:   43:    done  // found what we looked for, don't visit any more children
        -:   44:};
        -:   45:
        -:   46:/**
        -:   47: * Visit AST nodes recursively. The order is not "well defined"
        -:   48: */
        -:   49:void visitAstNodes(const Token *ast, std::function<ChildrenToVisit(const Token *)> visitor);
        -:   50:
        -:   51:std::vector<const Token*> astFlatten(const Token* tok, const char* op);
        -:   52:
        -:   53:bool astHasToken(const Token* root, const Token * tok);
        -:   54:
        -:   55:bool astHasVar(const Token * tok, nonneg int varid);
        -:   56:
        -:   57:/** Is expression a 'signed char' if no promotion is used */
        -:   58:bool astIsSignedChar(const Token *tok);
        -:   59:/** Is expression a 'char' if no promotion is used? */
        -:   60:bool astIsUnknownSignChar(const Token *tok);
        -:   61:/** Is expression of integral type? */
        -:   62:bool astIsIntegral(const Token *tok, bool unknown);
        -:   63:/** Is expression of floating point type? */
        -:   64:bool astIsFloat(const Token *tok, bool unknown);
        -:   65:/** Is expression of boolean type? */
        -:   66:bool astIsBool(const Token *tok);
        -:   67:
        -:   68:bool astIsPointer(const Token *tok);
        -:   69:
        -:   70:bool astIsIterator(const Token *tok);
        -:   71:
        -:   72:bool astIsContainer(const Token *tok);
        -:   73:
        -:   74:/**
        -:   75: * Get canonical type of expression. const/static/etc are not included and neither *&.
        -:   76: * For example:
        -:   77: * Expression type      Return
        -:   78: * std::string          std::string
        -:   79: * int *                int
        -:   80: * static const int     int
        -:   81: * std::vector<T>       std::vector
        -:   82: */
        -:   83:std::string astCanonicalType(const Token *expr);
        -:   84:
        -:   85:/** Is given syntax tree a variable comparison against value */
        -:   86:const Token * astIsVariableComparison(const Token *tok, const std::string &comp, const std::string &rhs, const Token **vartok=nullptr);
        -:   87:
        -:   88:const Token * nextAfterAstRightmostLeaf(const Token * tok);
        -:   89:
        -:   90:Token* astParentSkipParens(Token* tok);
        -:   91:const Token* astParentSkipParens(const Token* tok);
        -:   92:
        -:   93:bool precedes(const Token * tok1, const Token * tok2);
        -:   94:
        -:   95:bool isSameExpression(bool cpp, bool macro, const Token *tok1, const Token *tok2, const Library& library, bool pure, bool followVar, ErrorPath* errors=nullptr);
        -:   96:
        -:   97:bool isEqualKnownValue(const Token * const tok1, const Token * const tok2);
        -:   98:
        -:   99:bool isDifferentKnownValues(const Token * const tok1, const Token * const tok2);
        -:  100:
        -:  101:/**
        -:  102: * Are two conditions opposite
        -:  103: * @param isNot  do you want to know if cond1 is !cond2 or if cond1 and cond2 are non-overlapping. true: cond1==!cond2  false: cond1==true => cond2==false
        -:  104: * @param cpp    c++ file
        -:  105: * @param cond1  condition1
        -:  106: * @param cond2  condition2
        -:  107: * @param library files data
        -:  108: * @param pure boolean
        -:  109: */
        -:  110:bool isOppositeCond(bool isNot, bool cpp, const Token * const cond1, const Token * const cond2, const Library& library, bool pure, bool followVar, ErrorPath* errors=nullptr);
        -:  111:
        -:  112:bool isOppositeExpression(bool cpp, const Token * const tok1, const Token * const tok2, const Library& library, bool pure, bool followVar, ErrorPath* errors=nullptr);
        -:  113:
        -:  114:bool isConstExpression(const Token *tok, const Library& library, bool pure, bool cpp);
        -:  115:
        -:  116:bool isWithoutSideEffects(bool cpp, const Token* tok);
        -:  117:
        -:  118:bool isUniqueExpression(const Token* tok);
        -:  119:
        -:  120:/** Is scope a return scope (scope will unconditionally return) */
        -:  121:bool isReturnScope(const Token *endToken, const Settings * settings = nullptr, bool functionScope=false);
        -:  122:
        -:  123:/// Return the token to the function and the argument number
        -:  124:const Token * getTokenArgumentFunction(const Token * tok, int& argn);
        -:  125:
        -:  126:/** Is variable changed by function call?
        -:  127: * In case the answer of the question is inconclusive, e.g. because the function declaration is not known
        -:  128: * the return value is false and the output parameter inconclusive is set to true
        -:  129: *
        -:  130: * @param tok           ast tree
        -:  131: * @param varid         Variable Id
        -:  132: * @param settings      program settings
        -:  133: * @param inconclusive  pointer to output variable which indicates that the answer of the question is inconclusive
        -:  134: */
        -:  135:bool isVariableChangedByFunctionCall(const Token *tok, int indirect, nonneg int varid, const Settings *settings, bool *inconclusive);
        -:  136:
        -:  137:/** Is variable changed by function call?
        -:  138: * In case the answer of the question is inconclusive, e.g. because the function declaration is not known
        -:  139: * the return value is false and the output parameter inconclusive is set to true
        -:  140: *
        -:  141: * @param tok           token of variable in function call
        -:  142: * @param settings      program settings
        -:  143: * @param inconclusive pointer to output variable which indicates that the answer of the question is inconclusive
        -:  144: */
        -:  145:bool isVariableChangedByFunctionCall(const Token *tok, int indirect, const Settings *settings, bool *inconclusive);
        -:  146:
        -:  147:/** Is variable changed in block of code? */
        -:  148:bool isVariableChanged(const Token *start, const Token *end, const nonneg int varid, bool globalvar, const Settings *settings, bool cpp, int depth = 20);
        -:  149:
        -:  150:bool isVariableChanged(const Token *tok, int indirect, const Settings *settings, bool cpp, int depth = 20);
        -:  151:
        -:  152:bool isVariableChanged(const Variable * var, const Settings *settings, bool cpp, int depth = 20);
        -:  153:
        -:  154:const Token* findVariableChanged(const Token *start, const Token *end, int indirect, const nonneg int varid, bool globalvar, const Settings *settings, bool cpp, int depth = 20);
        -:  155:Token* findVariableChanged(Token *start, const Token *end, int indirect, const nonneg int varid, bool globalvar, const Settings *settings, bool cpp, int depth = 20);
        -:  156:
        -:  157:/// If token is an alias if another variable
        -:  158:bool isAliasOf(const Token *tok, nonneg int varid);
        -:  159:
        -:  160:bool isAliased(const Variable *var);
        -:  161:
        -:  162:/** Determines the number of arguments - if token is a function call or macro
        -:  163: * @param start token which is supposed to be the function/macro name.
        -:  164: * \return Number of arguments
        -:  165: */
        -:  166:int numberOfArguments(const Token *start);
        -:  167:
        -:  168:/**
        -:  169: * Get arguments (AST)
        -:  170: */
        -:  171:std::vector<const Token *> getArguments(const Token *ftok);
        -:  172:
        -:  173:const Token *findLambdaStartToken(const Token *last);
        -:  174:
        -:  175:/**
        -:  176: * find lambda function end token
        -:  177: * \param first The [ token
        -:  178: * \return nullptr or the }
        -:  179: */
        -:  180:const Token *findLambdaEndToken(const Token *first);
        -:  181:
        -:  182:bool isLikelyStream(bool cpp, const Token *stream);
        -:  183:
        -:  184:/**
        -:  185: * do we see a likely write of rhs through overloaded operator
        -:  186: *   s >> x;
        -:  187: *   a & x;
        -:  188: */
        -:  189:bool isLikelyStreamRead(bool cpp, const Token *op);
        -:  190:
        -:  191:bool isCPPCast(const Token* tok);
        -:  192:
        -:  193:bool isConstVarExpression(const Token *tok);
        -:  194:
        -:  195:const Variable *getLHSVariable(const Token *tok);
        -:  196:
        -:  197:bool isScopeBracket(const Token* tok);
        -:  198:
        -:  199:struct PathAnalysis {
        -:  200:    enum class Progress {
        -:  201:        Continue,
        -:  202:        Break
        -:  203:    };
        -:  204:    PathAnalysis(const Token* start, const Library& library)
        -:  205:        : start(start), library(&library)
        -:  206:    {}
        -:  207:    const Token * start;
        -:  208:    const Library * library;
        -:  209:
        -:  210:    struct Info {
        -:  211:        const Token* tok;
        -:  212:        ErrorPath errorPath;
        -:  213:        bool known;
        -:  214:    };
        -:  215:
        -:  216:    void forward(const std::function<Progress(const Info&)>& f) const;
        -:  217:    template<class F>
        -:  218:    void forwardAll(F f) {
        -:  219:        forward([&](const Info& info) {
        -:  220:            f(info);
        -:  221:            return Progress::Continue;
        -:  222:        });
        -:  223:    }
        -:  224:    template<class Predicate>
        -:  225:    Info forwardFind(Predicate pred) {
        -:  226:        Info result{};
        -:  227:        forward([&](const Info& info) {
        -:  228:            if (pred(info)) {
        -:  229:                result = info;
        -:  230:                return Progress::Break;
        -:  231:            }
        -:  232:            return Progress::Continue;
        -:  233:        });
        -:  234:        return result;
        -:  235:    }
        -:  236:private:
        -:  237:
        -:  238:    Progress forwardRecursive(const Token* tok, Info info, const std::function<PathAnalysis::Progress(const Info&)>& f) const;
        -:  239:    Progress forwardRange(const Token* startToken, const Token* endToken, Info info, const std::function<Progress(const Info&)>& f) const;
        -:  240:
        -:  241:    static const Scope* findOuterScope(const Scope * scope);
        -:  242:
        -:  243:    static std::pair<bool, bool> checkCond(const Token * tok, bool& known);
        -:  244:};
        -:  245:
        -:  246:/**
        -:  247: * @brief Returns true if there is a path between the two tokens
        -:  248: *
        -:  249: * @param start Starting point of the path
        -:  250: * @param dest The path destination
        -:  251: * @param errorPath Adds the path traversal to the errorPath
        -:  252: */
        -:  253:bool reaches(const Token * start, const Token * dest, const Library& library, ErrorPath* errorPath);
        -:  254:
        -:  255:/**
        -:  256: * Forward data flow analysis for checks
        -:  257: *  - unused value
        -:  258: *  - redundant assignment
        -:  259: *  - valueflow analysis
        -:  260: */
function _ZN11FwdAnalysisD2Ev called 0 returned 0% blocks executed 0%
    #####:  261:class FwdAnalysis {
call    0 never executed
        -:  262:public:
function _ZN11FwdAnalysisC2EbRK7Library called 0 returned 0% blocks executed 0%
    #####:  263:    FwdAnalysis(bool cpp, const Library &library) : mCpp(cpp), mLibrary(library), mWhat(What::Reassign), mValueFlowKnown(true) {}
call    0 never executed
        -:  264:
        -:  265:    bool hasOperand(const Token *tok, const Token *lhs) const;
        -:  266:
        -:  267:    /**
        -:  268:     * Check if "expr" is reassigned. The "expr" can be a tree (x.y[12]).
        -:  269:     * @param expr Symbolic expression to perform forward analysis for
        -:  270:     * @param startToken First token in forward analysis
        -:  271:     * @param endToken Last token in forward analysis
        -:  272:     * @return Token where expr is reassigned. If it's not reassigned then nullptr is returned.
        -:  273:     */
        -:  274:    const Token *reassign(const Token *expr, const Token *startToken, const Token *endToken);
        -:  275:
        -:  276:    /**
        -:  277:     * Check if "expr" is used. The "expr" can be a tree (x.y[12]).
        -:  278:     * @param expr Symbolic expression to perform forward analysis for
        -:  279:     * @param startToken First token in forward analysis
        -:  280:     * @param endToken Last token in forward analysis
        -:  281:     * @return true if expr is used.
        -:  282:     */
        -:  283:    bool unusedValue(const Token *expr, const Token *startToken, const Token *endToken);
        -:  284:
        -:  285:    struct KnownAndToken {
        -:  286:        bool known;
        -:  287:        const Token *token;
        -:  288:    };
        -:  289:
        -:  290:    std::vector<KnownAndToken> valueFlow(const Token *expr, const Token *startToken, const Token *endToken);
        -:  291:
        -:  292:    /** Is there some possible alias for given expression */
        -:  293:    bool possiblyAliased(const Token *expr, const Token *startToken) const;
        -:  294:
        -:  295:    static bool isNullOperand(const Token *expr);
        -:  296:private:
        -:  297:    static bool isEscapedAlias(const Token* expr);
        -:  298:
        -:  299:    /** Result of forward analysis */
        -:  300:    struct Result {
        -:  301:        enum class Type { NONE, READ, WRITE, BREAK, RETURN, BAILOUT } type;
        -:  302:        explicit Result(Type type) : type(type), token(nullptr) {}
        -:  303:        Result(Type type, const Token *token) : type(type), token(token) {}
        -:  304:        const Token *token;
        -:  305:    };
        -:  306:
        -:  307:    struct Result check(const Token *expr, const Token *startToken, const Token *endToken);
        -:  308:    struct Result checkRecursive(const Token *expr, const Token *startToken, const Token *endToken, const std::set<int> &exprVarIds, bool local, bool inInnerClass);
        -:  309:
        -:  310:    // Is expression a l-value global data?
        -:  311:    bool isGlobalData(const Token *expr) const;
        -:  312:
        -:  313:    const bool mCpp;
        -:  314:    const Library &mLibrary;
        -:  315:    enum class What { Reassign, UnusedValue, ValueFlow } mWhat;
        -:  316:    std::vector<KnownAndToken> mValueFlow;
        -:  317:    bool mValueFlowKnown;
        -:  318:};
        -:  319:
        -:  320:#endif // astutilsH
