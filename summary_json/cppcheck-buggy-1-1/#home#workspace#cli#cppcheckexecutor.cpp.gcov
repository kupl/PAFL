        -:    0:Source:/home/workspace/cli/cppcheckexecutor.cpp
        -:    0:Graph:/home/workspace/build/cli/CMakeFiles/cli_objs.dir/cppcheckexecutor.gcno
        -:    0:Data:/home/workspace/build/cli/CMakeFiles/cli_objs.dir/cppcheckexecutor.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*
        -:    2: * Cppcheck - A tool for static C/C++ code analysis
        -:    3: * Copyright (C) 2007-2019 Cppcheck team.
        -:    4: *
        -:    5: * This program is free software: you can redistribute it and/or modify
        -:    6: * it under the terms of the GNU General Public License as published by
        -:    7: * the Free Software Foundation, either version 3 of the License, or
        -:    8: * (at your option) any later version.
        -:    9: *
        -:   10: * This program is distributed in the hope that it will be useful,
        -:   11: * but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   12: * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   13: * GNU General Public License for more details.
        -:   14: *
        -:   15: * You should have received a copy of the GNU General Public License
        -:   16: * along with this program.  If not, see <http://www.gnu.org/licenses/>.
        -:   17: */
        -:   18:
        -:   19:#include "cppcheckexecutor.h"
        -:   20:
        -:   21:#include "analyzerinfo.h"
        -:   22:#include "cmdlineparser.h"
        -:   23:#include "config.h"
        -:   24:#include "cppcheck.h"
        -:   25:#include "filelister.h"
        -:   26:#include "importproject.h"
        -:   27:#include "library.h"
        -:   28:#include "path.h"
        -:   29:#include "pathmatch.h"
        -:   30:#include "preprocessor.h"
        -:   31:#include "settings.h"
        -:   32:#include "standards.h"
        -:   33:#include "suppressions.h"
        -:   34:#include "threadexecutor.h"
        -:   35:#include "utils.h"
        -:   36:#include "checkunusedfunctions.h"
        -:   37:
        -:   38:#include <csignal>
        -:   39:#include <cstdio>
        -:   40:#include <cstdlib> // EXIT_SUCCESS and EXIT_FAILURE
        -:   41:#include <cstring>
        -:   42:#include <iostream>
        -:   43:#include <list>
        -:   44:#include <utility>
        -:   45:#include <vector>
        -:   46:
        -:   47:#if !defined(NO_UNIX_SIGNAL_HANDLING) && defined(__GNUC__) && !defined(__MINGW32__) && !defined(__OS2__)
        -:   48:#define USE_UNIX_SIGNAL_HANDLING
        -:   49:#include <unistd.h>
        -:   50:#if defined(__APPLE__)
        -:   51:#   define _XOPEN_SOURCE // ucontext.h APIs can only be used on Mac OSX >= 10.7 if _XOPEN_SOURCE is defined
        -:   52:#   include <ucontext.h>
        -:   53:
        -:   54:#   undef _XOPEN_SOURCE
        -:   55:#elif !defined(__OpenBSD__)
        -:   56:#   include <ucontext.h>
        -:   57:#endif
        -:   58:#ifdef __linux__
        -:   59:#include <sys/syscall.h>
        -:   60:#include <sys/types.h>
        -:   61:#endif
        -:   62:#endif
        -:   63:
        -:   64:#if !defined(NO_UNIX_BACKTRACE_SUPPORT) && defined(USE_UNIX_SIGNAL_HANDLING) && defined(__GNUC__) && defined(__GLIBC__) && !defined(__CYGWIN__) && !defined(__MINGW32__) && !defined(__NetBSD__) && !defined(__SVR4) && !defined(__QNX__)
        -:   65:#define USE_UNIX_BACKTRACE_SUPPORT
        -:   66:#include <cxxabi.h>
        -:   67:#include <execinfo.h>
        -:   68:#endif
        -:   69:
        -:   70:#if defined(_MSC_VER)
        -:   71:#define USE_WINDOWS_SEH
        -:   72:#include <DbgHelp.h>
        -:   73:#include <TCHAR.H>
        -:   74:#include <Windows.h>
        -:   75:#include <excpt.h>
        -:   76:#endif
        -:   77:
        -:   78:
        1:   79:/*static*/ FILE* CppCheckExecutor::mExceptionOutput = stdout;
        -:   80:
function _ZN16CppCheckExecutorC2Ev called 0 returned 0% blocks executed 0%
    #####:   81:CppCheckExecutor::CppCheckExecutor()
    #####:   82:    : mSettings(nullptr), mLatestProgressOutputTime(0), mErrorOutput(nullptr), mShowAllErrors(false)
call    0 never executed
call    1 never executed
call    2 never executed
        -:   83:{
    #####:   84:}
        -:   85:
function _ZN16CppCheckExecutorD0Ev called 0 returned 0% blocks executed 0%
function _ZN16CppCheckExecutorD2Ev called 0 returned 0% blocks executed 0%
    #####:   86:CppCheckExecutor::~CppCheckExecutor()
call    0 never executed
call    1 never executed
call    2 never executed
        -:   87:{
    #####:   88:    delete mErrorOutput;
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   89:}
call    0 never executed
call    1 never executed
        -:   90:
function _ZN16CppCheckExecutor13parseFromArgsEP8CppCheckiPKPKc called 0 returned 0% blocks executed 0%
    #####:   91:bool CppCheckExecutor::parseFromArgs(CppCheck *cppcheck, int argc, const char* const argv[])
        -:   92:{
    #####:   93:    Settings& settings = cppcheck->settings();
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   94:    CmdLineParser parser(&settings);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
    #####:   95:    const bool success = parser.parseFromArgs(argc, argv);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   96:
    #####:   97:    if (success) {
branch  0 never executed
branch  1 never executed
    #####:   98:        if (parser.getShowVersion() && !parser.getShowErrorMessages()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:   99:            const char * const extraVersion = cppcheck->extraVersion();
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  100:            if (*extraVersion != 0)
branch  0 never executed
branch  1 never executed
        -:  101:                std::cout << "Cppcheck " << cppcheck->version() << " ("
    #####:  102:                          << extraVersion << ')' << std::endl;
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
call    9 never executed
branch 10 never executed
branch 11 never executed
call   12 never executed
branch 13 never executed
branch 14 never executed
call   15 never executed
branch 16 never executed
branch 17 never executed
call   18 never executed
branch 19 never executed
branch 20 never executed
        -:  103:            else
    #####:  104:                std::cout << "Cppcheck " << cppcheck->version() << std::endl;
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
call    9 never executed
branch 10 never executed
branch 11 never executed
        -:  105:        }
        -:  106:
    #####:  107:        if (parser.getShowErrorMessages()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  108:            mShowAllErrors = true;
    #####:  109:            std::cout << ErrorLogger::ErrorMessage::getXMLHeader();
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
call    7 never executed
    #####:  110:            cppcheck->getErrorMessages();
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  111:            std::cout << ErrorLogger::ErrorMessage::getXMLFooter() << std::endl;
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
        -:  112:        }
        -:  113:
    #####:  114:        if (parser.exitAfterPrinting()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  115:            settings.terminate();
call    0 never executed
    #####:  116:            return true;
        -:  117:        }
        -:  118:    } else {
    #####:  119:        return false;
        -:  120:    }
        -:  121:
        -:  122:    // Check that all include paths exist
        -:  123:    {
    #####:  124:        for (std::list<std::string>::iterator iter = settings.includePaths.begin();
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  125:             iter != settings.includePaths.end();
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  126:            ) {
    #####:  127:            const std::string path(Path::toNativeSeparators(*iter));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
    #####:  128:            if (FileLister::isDirectory(path))
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  129:                ++iter;
call    0 never executed
        -:  130:            else {
        -:  131:                // If the include path is not found, warn user and remove the non-existing path from the list.
    #####:  132:                if (settings.isEnabled(Settings::INFORMATION))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  133:                    std::cout << "(information) Couldn't find path given by -I '" << path << '\'' << std::endl;
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
call    9 never executed
branch 10 never executed
branch 11 never executed
    #####:  134:                iter = settings.includePaths.erase(iter);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  135:            }
        -:  136:        }
        -:  137:    }
        -:  138:
        -:  139:    // Output a warning for the user if he tries to exclude headers
    #####:  140:    bool warn = false;
    #####:  141:    const std::vector<std::string>& ignored = parser.getIgnoredPaths();
call    0 never executed
    #####:  142:    for (const std::string &i : ignored) {
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
    #####:  143:        if (Path::isHeader(i)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  144:            warn = true;
    #####:  145:            break;
        -:  146:        }
        -:  147:    }
    #####:  148:    if (warn) {
branch  0 never executed
branch  1 never executed
    #####:  149:        std::cout << "cppcheck: filename exclusion does not apply to header (.h and .hpp) files." << std::endl;
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  150:        std::cout << "cppcheck: Please use --suppress for ignoring results from the header files." << std::endl;
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -:  151:    }
        -:  152:
    #####:  153:    const std::vector<std::string>& pathnames = parser.getPathNames();
call    0 never executed
        -:  154:
        -:  155:#if defined(_WIN32)
        -:  156:    // For Windows we want case-insensitive path matching
        -:  157:    const bool caseSensitive = false;
        -:  158:#else
    #####:  159:    const bool caseSensitive = true;
        -:  160:#endif
    #####:  161:    if (!pathnames.empty()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  162:        // Execute recursiveAddFiles() to each given file parameter
    #####:  163:        const PathMatch matcher(ignored, caseSensitive);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
    #####:  164:        for (const std::string &pathname : pathnames)
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
    #####:  165:            FileLister::recursiveAddFiles(mFiles, Path::toNativeSeparators(pathname), mSettings->library.markupExtensions(), matcher);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
branch  8 never executed
branch  9 never executed
call   10 never executed
call   11 never executed
call   12 never executed
call   13 never executed
        -:  166:    }
        -:  167:
    #####:  168:    if (mFiles.empty() && settings.project.fileSettings.empty()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:  169:        std::cout << "cppcheck: error: could not find or open any of the paths given." << std::endl;
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  170:        if (!ignored.empty())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  171:            std::cout << "cppcheck: Maybe all paths were ignored?" << std::endl;
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  172:        return false;
        -:  173:    }
    #####:  174:    return true;
        -:  175:}
        -:  176:
function _ZN16CppCheckExecutor5checkEiPKPKc called 0 returned 0% blocks executed 0%
    #####:  177:int CppCheckExecutor::check(int argc, const char* const argv[])
        -:  178:{
    #####:  179:    Preprocessor::missingIncludeFlag = false;
    #####:  180:    Preprocessor::missingSystemIncludeFlag = false;
        -:  181:
    #####:  182:    CheckUnusedFunctions::clear();
call    0 never executed
        -:  183:
    #####:  184:    CppCheck cppCheck(*this, true);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
        -:  185:
    #####:  186:    const Settings& settings = cppCheck.settings();
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  187:    mSettings = &settings;
        -:  188:
    #####:  189:    if (!parseFromArgs(&cppCheck, argc, argv)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  190:        return EXIT_FAILURE;
        -:  191:    }
    #####:  192:    if (settings.terminated()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  193:        return EXIT_SUCCESS;
        -:  194:    }
    #####:  195:    if (cppCheck.settings().exceptionHandling) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  196:        return check_wrapper(cppCheck, argc, argv);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  197:    }
    #####:  198:    return check_internal(cppCheck, argc, argv);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  199:}
        -:  200:
function _ZN16CppCheckExecutor11setSettingsERK8Settings called 0 returned 0% blocks executed 0%
    #####:  201:void CppCheckExecutor::setSettings(const Settings &settings)
        -:  202:{
    #####:  203:    mSettings = &settings;
    #####:  204:}
        -:  205:
        -:  206:/**
        -:  207: *  Simple helper function:
        -:  208: * \return size of array
        -:  209: * */
        -:  210:template<typename T, int size>
function _Z14GetArrayLengthIcLi2048EEmRAT0__KT_ called 0 returned 0% blocks executed 0%
function _Z14GetArrayLengthIPvLi32EEmRAT0__KT_ called 0 returned 0% blocks executed 0%
    #####:  211:std::size_t GetArrayLength(const T(&)[size])
        -:  212:{
    #####:  213:    return size;
        -:  214:}
        -:  215:
        -:  216:
        -:  217:#if defined(USE_UNIX_SIGNAL_HANDLING)
        -:  218:/*
        -:  219: * Try to print the callstack.
        -:  220: * That is very sensitive to the operating system, hardware, compiler and runtime.
        -:  221: * The code is not meant for production environment!
        -:  222: * One reason is named first: it's using functions not whitelisted for usage in a signal handler function.
        -:  223: */
function _ZL16print_stacktraceP8_IO_FILEbib called 0 returned 0% blocks executed 0%
    #####:  224:static void print_stacktrace(FILE* output, bool demangling, int maxdepth, bool lowMem)
        -:  225:{
        -:  226:#if defined(USE_UNIX_BACKTRACE_SUPPORT)
        -:  227:// 32 vs. 64bit
        -:  228:#define ADDRESSDISPLAYLENGTH ((sizeof(long)==8)?12:8)
    #####:  229:    const int fd = fileno(output);
call    0 never executed
    #####:  230:    void *callstackArray[32]= {nullptr}; // the less resources the better...
    #####:  231:    const int currentdepth = backtrace(callstackArray, (int)GetArrayLength(callstackArray));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  232:    const int offset=2; // some entries on top are within our own exception handling code or libc
    #####:  233:    if (maxdepth<0)
branch  0 never executed
branch  1 never executed
    #####:  234:        maxdepth=currentdepth-offset;
        -:  235:    else
    #####:  236:        maxdepth = std::min(maxdepth, currentdepth);
call    0 never executed
    #####:  237:    if (lowMem) {
branch  0 never executed
branch  1 never executed
    #####:  238:        fputs("Callstack (symbols only):\n", output);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  239:        backtrace_symbols_fd(callstackArray+offset, maxdepth, fd);
call    0 never executed
        -:  240:    } else {
    #####:  241:        char **symbolStringList = backtrace_symbols(callstackArray, currentdepth);
call    0 never executed
    #####:  242:        if (symbolStringList) {
branch  0 never executed
branch  1 never executed
    #####:  243:            fputs("Callstack:\n", output);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  244:            for (int i = offset; i < maxdepth; ++i) {
branch  0 never executed
branch  1 never executed
    #####:  245:                const char * const symbolString = symbolStringList[i];
    #####:  246:                char * realnameString = nullptr;
    #####:  247:                const char * const firstBracketName     = strchr(symbolString, '(');
    #####:  248:                const char * const firstBracketAddress  = strchr(symbolString, '[');
    #####:  249:                const char * const secondBracketAddress = strchr(firstBracketAddress, ']');
    #####:  250:                const char * const beginAddress         = firstBracketAddress+3;
    #####:  251:                const int addressLen = int(secondBracketAddress-beginAddress);
    #####:  252:                const int padLen     = int(ADDRESSDISPLAYLENGTH-addressLen);
    #####:  253:                if (demangling && firstBracketName) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  254:                    const char * const plus = strchr(firstBracketName, '+');
    #####:  255:                    if (plus && (plus>(firstBracketName+1))) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  256:                        char input_buffer[1024]= {0};
    #####:  257:                        strncpy(input_buffer, firstBracketName+1, plus-firstBracketName-1);
    #####:  258:                        char output_buffer[2048]= {0};
    #####:  259:                        size_t length = GetArrayLength(output_buffer);
call    0 never executed
    #####:  260:                        int status=0;
        -:  261:                        // We're violating the specification - passing stack address instead of malloc'ed heap.
        -:  262:                        // Benefit is that no further heap is required, while there is sufficient stack...
    #####:  263:                        realnameString = abi::__cxa_demangle(input_buffer, output_buffer, &length, &status); // non-NULL on success
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  264:                    }
        -:  265:                }
    #####:  266:                const int ordinal=i-offset;
    #####:  267:                fprintf(output, "#%-2d 0x",
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  268:                        ordinal);
    #####:  269:                if (padLen>0)
branch  0 never executed
branch  1 never executed
    #####:  270:                    fprintf(output, "%0*d",
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  271:                            padLen, 0);
    #####:  272:                if (realnameString) {
branch  0 never executed
branch  1 never executed
    #####:  273:                    fprintf(output, "%.*s in %s\n",
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  274:                            (int)(secondBracketAddress-firstBracketAddress-3), firstBracketAddress+3,
        -:  275:                            realnameString);
        -:  276:                } else {
    #####:  277:                    fprintf(output, "%.*s in %.*s\n",
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  278:                            (int)(secondBracketAddress-firstBracketAddress-3), firstBracketAddress+3,
    #####:  279:                            (int)(firstBracketAddress-symbolString), symbolString);
        -:  280:                }
        -:  281:            }
    #####:  282:            free(symbolStringList);
        -:  283:        } else {
    #####:  284:            fputs("Callstack could not be obtained\n", output);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  285:        }
        -:  286:    }
        -:  287:#undef ADDRESSDISPLAYLENGTH
        -:  288:#else
        -:  289:    UNUSED(output);
        -:  290:    UNUSED(demangling);
        -:  291:    UNUSED(maxdepth);
        -:  292:    UNUSED(lowMem);
        -:  293:#endif
    #####:  294:}
        -:  295:
        -:  296:static const size_t MYSTACKSIZE = 16*1024+SIGSTKSZ; // wild guess about a reasonable buffer
        -:  297:static char mytstack[MYSTACKSIZE]= {0}; // alternative stack for signal handler
        -:  298:static bool bStackBelowHeap=false; // lame attempt to locate heap vs. stack address space. See CppCheckExecutor::check_wrapper()
        -:  299:
        -:  300:/**
        -:  301: * \param[in] ptr address to be examined.
        -:  302: * \return true if address is supposed to be on stack (contrary to heap). If ptr is 0 false will be returned.
        -:  303: * If unknown better return false.
        -:  304: */
function _ZL16IsAddressOnStackPKv called 0 returned 0% blocks executed 0%
    #####:  305:static bool IsAddressOnStack(const void* ptr)
        -:  306:{
    #####:  307:    if (nullptr==ptr)
branch  0 never executed
branch  1 never executed
    #####:  308:        return false;
        -:  309:    char a;
    #####:  310:    if (bStackBelowHeap)
branch  0 never executed
branch  1 never executed
    #####:  311:        return ptr < &a;
        -:  312:    else
    #####:  313:        return ptr > &a;
        -:  314:}
        -:  315:
        -:  316:/* (declare this list here, so it may be used in signal handlers in addition to main())
        -:  317: * A list of signals available in ISO C
        -:  318: * Check out http://pubs.opengroup.org/onlinepubs/009695399/basedefs/signal.h.html
        -:  319: * For now we only want to detect abnormal behaviour for a few selected signals:
        -:  320: */
        -:  321:
        -:  322:#define DECLARE_SIGNAL(x) std::make_pair(x, #x)
        -:  323:typedef std::map<int, std::string> Signalmap_t;
       19:  324:static const Signalmap_t listofsignals = {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
branch 13 taken 100% (fallthrough)
branch 14 taken 0% (throw)
call   15 returned 100%
branch 16 taken 100% (fallthrough)
branch 17 taken 0% (throw)
call   18 returned 100%
branch 19 taken 100% (fallthrough)
branch 20 taken 0% (throw)
call   21 returned 100%
branch 22 taken 100% (fallthrough)
branch 23 taken 0% (throw)
call   24 returned 100%
branch 25 taken 100% (fallthrough)
branch 26 taken 0% (throw)
call   27 returned 100%
call   28 returned 100%
branch 29 taken 100% (fallthrough)
branch 30 taken 0% (throw)
call   31 returned 100%
branch 32 taken 90% (fallthrough)
branch 33 taken 10%
call   34 returned 100%
call   35 never executed
branch 36 never executed
branch 37 never executed
        2:  325:    DECLARE_SIGNAL(SIGABRT),
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        2:  326:    DECLARE_SIGNAL(SIGBUS),
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        2:  327:    DECLARE_SIGNAL(SIGFPE),
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        2:  328:    DECLARE_SIGNAL(SIGILL),
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        2:  329:    DECLARE_SIGNAL(SIGINT),
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        2:  330:    DECLARE_SIGNAL(SIGQUIT),
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        2:  331:    DECLARE_SIGNAL(SIGSEGV),
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        2:  332:    DECLARE_SIGNAL(SIGSYS),
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  333:    // don't care: SIGTERM
        2:  334:    DECLARE_SIGNAL(SIGUSR1),
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  335:    //DECLARE_SIGNAL(SIGUSR2) no usage currently
        9:  336:};
call    0 returned 100%
call    1 never executed
        -:  337:#undef DECLARE_SIGNAL
        -:  338:/*
        -:  339: * Entry pointer for signal handlers
        -:  340: * It uses functions which are not safe to be called from a signal handler,
        -:  341: * (http://pubs.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html#tag_15_04 has a whitelist)
        -:  342: * but when ending up here something went terribly wrong anyway.
        -:  343: * And all which is left is just printing some information and terminate.
        -:  344: */
function _ZL21CppcheckSignalHandleriP9siginfo_tPv called 0 returned 0% blocks executed 0%
    #####:  345:static void CppcheckSignalHandler(int signo, siginfo_t * info, void * context)
        -:  346:{
    #####:  347:    int type = -1;
        -:  348:    pid_t killid;
        -:  349:#if defined(__linux__) && defined(REG_ERR)
    #####:  350:    const ucontext_t* const uc = reinterpret_cast<const ucontext_t*>(context);
    #####:  351:    killid = (pid_t) syscall(SYS_gettid);
call    0 never executed
    #####:  352:    if (uc) {
branch  0 never executed
branch  1 never executed
    #####:  353:        type = (int)uc->uc_mcontext.gregs[REG_ERR] & 2;
        -:  354:    }
        -:  355:#else
        -:  356:    UNUSED(context);
        -:  357:    killid = getpid();
        -:  358:#endif
        -:  359:
    #####:  360:    const Signalmap_t::const_iterator it=listofsignals.find(signo);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
    #####:  361:    const char * const signame = (it==listofsignals.end()) ? "unknown" : it->second.c_str();
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
    #####:  362:    bool printCallstack=true; // try to print a callstack?
    #####:  363:    bool lowMem=false; // was low-memory condition detected? Be careful then! Avoid allocating much more memory then.
    #####:  364:    bool unexpectedSignal=true; // unexpected indicates program failure
    #####:  365:    bool terminate=true; // exit process/thread
    #####:  366:    const bool isAddressOnStack = IsAddressOnStack(info->si_addr);
call    0 never executed
    #####:  367:    FILE* output = CppCheckExecutor::getExceptionOutput();
call    0 never executed
    #####:  368:    switch (signo) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:  369:    case SIGABRT:
    #####:  370:        fputs("Internal error: cppcheck received signal ", output);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  371:        fputs(signame, output);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  372:        fputs(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  373:#ifdef NDEBUG
        -:  374:            " - out of memory?\n",
        -:  375:#else
        -:  376:            " - out of memory or assertion?\n",
        -:  377:#endif
        -:  378:            output);
    #####:  379:        lowMem=true; // educated guess
    #####:  380:        break;
    #####:  381:    case SIGBUS:
    #####:  382:        fputs("Internal error: cppcheck received signal ", output);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  383:        fputs(signame, output);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  384:        switch (info->si_code) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  385:        case BUS_ADRALN: // invalid address alignment
    #####:  386:            fputs(" - BUS_ADRALN", output);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  387:            break;
    #####:  388:        case BUS_ADRERR: // nonexistent physical address
    #####:  389:            fputs(" - BUS_ADRERR", output);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  390:            break;
    #####:  391:        case BUS_OBJERR: // object-specific hardware error
    #####:  392:            fputs(" - BUS_OBJERR", output);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  393:            break;
        -:  394:#ifdef BUS_MCEERR_AR
    #####:  395:        case BUS_MCEERR_AR: // Hardware memory error consumed on a machine check;
    #####:  396:            fputs(" - BUS_MCEERR_AR", output);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  397:            break;
        -:  398:#endif
        -:  399:#ifdef BUS_MCEERR_AO
    #####:  400:        case BUS_MCEERR_AO: // Hardware memory error detected in process but not consumed
    #####:  401:            fputs(" - BUS_MCEERR_AO", output);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  402:            break;
        -:  403:#endif
    #####:  404:        default:
    #####:  405:            break;
        -:  406:        }
    #####:  407:        fprintf(output, " (at 0x%lx).\n",
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  408:                (unsigned long)info->si_addr);
    #####:  409:        break;
    #####:  410:    case SIGFPE:
    #####:  411:        fputs("Internal error: cppcheck received signal ", output);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  412:        fputs(signame, output);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  413:        switch (info->si_code) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
    #####:  414:        case FPE_INTDIV: //     integer divide by zero
    #####:  415:            fputs(" - FPE_INTDIV", output);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  416:            break;
    #####:  417:        case FPE_INTOVF: //     integer overflow
    #####:  418:            fputs(" - FPE_INTOVF", output);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  419:            break;
    #####:  420:        case FPE_FLTDIV: //     floating-point divide by zero
    #####:  421:            fputs(" - FPE_FLTDIV", output);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  422:            break;
    #####:  423:        case FPE_FLTOVF: //     floating-point overflow
    #####:  424:            fputs(" - FPE_FLTOVF", output);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  425:            break;
    #####:  426:        case FPE_FLTUND: //     floating-point underflow
    #####:  427:            fputs(" - FPE_FLTUND", output);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  428:            break;
    #####:  429:        case FPE_FLTRES: //     floating-point inexact result
    #####:  430:            fputs(" - FPE_FLTRES", output);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  431:            break;
    #####:  432:        case FPE_FLTINV: //     floating-point invalid operation
    #####:  433:            fputs(" - FPE_FLTINV", output);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  434:            break;
    #####:  435:        case FPE_FLTSUB: //     subscript out of range
    #####:  436:            fputs(" - FPE_FLTSUB", output);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  437:            break;
    #####:  438:        default:
    #####:  439:            break;
        -:  440:        }
    #####:  441:        fprintf(output, " (at 0x%lx).\n",
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  442:                (unsigned long)info->si_addr);
    #####:  443:        break;
    #####:  444:    case SIGILL:
    #####:  445:        fputs("Internal error: cppcheck received signal ", output);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  446:        fputs(signame, output);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  447:        switch (info->si_code) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
    #####:  448:        case ILL_ILLOPC: //     illegal opcode
    #####:  449:            fputs(" - ILL_ILLOPC", output);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  450:            break;
    #####:  451:        case ILL_ILLOPN: //    illegal operand
    #####:  452:            fputs(" - ILL_ILLOPN", output);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  453:            break;
    #####:  454:        case ILL_ILLADR: //    illegal addressing mode
    #####:  455:            fputs(" - ILL_ILLADR", output);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  456:            break;
    #####:  457:        case ILL_ILLTRP: //    illegal trap
    #####:  458:            fputs(" - ILL_ILLTRP", output);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  459:            break;
    #####:  460:        case ILL_PRVOPC: //    privileged opcode
    #####:  461:            fputs(" - ILL_PRVOPC", output);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  462:            break;
    #####:  463:        case ILL_PRVREG: //    privileged register
    #####:  464:            fputs(" - ILL_PRVREG", output);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  465:            break;
    #####:  466:        case ILL_COPROC: //    coprocessor error
    #####:  467:            fputs(" - ILL_COPROC", output);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  468:            break;
    #####:  469:        case ILL_BADSTK: //    internal stack error
    #####:  470:            fputs(" - ILL_BADSTK", output);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  471:            break;
    #####:  472:        default:
    #####:  473:            break;
        -:  474:        }
    #####:  475:        fprintf(output, " (at 0x%lx).%s\n",
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  476:                (unsigned long)info->si_addr,
        -:  477:                (isAddressOnStack)?" Stackoverflow?":"");
    #####:  478:        break;
    #####:  479:    case SIGINT:
    #####:  480:        unexpectedSignal=false; // legal usage: interrupt application via CTRL-C
    #####:  481:        fputs("cppcheck received signal ", output);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  482:        fputs(signame, output);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  483:        printCallstack=true;
    #####:  484:        fputs(".\n", output);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  485:        break;
    #####:  486:    case SIGSEGV:
    #####:  487:        fputs("Internal error: cppcheck received signal ", output);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  488:        fputs(signame, output);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  489:        switch (info->si_code) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
    #####:  490:        case SEGV_MAPERR: //    address not mapped to object
    #####:  491:            fputs(" - SEGV_MAPERR", output);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  492:            break;
    #####:  493:        case SEGV_ACCERR: //    invalid permissions for mapped object
    #####:  494:            fputs(" - SEGV_ACCERR", output);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  495:            break;
    #####:  496:        default:
    #####:  497:            break;
        -:  498:        }
    #####:  499:        fprintf(output, " (%sat 0x%lx).%s\n",
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
        -:  500:                // cppcheck-suppress knownConditionTrueFalse ; FP
        -:  501:                (type==-1)? "" :
        -:  502:                (type==0) ? "reading " : "writing ",
    #####:  503:                (unsigned long)info->si_addr,
        -:  504:                (isAddressOnStack)?" Stackoverflow?":""
        -:  505:               );
    #####:  506:        break;
    #####:  507:    case SIGUSR1:
    #####:  508:        fputs("cppcheck received signal ", output);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  509:        fputs(signame, output);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  510:        fputs(".\n", output);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  511:        terminate=false;
    #####:  512:        break;
    #####:  513:    default:
    #####:  514:        fputs("Internal error: cppcheck received signal ", output);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  515:        fputs(signame, output);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  516:        fputs(".\n", output);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  517:        break;
        -:  518:    }
    #####:  519:    if (printCallstack) {
branch  0 never executed
branch  1 never executed
    #####:  520:        print_stacktrace(output, true, -1, lowMem);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  521:    }
    #####:  522:    if (unexpectedSignal) {
branch  0 never executed
branch  1 never executed
    #####:  523:        fputs("\nPlease report this to the cppcheck developers!\n", output);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  524:    }
    #####:  525:    fflush(output);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  526:
    #####:  527:    if (terminate) {
branch  0 never executed
branch  1 never executed
        -:  528:        // now let things proceed, shutdown and hopefully dump core for post-mortem analysis
        -:  529:        struct sigaction act;
    #####:  530:        memset(&act, 0, sizeof(act));
    #####:  531:        act.sa_handler=SIG_DFL;
    #####:  532:        sigaction(signo, &act, nullptr);
call    0 never executed
    #####:  533:        kill(killid, signo);
call    0 never executed
        -:  534:    }
    #####:  535:}
        -:  536:#endif
        -:  537:
        -:  538:#ifdef USE_WINDOWS_SEH
        -:  539:namespace {
        -:  540:    const ULONG maxnamelength = 512;
        -:  541:    struct IMAGEHLP_SYMBOL64_EXT : public IMAGEHLP_SYMBOL64 {
        -:  542:        TCHAR NameExt[maxnamelength]; // actually no need to worry about character encoding here
        -:  543:    };
        -:  544:    typedef BOOL (WINAPI *fpStackWalk64)(DWORD, HANDLE, HANDLE, LPSTACKFRAME64, PVOID, PREAD_PROCESS_MEMORY_ROUTINE64, PFUNCTION_TABLE_ACCESS_ROUTINE64, PGET_MODULE_BASE_ROUTINE64, PTRANSLATE_ADDRESS_ROUTINE64);
        -:  545:    fpStackWalk64 pStackWalk64;
        -:  546:    typedef DWORD64(WINAPI *fpSymGetModuleBase64)(HANDLE, DWORD64);
        -:  547:    fpSymGetModuleBase64 pSymGetModuleBase64;
        -:  548:    typedef BOOL (WINAPI *fpSymGetSymFromAddr64)(HANDLE, DWORD64, PDWORD64, PIMAGEHLP_SYMBOL64);
        -:  549:    fpSymGetSymFromAddr64 pSymGetSymFromAddr64;
        -:  550:    typedef BOOL (WINAPI *fpSymGetLineFromAddr64)(HANDLE, DWORD64, PDWORD, PIMAGEHLP_LINE64);
        -:  551:    fpSymGetLineFromAddr64 pSymGetLineFromAddr64;
        -:  552:    typedef DWORD (WINAPI *fpUnDecorateSymbolName)(const TCHAR*, PTSTR, DWORD, DWORD) ;
        -:  553:    fpUnDecorateSymbolName pUnDecorateSymbolName;
        -:  554:    typedef PVOID(WINAPI *fpSymFunctionTableAccess64)(HANDLE, DWORD64);
        -:  555:    fpSymFunctionTableAccess64 pSymFunctionTableAccess64;
        -:  556:    typedef BOOL (WINAPI *fpSymInitialize)(HANDLE, PCSTR, BOOL);
        -:  557:    fpSymInitialize pSymInitialize;
        -:  558:
        -:  559:    HMODULE hLibDbgHelp;
        -:  560:// avoid explicit dependency on Dbghelp.dll
        -:  561:    bool loadDbgHelp()
        -:  562:    {
        -:  563:        hLibDbgHelp = ::LoadLibraryW(L"Dbghelp.dll");
        -:  564:        if (!hLibDbgHelp)
        -:  565:            return false;
        -:  566:        pStackWalk64 = (fpStackWalk64) ::GetProcAddress(hLibDbgHelp, "StackWalk64");
        -:  567:        pSymGetModuleBase64 = (fpSymGetModuleBase64) ::GetProcAddress(hLibDbgHelp, "SymGetModuleBase64");
        -:  568:        pSymGetSymFromAddr64 = (fpSymGetSymFromAddr64) ::GetProcAddress(hLibDbgHelp, "SymGetSymFromAddr64");
        -:  569:        pSymGetLineFromAddr64 = (fpSymGetLineFromAddr64)::GetProcAddress(hLibDbgHelp, "SymGetLineFromAddr64");
        -:  570:        pSymFunctionTableAccess64 = (fpSymFunctionTableAccess64)::GetProcAddress(hLibDbgHelp, "SymFunctionTableAccess64");
        -:  571:        pSymInitialize = (fpSymInitialize) ::GetProcAddress(hLibDbgHelp, "SymInitialize");
        -:  572:        pUnDecorateSymbolName = (fpUnDecorateSymbolName)::GetProcAddress(hLibDbgHelp, "UnDecorateSymbolName");
        -:  573:        return true;
        -:  574:    }
        -:  575:
        -:  576:
        -:  577:    void PrintCallstack(FILE* outputFile, PEXCEPTION_POINTERS ex)
        -:  578:    {
        -:  579:        if (!loadDbgHelp())
        -:  580:            return;
        -:  581:        const HANDLE hProcess   = GetCurrentProcess();
        -:  582:        const HANDLE hThread    = GetCurrentThread();
        -:  583:        pSymInitialize(
        -:  584:            hProcess,
        -:  585:            nullptr,
        -:  586:            TRUE
        -:  587:        );
        -:  588:        CONTEXT             context = *(ex->ContextRecord);
        -:  589:        STACKFRAME64        stack= {0};
        -:  590:#ifdef _M_IX86
        -:  591:        stack.AddrPC.Offset    = context.Eip;
        -:  592:        stack.AddrPC.Mode      = AddrModeFlat;
        -:  593:        stack.AddrStack.Offset = context.Esp;
        -:  594:        stack.AddrStack.Mode   = AddrModeFlat;
        -:  595:        stack.AddrFrame.Offset = context.Ebp;
        -:  596:        stack.AddrFrame.Mode   = AddrModeFlat;
        -:  597:#else
        -:  598:        stack.AddrPC.Offset    = context.Rip;
        -:  599:        stack.AddrPC.Mode      = AddrModeFlat;
        -:  600:        stack.AddrStack.Offset = context.Rsp;
        -:  601:        stack.AddrStack.Mode   = AddrModeFlat;
        -:  602:        stack.AddrFrame.Offset = context.Rsp;
        -:  603:        stack.AddrFrame.Mode   = AddrModeFlat;
        -:  604:#endif
        -:  605:        IMAGEHLP_SYMBOL64_EXT symbol;
        -:  606:        symbol.SizeOfStruct  = sizeof(IMAGEHLP_SYMBOL64);
        -:  607:        symbol.MaxNameLength = maxnamelength;
        -:  608:        DWORD64 displacement   = 0;
        -:  609:        int beyond_main=-1; // emergency exit, see below
        -:  610:        for (ULONG frame = 0; ; frame++) {
        -:  611:            BOOL result = pStackWalk64
        -:  612:                          (
        -:  613:#ifdef _M_IX86
        -:  614:                              IMAGE_FILE_MACHINE_I386,
        -:  615:#else
        -:  616:                              IMAGE_FILE_MACHINE_AMD64,
        -:  617:#endif
        -:  618:                              hProcess,
        -:  619:                              hThread,
        -:  620:                              &stack,
        -:  621:                              &context,
        -:  622:                              nullptr,
        -:  623:                              pSymFunctionTableAccess64,
        -:  624:                              pSymGetModuleBase64,
        -:  625:                              nullptr
        -:  626:                          );
        -:  627:            if (!result)  // official end...
        -:  628:                break;
        -:  629:            pSymGetSymFromAddr64(hProcess, (ULONG64)stack.AddrPC.Offset, &displacement, &symbol);
        -:  630:            TCHAR undname[maxnamelength]= {0};
        -:  631:            pUnDecorateSymbolName((const TCHAR*)symbol.Name, (PTSTR)undname, (DWORD)GetArrayLength(undname), UNDNAME_COMPLETE);
        -:  632:            if (beyond_main>=0)
        -:  633:                ++beyond_main;
        -:  634:            if (_tcscmp(undname, _T("main"))==0)
        -:  635:                beyond_main=0;
        -:  636:            fprintf(outputFile,
        -:  637:                    "%lu. 0x%08I64X in ",
        -:  638:                    frame, (ULONG64)stack.AddrPC.Offset);
        -:  639:            fputs((const char *)undname, outputFile);
        -:  640:            fputc('\n', outputFile);
        -:  641:            if (0==stack.AddrReturn.Offset || beyond_main>2) // StackWalk64() sometimes doesn't reach any end...
        -:  642:                break;
        -:  643:        }
        -:  644:
        -:  645:        FreeLibrary(hLibDbgHelp);
        -:  646:        hLibDbgHelp=nullptr;
        -:  647:    }
        -:  648:
        -:  649:    void writeMemoryErrorDetails(FILE* outputFile, PEXCEPTION_POINTERS ex, const char* description)
        -:  650:    {
        -:  651:        fputs(description, outputFile);
        -:  652:        fprintf(outputFile, " (instruction: 0x%p) ", ex->ExceptionRecord->ExceptionAddress);
        -:  653:        // Using %p for ULONG_PTR later on, so it must have size identical to size of pointer
        -:  654:        // This is not the universally portable solution but good enough for Win32/64
        -:  655:        C_ASSERT(sizeof(void*) == sizeof(ex->ExceptionRecord->ExceptionInformation[1]));
        -:  656:        switch (ex->ExceptionRecord->ExceptionInformation[0]) {
        -:  657:        case 0:
        -:  658:            fprintf(outputFile, "reading from 0x%p",
        -:  659:                    reinterpret_cast<void*>(ex->ExceptionRecord->ExceptionInformation[1]));
        -:  660:            break;
        -:  661:        case 1:
        -:  662:            fprintf(outputFile, "writing to 0x%p",
        -:  663:                    reinterpret_cast<void*>(ex->ExceptionRecord->ExceptionInformation[1]));
        -:  664:            break;
        -:  665:        case 8:
        -:  666:            fprintf(outputFile, "data execution prevention at 0x%p",
        -:  667:                    reinterpret_cast<void*>(ex->ExceptionRecord->ExceptionInformation[1]));
        -:  668:            break;
        -:  669:        default:
        -:  670:            break;
        -:  671:        }
        -:  672:    }
        -:  673:
        -:  674:    /*
        -:  675:     * Any evaluation of the exception needs to be done here!
        -:  676:     */
        -:  677:    int filterException(int code, PEXCEPTION_POINTERS ex)
        -:  678:    {
        -:  679:        FILE *outputFile = stdout;
        -:  680:        fputs("Internal error: ", outputFile);
        -:  681:        switch (ex->ExceptionRecord->ExceptionCode) {
        -:  682:        case EXCEPTION_ACCESS_VIOLATION:
        -:  683:            writeMemoryErrorDetails(outputFile, ex, "Access violation");
        -:  684:            break;
        -:  685:        case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:
        -:  686:            fputs("Out of array bounds", outputFile);
        -:  687:            break;
        -:  688:        case EXCEPTION_BREAKPOINT:
        -:  689:            fputs("Breakpoint", outputFile);
        -:  690:            break;
        -:  691:        case EXCEPTION_DATATYPE_MISALIGNMENT:
        -:  692:            fputs("Misaligned data", outputFile);
        -:  693:            break;
        -:  694:        case EXCEPTION_FLT_DENORMAL_OPERAND:
        -:  695:            fputs("Denormalized floating-point value", outputFile);
        -:  696:            break;
        -:  697:        case EXCEPTION_FLT_DIVIDE_BY_ZERO:
        -:  698:            fputs("Floating-point divide-by-zero", outputFile);
        -:  699:            break;
        -:  700:        case EXCEPTION_FLT_INEXACT_RESULT:
        -:  701:            fputs("Inexact floating-point value", outputFile);
        -:  702:            break;
        -:  703:        case EXCEPTION_FLT_INVALID_OPERATION:
        -:  704:            fputs("Invalid floating-point operation", outputFile);
        -:  705:            break;
        -:  706:        case EXCEPTION_FLT_OVERFLOW:
        -:  707:            fputs("Floating-point overflow", outputFile);
        -:  708:            break;
        -:  709:        case EXCEPTION_FLT_STACK_CHECK:
        -:  710:            fputs("Floating-point stack overflow", outputFile);
        -:  711:            break;
        -:  712:        case EXCEPTION_FLT_UNDERFLOW:
        -:  713:            fputs("Floating-point underflow", outputFile);
        -:  714:            break;
        -:  715:        case EXCEPTION_GUARD_PAGE:
        -:  716:            fputs("Page-guard access", outputFile);
        -:  717:            break;
        -:  718:        case EXCEPTION_ILLEGAL_INSTRUCTION:
        -:  719:            fputs("Illegal instruction", outputFile);
        -:  720:            break;
        -:  721:        case EXCEPTION_IN_PAGE_ERROR:
        -:  722:            writeMemoryErrorDetails(outputFile, ex, "Invalid page access");
        -:  723:            break;
        -:  724:        case EXCEPTION_INT_DIVIDE_BY_ZERO:
        -:  725:            fputs("Integer divide-by-zero", outputFile);
        -:  726:            break;
        -:  727:        case EXCEPTION_INT_OVERFLOW:
        -:  728:            fputs("Integer overflow", outputFile);
        -:  729:            break;
        -:  730:        case EXCEPTION_INVALID_DISPOSITION:
        -:  731:            fputs("Invalid exception dispatcher", outputFile);
        -:  732:            break;
        -:  733:        case EXCEPTION_INVALID_HANDLE:
        -:  734:            fputs("Invalid handle", outputFile);
        -:  735:            break;
        -:  736:        case EXCEPTION_NONCONTINUABLE_EXCEPTION:
        -:  737:            fputs("Non-continuable exception", outputFile);
        -:  738:            break;
        -:  739:        case EXCEPTION_PRIV_INSTRUCTION:
        -:  740:            fputs("Invalid instruction", outputFile);
        -:  741:            break;
        -:  742:        case EXCEPTION_SINGLE_STEP:
        -:  743:            fputs("Single instruction step", outputFile);
        -:  744:            break;
        -:  745:        case EXCEPTION_STACK_OVERFLOW:
        -:  746:            fputs("Stack overflow", outputFile);
        -:  747:            break;
        -:  748:        default:
        -:  749:            fprintf(outputFile, "Unknown exception (%d)\n",
        -:  750:                    code);
        -:  751:            break;
        -:  752:        }
        -:  753:        fputc('\n', outputFile);
        -:  754:        PrintCallstack(outputFile, ex);
        -:  755:        fflush(outputFile);
        -:  756:        return EXCEPTION_EXECUTE_HANDLER;
        -:  757:    }
        -:  758:}
        -:  759:#endif
        -:  760:
        -:  761:/**
        -:  762: * Signal/SEH handling
        -:  763: * Has to be clean for using with SEH on windows, i.e. no construction of C++ object instances is allowed!
        -:  764: * TODO Check for multi-threading issues!
        -:  765: *
        -:  766: */
function _ZN16CppCheckExecutor13check_wrapperER8CppCheckiPKPKc called 0 returned 0% blocks executed 0%
    #####:  767:int CppCheckExecutor::check_wrapper(CppCheck& cppcheck, int argc, const char* const argv[])
        -:  768:{
        -:  769:#ifdef USE_WINDOWS_SEH
        -:  770:    FILE *outputFile = stdout;
        -:  771:    __try {
        -:  772:        return check_internal(cppcheck, argc, argv);
        -:  773:    } __except (filterException(GetExceptionCode(), GetExceptionInformation())) {
        -:  774:        // reporting to stdout may not be helpful within a GUI application...
        -:  775:        fputs("Please report this to the cppcheck developers!\n", outputFile);
        -:  776:        return -1;
        -:  777:    }
        -:  778:#elif defined(USE_UNIX_SIGNAL_HANDLING)
        -:  779:    // determine stack vs. heap
        -:  780:    char stackVariable;
    #####:  781:    char *heapVariable=(char*)malloc(1);
    #####:  782:    bStackBelowHeap = &stackVariable < heapVariable;
    #####:  783:    free(heapVariable);
        -:  784:
        -:  785:    // set up alternative stack for signal handler
        -:  786:    stack_t segv_stack;
    #####:  787:    segv_stack.ss_sp = mytstack;
    #####:  788:    segv_stack.ss_flags = 0;
    #####:  789:    segv_stack.ss_size = MYSTACKSIZE;
    #####:  790:    sigaltstack(&segv_stack, nullptr);
call    0 never executed
        -:  791:
        -:  792:    // install signal handler
        -:  793:    struct sigaction act;
    #####:  794:    memset(&act, 0, sizeof(act));
    #####:  795:    act.sa_flags=SA_SIGINFO|SA_ONSTACK;
    #####:  796:    act.sa_sigaction=CppcheckSignalHandler;
    #####:  797:    for (std::map<int, std::string>::const_iterator sig=listofsignals.begin(); sig!=listofsignals.end(); ++sig) {
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
call    7 never executed
    #####:  798:        sigaction(sig->first, &act, nullptr);
call    0 never executed
call    1 never executed
        -:  799:    }
    #####:  800:    return check_internal(cppcheck, argc, argv);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  801:#else
        -:  802:    return check_internal(cppcheck, argc, argv);
        -:  803:#endif
        -:  804:}
        -:  805:
        -:  806:/*
        -:  807: * That is a method which gets called from check_wrapper
        -:  808: * */
function _ZN16CppCheckExecutor14check_internalER8CppCheckiPKPKc called 0 returned 0% blocks executed 0%
    #####:  809:int CppCheckExecutor::check_internal(CppCheck& cppcheck, int /*argc*/, const char* const argv[])
        -:  810:{
    #####:  811:    Settings& settings = cppcheck.settings();
call    0 never executed
    #####:  812:    mSettings = &settings;
    #####:  813:    const bool std = tryLoadLibrary(settings.library, argv[0], "std.cfg");
call    0 never executed
        -:  814:
    #####:  815:    for (const std::string &lib : settings.libraries) {
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
branch  8 never executed
branch  9 never executed
call   10 never executed
branch 11 never executed
branch 12 never executed
call   13 never executed
call   14 never executed
call   15 never executed
call   16 never executed
    #####:  816:        if (!tryLoadLibrary(settings.library, argv[0], lib.c_str())) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  817:            const std::string msg("Failed to load the library " + lib);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
    #####:  818:            const std::list<ErrorLogger::ErrorMessage::FileLocation> callstack;
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  819:            ErrorLogger::ErrorMessage errmsg(callstack, emptyString, Severity::information, msg, "failedToLoadCfg", false);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
    #####:  820:            reportErr(errmsg);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  821:            return EXIT_FAILURE;
        -:  822:        }
        -:  823:    }
        -:  824:
    #####:  825:    bool posix = true;
    #####:  826:    if (settings.posix())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  827:        posix = tryLoadLibrary(settings.library, argv[0], "posix.cfg");
call    0 never executed
    #####:  828:    bool windows = true;
    #####:  829:    if (settings.isWindowsPlatform())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  830:        windows = tryLoadLibrary(settings.library, argv[0], "windows.cfg");
call    0 never executed
        -:  831:
    #####:  832:    if (!std || !posix || !windows) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  833:        const std::list<ErrorLogger::ErrorMessage::FileLocation> callstack;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  834:        const std::string msg("Failed to load " + std::string(!std ? "std.cfg" : !posix ? "posix.cfg" : "windows.cfg") + ". Your Cppcheck installation is broken, please re-install.");
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
call    8 never executed
branch  9 never executed
branch 10 never executed
call   11 never executed
branch 12 never executed
branch 13 never executed
call   14 never executed
call   15 never executed
call   16 never executed
call   17 never executed
call   18 never executed
call   19 never executed
call   20 never executed
call   21 never executed
        -:  835:#ifdef FILESDIR
        -:  836:        const std::string details("The Cppcheck binary was compiled with FILESDIR set to \""
        -:  837:                                  FILESDIR "\" and will therefore search for "
    #####:  838:                                  "std.cfg in " FILESDIR "/cfg.");
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
        -:  839:#else
        -:  840:        const std::string cfgfolder(Path::fromNativeSeparators(Path::getPathFromFilename(argv[0])) + "cfg");
        -:  841:        const std::string details("The Cppcheck binary was compiled without FILESDIR set. Either the "
        -:  842:                                  "std.cfg should be available in " + cfgfolder + " or the FILESDIR "
        -:  843:                                  "should be configured.");
        -:  844:#endif
    #####:  845:        ErrorLogger::ErrorMessage errmsg(callstack, emptyString, Severity::information, msg+" "+details, "failedToLoadCfg", false);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
branch  8 never executed
branch  9 never executed
call   10 never executed
branch 11 never executed
branch 12 never executed
call   13 never executed
call   14 never executed
call   15 never executed
call   16 never executed
call   17 never executed
call   18 never executed
call   19 never executed
call   20 never executed
call   21 never executed
    #####:  846:        reportErr(errmsg);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  847:        return EXIT_FAILURE;
        -:  848:    }
        -:  849:
    #####:  850:    if (settings.reportProgress)
branch  0 never executed
branch  1 never executed
    #####:  851:        mLatestProgressOutputTime = std::time(nullptr);
call    0 never executed
        -:  852:
    #####:  853:    if (!settings.outputFile.empty()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  854:        mErrorOutput = new std::ofstream(settings.outputFile);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
        -:  855:    }
        -:  856:
    #####:  857:    if (settings.xml) {
branch  0 never executed
branch  1 never executed
    #####:  858:        reportErr(ErrorLogger::ErrorMessage::getXMLHeader());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
        -:  859:    }
        -:  860:
    #####:  861:    if (!settings.buildDir.empty()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  862:        std::list<std::string> fileNames;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  863:        for (std::map<std::string, std::size_t>::const_iterator i = mFiles.begin(); i != mFiles.end(); ++i)
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
    #####:  864:            fileNames.push_back(i->first);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  865:        AnalyzerInformation::writeFilesTxt(settings.buildDir, fileNames, settings.project.fileSettings);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  866:    }
        -:  867:
    #####:  868:    unsigned int returnValue = 0;
    #####:  869:    if (settings.jobs == 1) {
branch  0 never executed
branch  1 never executed
        -:  870:        // Single process
    #####:  871:        settings.jointSuppressionReport = true;
        -:  872:
    #####:  873:        std::size_t totalfilesize = 0;
    #####:  874:        for (std::map<std::string, std::size_t>::const_iterator i = mFiles.begin(); i != mFiles.end(); ++i) {
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
call    8 never executed
call    9 never executed
    #####:  875:            totalfilesize += i->second;
call    0 never executed
        -:  876:        }
        -:  877:
    #####:  878:        std::size_t processedsize = 0;
    #####:  879:        unsigned int c = 0;
    #####:  880:        if (settings.project.fileSettings.empty()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  881:            for (std::map<std::string, std::size_t>::const_iterator i = mFiles.begin(); i != mFiles.end(); ++i) {
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
    #####:  882:                if (!mSettings->library.markupFile(i->first)
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  883:                    || !mSettings->library.processMarkupAfterCode(i->first)) {
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:  884:                    returnValue += cppcheck.check(i->first);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  885:                    processedsize += i->second;
call    0 never executed
    #####:  886:                    if (!settings.quiet)
branch  0 never executed
branch  1 never executed
    #####:  887:                        reportStatus(c + 1, mFiles.size(), processedsize, totalfilesize);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  888:                    c++;
        -:  889:                }
        -:  890:            }
        -:  891:        } else {
        -:  892:
        -:  893:            // filesettings
    #####:  894:            c = 0;
    #####:  895:            for (const ImportProject::FileSettings &fs : settings.project.fileSettings) {
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
    #####:  896:                returnValue += cppcheck.check(fs);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  897:                ++c;
    #####:  898:                if (!settings.quiet)
branch  0 never executed
branch  1 never executed
    #####:  899:                    reportStatus(c, settings.project.fileSettings.size(), c, settings.project.fileSettings.size());
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  900:            }
        -:  901:        }
        -:  902:
        -:  903:        // second loop to parse all markup files which may not work until all
        -:  904:        // c/cpp files have been parsed and checked
    #####:  905:        for (std::map<std::string, std::size_t>::const_iterator i = mFiles.begin(); i != mFiles.end(); ++i) {
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
    #####:  906:            if (mSettings->library.markupFile(i->first) && mSettings->library.processMarkupAfterCode(i->first)) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
call    7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
    #####:  907:                returnValue += cppcheck.check(i->first);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  908:                processedsize += i->second;
call    0 never executed
    #####:  909:                if (!settings.quiet)
branch  0 never executed
branch  1 never executed
    #####:  910:                    reportStatus(c + 1, mFiles.size(), processedsize, totalfilesize);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  911:                c++;
        -:  912:            }
        -:  913:        }
    #####:  914:        if (cppcheck.analyseWholeProgram())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  915:            returnValue++;
    #####:  916:    } else if (!ThreadExecutor::isEnabled()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  917:        std::cout << "No thread support yet implemented for this platform." << std::endl;
call    0 never executed
call    1 never executed
        -:  918:    } else {
        -:  919:        // Multiple processes
    #####:  920:        ThreadExecutor executor(mFiles, settings, *this);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####:  921:        returnValue = executor.check();
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  922:    }
        -:  923:
    #####:  924:    cppcheck.analyseWholeProgram(mSettings->buildDir, mFiles);
call    0 never executed
        -:  925:
    #####:  926:    if (settings.isEnabled(Settings::INFORMATION) || settings.checkConfiguration) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:  927:        const bool enableUnusedFunctionCheck = cppcheck.isUnusedFunctionCheckEnabled();
call    0 never executed
        -:  928:
    #####:  929:        if (settings.jointSuppressionReport) {
branch  0 never executed
branch  1 never executed
    #####:  930:            for (std::map<std::string, std::size_t>::const_iterator i = mFiles.begin(); i != mFiles.end(); ++i) {
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
    #####:  931:                const bool err = reportUnmatchedSuppressions(settings.nomsg.getUnmatchedLocalSuppressions(i->first, enableUnusedFunctionCheck));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
call    8 never executed
    #####:  932:                if (err && returnValue == 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  933:                    returnValue = settings.exitCode;
        -:  934:            }
        -:  935:        }
        -:  936:
    #####:  937:        const bool err = reportUnmatchedSuppressions(settings.nomsg.getUnmatchedGlobalSuppressions(enableUnusedFunctionCheck));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
    #####:  938:        if (err && returnValue == 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  939:            returnValue = settings.exitCode;
        -:  940:    }
        -:  941:
    #####:  942:    if (!settings.checkConfiguration) {
branch  0 never executed
branch  1 never executed
    #####:  943:        cppcheck.tooManyConfigsError("",0U);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
call   12 never executed
        -:  944:
    #####:  945:        if (settings.isEnabled(Settings::MISSING_INCLUDE) && (Preprocessor::missingIncludeFlag || Preprocessor::missingSystemIncludeFlag)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
    #####:  946:            const std::list<ErrorLogger::ErrorMessage::FileLocation> callStack;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  947:            ErrorLogger::ErrorMessage msg(callStack,
        -:  948:                                          emptyString,
        -:  949:                                          Severity::information,
        -:  950:                                          "Cppcheck cannot find all the include files (use --check-config for details)\n"
        -:  951:                                          "Cppcheck cannot find all the include files. Cppcheck can check the code without the "
        -:  952:                                          "include files found. But the results will probably be more accurate if all the include "
        -:  953:                                          "files are found. Please check your project's include directories and add all of them "
        -:  954:                                          "as include directories for Cppcheck. To see what files Cppcheck cannot find use "
        -:  955:                                          "--check-config.",
        -:  956:                                          Preprocessor::missingIncludeFlag ? "missingInclude" : "missingIncludeSystem",
    #####:  957:                                          false);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
call    7 never executed
branch  8 never executed
branch  9 never executed
call   10 never executed
branch 11 never executed
branch 12 never executed
call   13 never executed
call   14 never executed
call   15 never executed
call   16 never executed
call   17 never executed
call   18 never executed
call   19 never executed
call   20 never executed
call   21 never executed
    #####:  958:            reportInfo(msg);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  959:        }
        -:  960:    }
        -:  961:
    #####:  962:    if (settings.xml) {
branch  0 never executed
branch  1 never executed
    #####:  963:        reportErr(ErrorLogger::ErrorMessage::getXMLFooter());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
        -:  964:    }
        -:  965:
    #####:  966:    mSettings = nullptr;
    #####:  967:    if (returnValue)
branch  0 never executed
branch  1 never executed
    #####:  968:        return settings.exitCode;
    #####:  969:    return 0;
call    0 never executed
        -:  970:}
        -:  971:
        -:  972:#ifdef _WIN32
        -:  973:// fix trac ticket #439 'Cppcheck reports wrong filename for filenames containing 8-bit ASCII'
        -:  974:static inline std::string ansiToOEM(const std::string &msg, bool doConvert)
        -:  975:{
        -:  976:    if (doConvert) {
        -:  977:        const unsigned msglength = msg.length();
        -:  978:        // convert ANSI strings to OEM strings in two steps
        -:  979:        std::vector<WCHAR> wcContainer(msglength);
        -:  980:        std::string result(msglength, '\0');
        -:  981:
        -:  982:        // ansi code page characters to wide characters
        -:  983:        MultiByteToWideChar(CP_ACP, 0, msg.data(), msglength, wcContainer.data(), msglength);
        -:  984:        // wide characters to oem codepage characters
        -:  985:        WideCharToMultiByte(CP_OEMCP, 0, wcContainer.data(), msglength, const_cast<char *>(result.data()), msglength, nullptr, nullptr);
        -:  986:
        -:  987:        return result; // hope for return value optimization
        -:  988:    }
        -:  989:    return msg;
        -:  990:}
        -:  991:#else
        -:  992:// no performance regression on non-windows systems
        -:  993:#define ansiToOEM(msg, doConvert) (msg)
        -:  994:#endif
        -:  995:
function _ZN16CppCheckExecutor9reportErrERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 0 returned 0% blocks executed 0%
    #####:  996:void CppCheckExecutor::reportErr(const std::string &errmsg)
        -:  997:{
        -:  998:    // Alert only about unique errors
    #####:  999:    if (mShownErrors.find(errmsg) != mShownErrors.end())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
call    9 never executed
    #####: 1000:        return;
        -: 1001:
    #####: 1002:    mShownErrors.insert(errmsg);
call    0 never executed
call    1 never executed
    #####: 1003:    if (mErrorOutput)
branch  0 never executed
branch  1 never executed
    #####: 1004:        *mErrorOutput << errmsg << std::endl;
call    0 never executed
call    1 never executed
        -: 1005:    else {
    #####: 1006:        std::cerr << ansiToOEM(errmsg, (mSettings == nullptr) ? true : !mSettings->xml) << std::endl;
call    0 never executed
call    1 never executed
        -: 1007:    }
        -: 1008:}
        -: 1009:
function _ZN16CppCheckExecutor9reportOutERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 0 returned 0% blocks executed 0%
    #####: 1010:void CppCheckExecutor::reportOut(const std::string &outmsg)
        -: 1011:{
    #####: 1012:    std::cout << ansiToOEM(outmsg, true) << std::endl;
call    0 never executed
call    1 never executed
    #####: 1013:}
        -: 1014:
function _ZN16CppCheckExecutor14reportProgressERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEPKcm called 0 returned 0% blocks executed 0%
    #####: 1015:void CppCheckExecutor::reportProgress(const std::string &filename, const char stage[], const std::size_t value)
        -: 1016:{
        -: 1017:    (void)filename;
        -: 1018:
    #####: 1019:    if (!mLatestProgressOutputTime)
branch  0 never executed
branch  1 never executed
    #####: 1020:        return;
        -: 1021:
        -: 1022:    // Report progress messages every 10 seconds
    #####: 1023:    const std::time_t currentTime = std::time(nullptr);
call    0 never executed
    #####: 1024:    if (currentTime >= (mLatestProgressOutputTime + 10)) {
branch  0 never executed
branch  1 never executed
    #####: 1025:        mLatestProgressOutputTime = currentTime;
        -: 1026:
        -: 1027:        // format a progress message
    #####: 1028:        std::ostringstream ostr;
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
        -: 1029:        ostr << "progress: "
        -: 1030:             << stage
    #####: 1031:             << ' ' << value << '%';
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
call    9 never executed
branch 10 never executed
branch 11 never executed
call   12 never executed
branch 13 never executed
branch 14 never executed
        -: 1032:
        -: 1033:        // Report progress message
    #####: 1034:        reportOut(ostr.str());
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
call    7 never executed
        -: 1035:    }
        -: 1036:}
        -: 1037:
function _ZN16CppCheckExecutor10reportInfoERKN11ErrorLogger12ErrorMessageE called 0 returned 0% blocks executed 0%
    #####: 1038:void CppCheckExecutor::reportInfo(const ErrorLogger::ErrorMessage &msg)
        -: 1039:{
    #####: 1040:    reportErr(msg);
call    0 never executed
    #####: 1041:}
        -: 1042:
function _ZN16CppCheckExecutor12reportStatusEmmmm called 0 returned 0% blocks executed 0%
    #####: 1043:void CppCheckExecutor::reportStatus(std::size_t fileindex, std::size_t filecount, std::size_t sizedone, std::size_t sizetotal)
        -: 1044:{
    #####: 1045:    if (filecount > 1) {
branch  0 never executed
branch  1 never executed
    #####: 1046:        std::ostringstream oss;
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
    #####: 1047:        const long percentDone = (sizetotal > 0) ? static_cast<long>(static_cast<long double>(sizedone) / sizetotal * 100) : 0;
branch  0 never executed
branch  1 never executed
    #####: 1048:        oss << fileindex << '/' << filecount
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
    #####: 1049:            << " files checked " << percentDone
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1050:            << "% done";
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1051:        std::cout << oss.str() << std::endl;
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
call    9 never executed
call   10 never executed
        -: 1052:    }
    #####: 1053:}
        -: 1054:
function _ZN16CppCheckExecutor9reportErrERKN11ErrorLogger12ErrorMessageE called 0 returned 0% blocks executed 0%
    #####: 1055:void CppCheckExecutor::reportErr(const ErrorLogger::ErrorMessage &msg)
        -: 1056:{
    #####: 1057:    if (mShowAllErrors) {
branch  0 never executed
branch  1 never executed
    #####: 1058:        reportOut(msg.toXML());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
    #####: 1059:    } else if (mSettings->xml) {
branch  0 never executed
branch  1 never executed
    #####: 1060:        reportErr(msg.toXML());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
        -: 1061:    } else {
    #####: 1062:        reportErr(msg.toString(mSettings->verbose, mSettings->templateFormat, mSettings->templateLocation));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
        -: 1063:    }
    #####: 1064:}
        -: 1065:
function _ZN16CppCheckExecutor18setExceptionOutputEP8_IO_FILE called 0 returned 0% blocks executed 0%
    #####: 1066:void CppCheckExecutor::setExceptionOutput(FILE* exceptionOutput)
        -: 1067:{
    #####: 1068:    mExceptionOutput = exceptionOutput;
    #####: 1069:}
        -: 1070:
function _ZN16CppCheckExecutor18getExceptionOutputEv called 0 returned 0% blocks executed 0%
    #####: 1071:FILE* CppCheckExecutor::getExceptionOutput()
        -: 1072:{
    #####: 1073:    return mExceptionOutput;
        -: 1074:}
        -: 1075:
function _ZN16CppCheckExecutor14tryLoadLibraryER7LibraryPKcS3_ called 0 returned 0% blocks executed 0%
    #####: 1076:bool CppCheckExecutor::tryLoadLibrary(Library& destination, const char* basepath, const char* filename)
        -: 1077:{
    #####: 1078:    const Library::Error err = destination.load(basepath, filename);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
        -: 1079:
    #####: 1080:    if (err.errorcode == Library::UNKNOWN_ELEMENT)
branch  0 never executed
branch  1 never executed
    #####: 1081:        std::cout << "cppcheck: Found unknown elements in configuration file '" << filename << "': " << err.reason << std::endl;
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
call    9 never executed
branch 10 never executed
branch 11 never executed
call   12 never executed
branch 13 never executed
branch 14 never executed
    #####: 1082:    else if (err.errorcode != Library::OK) {
branch  0 never executed
branch  1 never executed
    #####: 1083:        std::string errmsg;
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1084:        switch (err.errorcode) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 1085:        case Library::OK:
    #####: 1086:            break;
    #####: 1087:        case Library::FILE_NOT_FOUND:
    #####: 1088:            errmsg = "File not found";
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1089:            break;
    #####: 1090:        case Library::BAD_XML:
    #####: 1091:            errmsg = "Bad XML";
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1092:            break;
    #####: 1093:        case Library::UNKNOWN_ELEMENT:
    #####: 1094:            errmsg = "Unexpected element";
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1095:            break;
    #####: 1096:        case Library::MISSING_ATTRIBUTE:
    #####: 1097:            errmsg = "Missing attribute";
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1098:            break;
    #####: 1099:        case Library::BAD_ATTRIBUTE_VALUE:
    #####: 1100:            errmsg = "Bad attribute value";
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1101:            break;
    #####: 1102:        case Library::UNSUPPORTED_FORMAT:
    #####: 1103:            errmsg = "File is of unsupported format version";
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1104:            break;
    #####: 1105:        case Library::DUPLICATE_PLATFORM_TYPE:
    #####: 1106:            errmsg = "Duplicate platform type";
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1107:            break;
    #####: 1108:        case Library::PLATFORM_TYPE_REDEFINED:
    #####: 1109:            errmsg = "Platform type redefined";
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1110:            break;
        -: 1111:        }
    #####: 1112:        if (!err.reason.empty())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1113:            errmsg += " '" + err.reason + "'";
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
call   12 never executed
    #####: 1114:        std::cout << "cppcheck: Failed to load library configuration file '" << filename << "'. " << errmsg << std::endl;
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
call    9 never executed
branch 10 never executed
branch 11 never executed
call   12 never executed
branch 13 never executed
branch 14 never executed
    #####: 1115:        return false;
        -: 1116:    }
    #####: 1117:    return true;
function _GLOBAL__sub_I__ZN16CppCheckExecutor16mExceptionOutputE called 1 returned 100% blocks executed 100%
function _Z41__static_initialization_and_destruction_0ii called 1 returned 100% blocks executed 56%
        3: 1118:}
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
