        -:    0:Source:/home/workspace/lib/token.h
        -:    0:Graph:/home/workspace/build/lib/CMakeFiles/lib_objs.dir/valueflow.gcno
        -:    0:Data:/home/workspace/build/lib/CMakeFiles/lib_objs.dir/valueflow.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*
        -:    2: * Cppcheck - A tool for static C/C++ code analysis
        -:    3: * Copyright (C) 2007-2019 Cppcheck team.
        -:    4: *
        -:    5: * This program is free software: you can redistribute it and/or modify
        -:    6: * it under the terms of the GNU General Public License as published by
        -:    7: * the Free Software Foundation, either version 3 of the License, or
        -:    8: * (at your option) any later version.
        -:    9: *
        -:   10: * This program is distributed in the hope that it will be useful,
        -:   11: * but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   12: * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   13: * GNU General Public License for more details.
        -:   14: *
        -:   15: * You should have received a copy of the GNU General Public License
        -:   16: * along with this program.  If not, see <http://www.gnu.org/licenses/>.
        -:   17: */
        -:   18:
        -:   19://---------------------------------------------------------------------------
        -:   20:#ifndef tokenH
        -:   21:#define tokenH
        -:   22://---------------------------------------------------------------------------
        -:   23:
        -:   24:#include "config.h"
        -:   25:#include "mathlib.h"
        -:   26:#include "valueflow.h"
        -:   27:#include "templatesimplifier.h"
        -:   28:#include "utils.h"
        -:   29:
        -:   30:#include <algorithm>
        -:   31:#include <cstddef>
        -:   32:#include <functional>
        -:   33:#include <list>
        -:   34:#include <memory>
        -:   35:#include <ostream>
        -:   36:#include <string>
        -:   37:#include <vector>
        -:   38:
        -:   39:class Enumerator;
        -:   40:class Function;
        -:   41:class Scope;
        -:   42:class Settings;
        -:   43:class Type;
        -:   44:class ValueType;
        -:   45:class Variable;
        -:   46:
        -:   47:/**
        -:   48: * @brief This struct stores pointers to the front and back tokens of the list this token is in.
        -:   49: */
        -:   50:struct TokensFrontBack {
        -:   51:    Token *front;
        -:   52:    Token *back;
        -:   53:};
        -:   54:
        -:   55:struct ScopeInfo2 {
        -:   56:    ScopeInfo2(const std::string &name_, const Token *bodyEnd_, const std::set<std::string> &usingNamespaces_ = std::set<std::string>()) : name(name_), bodyEnd(bodyEnd_), usingNamespaces(usingNamespaces_) {}
        -:   57:    std::string name;
        -:   58:    const Token * const bodyEnd;
        -:   59:    std::set<std::string> usingNamespaces;
        -:   60:};
        -:   61:
        -:   62:struct TokenImpl {
        -:   63:    nonneg int mVarId;
        -:   64:    nonneg int mFileIndex;
        -:   65:    nonneg int mLineNumber;
        -:   66:    nonneg int mColumn;
        -:   67:
        -:   68:    // AST..
        -:   69:    Token *mAstOperand1;
        -:   70:    Token *mAstOperand2;
        -:   71:    Token *mAstParent;
        -:   72:
        -:   73:    // symbol database information
        -:   74:    const Scope *mScope;
        -:   75:    union {
        -:   76:        const Function *mFunction;
        -:   77:        const Variable *mVariable;
        -:   78:        const ::Type* mType;
        -:   79:        const Enumerator *mEnumerator;
        -:   80:    };
        -:   81:
        -:   82:    /**
        -:   83:     * A value from 0-100 that provides a rough idea about where in the token
        -:   84:     * list this token is located.
        -:   85:     */
        -:   86:    nonneg int mProgressValue;
        -:   87:
        -:   88:    /**
        -:   89:     * Token index. Position in token list
        -:   90:     */
        -:   91:    nonneg int mIndex;
        -:   92:
        -:   93:    // original name like size_t
        -:   94:    std::string* mOriginalName;
        -:   95:
        -:   96:    // ValueType
        -:   97:    ValueType *mValueType;
        -:   98:
        -:   99:    // ValueFlow
        -:  100:    std::list<ValueFlow::Value>* mValues;
        -:  101:    static const std::list<ValueFlow::Value> mEmptyValueList;
        -:  102:
        -:  103:    /** Bitfield bit count. */
        -:  104:    unsigned char mBits;
        -:  105:
        -:  106:    // Pointer to a template in the template simplifier
        -:  107:    std::set<TemplateSimplifier::TokenAndName*> mTemplateSimplifierPointers;
        -:  108:
        -:  109:    // Pointer to the object representing this token's scope
        -:  110:    std::shared_ptr<ScopeInfo2> mScopeInfo;
        -:  111:
        -:  112:    // __cppcheck_in_range__
        -:  113:    struct CppcheckAttributes {
        -:  114:        enum Type {LOW,HIGH} type;
        -:  115:        MathLib::bigint value;
        -:  116:        struct CppcheckAttributes *next;
        -:  117:    };
        -:  118:    struct CppcheckAttributes *mCppcheckAttributes;
        -:  119:
        -:  120:    // For memoization, to speed up parsing of huge arrays #8897
        -:  121:    enum class Cpp11init {UNKNOWN, CPP11INIT, NOINIT} mCpp11init;
        -:  122:
        -:  123:    void setCppcheckAttribute(CppcheckAttributes::Type type, MathLib::bigint value);
        -:  124:    bool getCppcheckAttribute(CppcheckAttributes::Type type, MathLib::bigint *value) const;
        -:  125:
        -:  126:    TokenImpl()
        -:  127:        : mVarId(0)
        -:  128:        , mFileIndex(0)
        -:  129:        , mLineNumber(0)
        -:  130:        , mColumn(0)
        -:  131:        , mAstOperand1(nullptr)
        -:  132:        , mAstOperand2(nullptr)
        -:  133:        , mAstParent(nullptr)
        -:  134:        , mScope(nullptr)
        -:  135:        , mFunction(nullptr) // Initialize whole union
        -:  136:        , mProgressValue(0)
        -:  137:        , mIndex(0)
        -:  138:        , mOriginalName(nullptr)
        -:  139:        , mValueType(nullptr)
        -:  140:        , mValues(nullptr)
        -:  141:        , mBits(0)
        -:  142:        , mTemplateSimplifierPointers()
        -:  143:        , mScopeInfo(nullptr)
        -:  144:        , mCppcheckAttributes(nullptr)
        -:  145:        , mCpp11init(Cpp11init::UNKNOWN)
        -:  146:    {}
        -:  147:
        -:  148:    ~TokenImpl();
        -:  149:};
        -:  150:
        -:  151:/// @addtogroup Core
        -:  152:/// @{
        -:  153:
        -:  154:/**
        -:  155: * @brief The token list that the TokenList generates is a linked-list of this class.
        -:  156: *
        -:  157: * Tokens are stored as strings. The "if", "while", etc are stored in plain text.
        -:  158: * The reason the Token class is needed (instead of using the string class) is that some extra functionality is also needed for tokens:
        -:  159: *  - location of the token is stored (fileIndex, linenr, column)
        -:  160: *  - functions for classifying the token (isName, isNumber, isBoolean, isStandardType)
        -:  161: *
        -:  162: * The Token class also has other functions for management of token list, matching tokens, etc.
        -:  163: */
        -:  164:class CPPCHECKLIB Token {
        -:  165:private:
        -:  166:    TokensFrontBack* mTokensFrontBack;
        -:  167:
        -:  168:    // Not implemented..
        -:  169:    Token(const Token &);
        -:  170:    Token operator=(const Token &);
        -:  171:
        -:  172:public:
        -:  173:    enum Type {
        -:  174:        eVariable, eType, eFunction, eKeyword, eName, // Names: Variable (varId), Type (typeId, later), Function (FuncId, later), Language keyword, Name (unknown identifier)
        -:  175:        eNumber, eString, eChar, eBoolean, eLiteral, eEnumerator, // Literals: Number, String, Character, Boolean, User defined literal (C++11), Enumerator
        -:  176:        eArithmeticalOp, eComparisonOp, eAssignmentOp, eLogicalOp, eBitOp, eIncDecOp, eExtendedOp, // Operators: Arithmetical, Comparison, Assignment, Logical, Bitwise, ++/--, Extended
        -:  177:        eBracket, // {, }, <, >: < and > only if link() is set. Otherwise they are comparison operators.
        -:  178:        eLambda, // A function without a name
        -:  179:        eEllipsis, // "..."
        -:  180:        eOther,
        -:  181:        eNone
        -:  182:    };
        -:  183:
        -:  184:    explicit Token(TokensFrontBack *tokensFrontBack = nullptr);
        -:  185:    ~Token();
        -:  186:
        -:  187:    template<typename T>
function _ZN5Token3strINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEEvOT_ called 0 returned 0% blocks executed 0%
    #####:  188:    void str(T&& s) {
    #####:  189:        mStr = s;
call    0 never executed
    #####:  190:        mImpl->mVarId = 0;
        -:  191:
    #####:  192:        update_property_info();
call    0 never executed
    #####:  193:    }
        -:  194:
        -:  195:    /**
        -:  196:     * Concatenate two (quoted) strings. Automatically cuts of the last/first character.
        -:  197:     * Example: "hello ""world" -> "hello world". Used by the token simplifier.
        -:  198:     */
        -:  199:    void concatStr(std::string const& b);
        -:  200:
function _ZNK5Token3strB5cxx11Ev called 0 returned 0% blocks executed 0%
    #####:  201:    const std::string &str() const {
    #####:  202:        return mStr;
        -:  203:    }
        -:  204:
        -:  205:    /**
        -:  206:     * Unlink and delete the next 'count' tokens.
        -:  207:     */
        -:  208:    void deleteNext(nonneg int count = 1);
        -:  209:
        -:  210:    /**
        -:  211:    * Unlink and delete the previous 'count' tokens.
        -:  212:    */
        -:  213:    void deletePrevious(nonneg int count = 1);
        -:  214:
        -:  215:    /**
        -:  216:     * Swap the contents of this token with the next token.
        -:  217:     */
        -:  218:    void swapWithNext();
        -:  219:
        -:  220:    /**
        -:  221:     * @return token in given index, related to this token.
        -:  222:     * For example index 1 would return next token, and 2
        -:  223:     * would return next from that one.
        -:  224:     */
        -:  225:    const Token *tokAt(int index) const;
function _ZN5Token5tokAtEi called 0 returned 0% blocks executed 0%
    #####:  226:    Token *tokAt(int index) {
    #####:  227:        return const_cast<Token *>(const_cast<const Token *>(this)->tokAt(index));
call    0 never executed
        -:  228:    }
        -:  229:
        -:  230:    /**
        -:  231:     * @return the link to the token in given index, related to this token.
        -:  232:     * For example index 1 would return the link to next token.
        -:  233:     */
        -:  234:    const Token *linkAt(int index) const;
function _ZN5Token6linkAtEi called 0 returned 0% blocks executed 0%
    #####:  235:    Token *linkAt(int index) {
    #####:  236:        return const_cast<Token *>(const_cast<const Token *>(this)->linkAt(index));
call    0 never executed
        -:  237:    }
        -:  238:
        -:  239:    /**
        -:  240:     * @return String of the token in given index, related to this token.
        -:  241:     * If that token does not exist, an empty string is being returned.
        -:  242:     */
        -:  243:    const std::string &strAt(int index) const;
        -:  244:
        -:  245:    /**
        -:  246:     * Match given token (or list of tokens) to a pattern list.
        -:  247:     *
        -:  248:     * Possible patterns
        -:  249:     * "someRandomText" If token contains "someRandomText".
        -:  250:     * @note Use Match() if you want to use flags in patterns
        -:  251:     *
        -:  252:     * The patterns can be also combined to compare to multiple tokens at once
        -:  253:     * by separating tokens with a space, e.g.
        -:  254:     * ") void {" will return true if first token is ')' next token
        -:  255:     * is "void" and token after that is '{'. If even one of the tokens does
        -:  256:     * not match its pattern, false is returned.
        -:  257:     *
        -:  258:     * @param tok List of tokens to be compared to the pattern
        -:  259:     * @param pattern The pattern against which the tokens are compared,
        -:  260:     * e.g. "const" or ") void {".
        -:  261:     * @return true if given token matches with given pattern
        -:  262:     *         false if given token does not match with given pattern
        -:  263:     */
        -:  264:    static bool simpleMatch(const Token *tok, const char pattern[]);
        -:  265:
        -:  266:    /**
        -:  267:     * Match given token (or list of tokens) to a pattern list.
        -:  268:     *
        -:  269:     * Possible patterns
        -:  270:     * - "%any%" any token
        -:  271:     * - "%assign%" a assignment operand
        -:  272:     * - "%bool%" true or false
        -:  273:     * - "%char%" Any token enclosed in &apos;-character.
        -:  274:     * - "%comp%" Any token such that isComparisonOp() returns true.
        -:  275:     * - "%cop%" Any token such that isConstOp() returns true.
        -:  276:     * - "%name%" any token which is a name, variable or type e.g. "hello" or "int"
        -:  277:     * - "%num%" Any numeric token, e.g. "23"
        -:  278:     * - "%op%" Any token such that isOp() returns true.
        -:  279:     * - "%or%" A bitwise-or operator '|'
        -:  280:     * - "%oror%" A logical-or operator '||'
        -:  281:     * - "%type%" Anything that can be a variable type, e.g. "int", but not "delete".
        -:  282:     * - "%str%" Any token starting with &quot;-character (C-string).
        -:  283:     * - "%var%" Match with token with varId > 0
        -:  284:     * - "%varid%" Match with parameter varid
        -:  285:     * - "[abc]" Any of the characters 'a' or 'b' or 'c'
        -:  286:     * - "int|void|char" Any of the strings, int, void or char
        -:  287:     * - "int|void|char|" Any of the strings, int, void or char or empty string
        -:  288:     * - "!!else" No tokens or any token that is not "else".
        -:  289:     * - "someRandomText" If token contains "someRandomText".
        -:  290:     *
        -:  291:     * multi-compare patterns such as "int|void|char" can contain %%or%, %%oror% and %%op%
        -:  292:     * it is recommended to put such an %%cmd% as the first pattern.
        -:  293:     * For example: "%var%|%num%|)" means yes to a variable, a number or ')'.
        -:  294:     *
        -:  295:     * The patterns can be also combined to compare to multiple tokens at once
        -:  296:     * by separating tokens with a space, e.g.
        -:  297:     * ") const|void {" will return true if first token is ')' next token is either
        -:  298:     * "const" or "void" and token after that is '{'. If even one of the tokens does not
        -:  299:     * match its pattern, false is returned.
        -:  300:     *
        -:  301:     * @param tok List of tokens to be compared to the pattern
        -:  302:     * @param pattern The pattern against which the tokens are compared,
        -:  303:     * e.g. "const" or ") const|volatile| {".
        -:  304:     * @param varid if %%varid% is given in the pattern the Token::varId
        -:  305:     * will be matched against this argument
        -:  306:     * @return true if given token matches with given pattern
        -:  307:     *         false if given token does not match with given pattern
        -:  308:     */
        -:  309:    static bool Match(const Token *tok, const char pattern[], nonneg int varid = 0);
        -:  310:
        -:  311:    /**
        -:  312:     * @return length of C-string.
        -:  313:     *
        -:  314:     * Should be called for %%str%% tokens only.
        -:  315:     *
        -:  316:     * @param tok token with C-string
        -:  317:     **/
        -:  318:    static nonneg int getStrLength(const Token *tok);
        -:  319:
        -:  320:    /**
        -:  321:     * @return sizeof of C-string.
        -:  322:     *
        -:  323:     * Should be called for %%str%% tokens only.
        -:  324:     *
        -:  325:     * @param tok token with C-string
        -:  326:     **/
        -:  327:    static nonneg int getStrSize(const Token *tok);
        -:  328:
        -:  329:    /**
        -:  330:     * @return char of C-string at index (possible escaped "\\n")
        -:  331:     *
        -:  332:     * Should be called for %%str%% tokens only.
        -:  333:     *
        -:  334:     * @param tok token with C-string
        -:  335:     * @param index position of character
        -:  336:     **/
        -:  337:    static std::string getCharAt(const Token *tok, MathLib::bigint index);
        -:  338:
function _ZNK5Token9valueTypeEv called 0 returned 0% blocks executed 0%
    #####:  339:    const ValueType *valueType() const {
    #####:  340:        return mImpl->mValueType;
        -:  341:    }
        -:  342:    void setValueType(ValueType *vt);
        -:  343:
        -:  344:    const ValueType *argumentType() const {
        -:  345:        const Token *top = this;
        -:  346:        while (top && !Token::Match(top->astParent(), ",|("))
        -:  347:            top = top->astParent();
        -:  348:        return top ? top->mImpl->mValueType : nullptr;
        -:  349:    }
        -:  350:
function _ZNK5Token7tokTypeEv called 0 returned 0% blocks executed 0%
    #####:  351:    Token::Type tokType() const {
    #####:  352:        return mTokType;
        -:  353:    }
        -:  354:    void tokType(Token::Type t) {
        -:  355:        mTokType = t;
        -:  356:
        -:  357:        const bool memoizedIsName = (mTokType == eName || mTokType == eType || mTokType == eVariable ||
        -:  358:                                     mTokType == eFunction || mTokType == eKeyword || mTokType == eBoolean ||
        -:  359:                                     mTokType == eEnumerator); // TODO: "true"/"false" aren't really a name...
        -:  360:        setFlag(fIsName, memoizedIsName);
        -:  361:
        -:  362:        const bool memoizedIsLiteral = (mTokType == eNumber || mTokType == eString || mTokType == eChar ||
        -:  363:                                        mTokType == eBoolean || mTokType == eLiteral || mTokType == eEnumerator);
        -:  364:        setFlag(fIsLiteral, memoizedIsLiteral);
        -:  365:    }
        -:  366:    void isKeyword(const bool kwd) {
        -:  367:        if (kwd)
        -:  368:            tokType(eKeyword);
        -:  369:        else if (mTokType == eKeyword)
        -:  370:            tokType(eName);
        -:  371:    }
        -:  372:    bool isKeyword() const {
        -:  373:        return mTokType == eKeyword;
        -:  374:    }
function _ZNK5Token6isNameEv called 0 returned 0% blocks executed 0%
    #####:  375:    bool isName() const {
    #####:  376:        return getFlag(fIsName);
call    0 never executed
        -:  377:    }
        -:  378:    bool isNameOnly() const {
        -:  379:        return mFlags == fIsName && mTokType == eName;
        -:  380:    }
        -:  381:    bool isUpperCaseName() const;
function _ZNK5Token9isLiteralEv called 0 returned 0% blocks executed 0%
    #####:  382:    bool isLiteral() const {
    #####:  383:        return getFlag(fIsLiteral);
call    0 never executed
        -:  384:    }
function _ZNK5Token8isNumberEv called 0 returned 0% blocks executed 0%
    #####:  385:    bool isNumber() const {
    #####:  386:        return mTokType == eNumber;
        -:  387:    }
        -:  388:    bool isEnumerator() const {
        -:  389:        return mTokType == eEnumerator;
        -:  390:    }
function _ZNK5Token4isOpEv called 0 returned 0% blocks executed 0%
    #####:  391:    bool isOp() const {
    #####:  392:        return (isConstOp() ||
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  393:                isAssignmentOp() ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  394:                mTokType == eIncDecOp);
        -:  395:    }
function _ZNK5Token9isConstOpEv called 0 returned 0% blocks executed 0%
    #####:  396:    bool isConstOp() const {
    #####:  397:        return (isArithmeticalOp() ||
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  398:                mTokType == eLogicalOp ||
branch  0 never executed
branch  1 never executed
    #####:  399:                mTokType == eComparisonOp ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  400:                mTokType == eBitOp);
        -:  401:    }
        -:  402:    bool isExtendedOp() const {
        -:  403:        return isConstOp() ||
        -:  404:               mTokType == eExtendedOp;
        -:  405:    }
function _ZNK5Token16isArithmeticalOpEv called 0 returned 0% blocks executed 0%
    #####:  406:    bool isArithmeticalOp() const {
    #####:  407:        return mTokType == eArithmeticalOp;
        -:  408:    }
function _ZNK5Token14isComparisonOpEv called 0 returned 0% blocks executed 0%
    #####:  409:    bool isComparisonOp() const {
    #####:  410:        return mTokType == eComparisonOp;
        -:  411:    }
function _ZNK5Token14isAssignmentOpEv called 0 returned 0% blocks executed 0%
    #####:  412:    bool isAssignmentOp() const {
    #####:  413:        return mTokType == eAssignmentOp;
        -:  414:    }
        -:  415:    bool isBoolean() const {
        -:  416:        return mTokType == eBoolean;
        -:  417:    }
function _ZNK5Token10isBinaryOpEv called 0 returned 0% blocks executed 0%
    #####:  418:    bool isBinaryOp() const {
    #####:  419:        return astOperand1() != nullptr && astOperand2() != nullptr;
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -:  420:    }
function _ZNK5Token9isUnaryOpERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 0 returned 0% blocks executed 0%
    #####:  421:    bool isUnaryOp(const std::string &s) const {
    #####:  422:        return s == mStr && astOperand1() != nullptr && astOperand2() == nullptr;
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
        -:  423:    }
        -:  424:    bool isUnaryPreOp() const;
        -:  425:
        -:  426:    unsigned int flags() const {
        -:  427:        return mFlags;
        -:  428:    }
        -:  429:    void flags(const unsigned int flags_) {
        -:  430:        mFlags = flags_;
        -:  431:    }
function _ZNK5Token10isUnsignedEv called 0 returned 0% blocks executed 0%
    #####:  432:    bool isUnsigned() const {
    #####:  433:        return getFlag(fIsUnsigned);
call    0 never executed
        -:  434:    }
        -:  435:    void isUnsigned(const bool sign) {
        -:  436:        setFlag(fIsUnsigned, sign);
        -:  437:    }
        -:  438:    bool isSigned() const {
        -:  439:        return getFlag(fIsSigned);
        -:  440:    }
        -:  441:    void isSigned(const bool sign) {
        -:  442:        setFlag(fIsSigned, sign);
        -:  443:    }
        -:  444:    bool isPointerCompare() const {
        -:  445:        return getFlag(fIsPointerCompare);
        -:  446:    }
        -:  447:    void isPointerCompare(const bool b) {
        -:  448:        setFlag(fIsPointerCompare, b);
        -:  449:    }
function _ZNK5Token6isLongEv called 0 returned 0% blocks executed 0%
    #####:  450:    bool isLong() const {
    #####:  451:        return getFlag(fIsLong);
call    0 never executed
        -:  452:    }
        -:  453:    void isLong(bool size) {
        -:  454:        setFlag(fIsLong, size);
        -:  455:    }
function _ZNK5Token14isStandardTypeEv called 0 returned 0% blocks executed 0%
    #####:  456:    bool isStandardType() const {
    #####:  457:        return getFlag(fIsStandardType);
call    0 never executed
        -:  458:    }
        -:  459:    void isStandardType(const bool b) {
        -:  460:        setFlag(fIsStandardType, b);
        -:  461:    }
function _ZNK5Token15isExpandedMacroEv called 0 returned 0% blocks executed 0%
    #####:  462:    bool isExpandedMacro() const {
    #####:  463:        return getFlag(fIsExpandedMacro);
call    0 never executed
        -:  464:    }
        -:  465:    void isExpandedMacro(const bool m) {
        -:  466:        setFlag(fIsExpandedMacro, m);
        -:  467:    }
function _ZNK5Token6isCastEv called 0 returned 0% blocks executed 0%
    #####:  468:    bool isCast() const {
    #####:  469:        return getFlag(fIsCast);
call    0 never executed
        -:  470:    }
        -:  471:    void isCast(bool c) {
        -:  472:        setFlag(fIsCast, c);
        -:  473:    }
        -:  474:    bool isAttributeConstructor() const {
        -:  475:        return getFlag(fIsAttributeConstructor);
        -:  476:    }
        -:  477:    void isAttributeConstructor(const bool ac) {
        -:  478:        setFlag(fIsAttributeConstructor, ac);
        -:  479:    }
        -:  480:    bool isAttributeDestructor() const {
        -:  481:        return getFlag(fIsAttributeDestructor);
        -:  482:    }
        -:  483:    void isAttributeDestructor(const bool value) {
        -:  484:        setFlag(fIsAttributeDestructor, value);
        -:  485:    }
        -:  486:    bool isAttributeUnused() const {
        -:  487:        return getFlag(fIsAttributeUnused);
        -:  488:    }
        -:  489:    void isAttributeUnused(bool unused) {
        -:  490:        setFlag(fIsAttributeUnused, unused);
        -:  491:    }
        -:  492:    bool isAttributeUsed() const {
        -:  493:        return getFlag(fIsAttributeUsed);
        -:  494:    }
        -:  495:    void isAttributeUsed(const bool unused) {
        -:  496:        setFlag(fIsAttributeUsed, unused);
        -:  497:    }
        -:  498:    bool isAttributePure() const {
        -:  499:        return getFlag(fIsAttributePure);
        -:  500:    }
        -:  501:    void isAttributePure(const bool value) {
        -:  502:        setFlag(fIsAttributePure, value);
        -:  503:    }
        -:  504:    bool isAttributeConst() const {
        -:  505:        return getFlag(fIsAttributeConst);
        -:  506:    }
        -:  507:    void isAttributeConst(bool value) {
        -:  508:        setFlag(fIsAttributeConst, value);
        -:  509:    }
        -:  510:    bool isAttributeNoreturn() const {
        -:  511:        return getFlag(fIsAttributeNoreturn);
        -:  512:    }
        -:  513:    void isAttributeNoreturn(const bool value) {
        -:  514:        setFlag(fIsAttributeNoreturn, value);
        -:  515:    }
        -:  516:    bool isAttributeNothrow() const {
        -:  517:        return getFlag(fIsAttributeNothrow);
        -:  518:    }
        -:  519:    void isAttributeNothrow(const bool value) {
        -:  520:        setFlag(fIsAttributeNothrow, value);
        -:  521:    }
        -:  522:    bool isAttributePacked() const {
        -:  523:        return getFlag(fIsAttributePacked);
        -:  524:    }
        -:  525:    void isAttributePacked(const bool value) {
        -:  526:        setFlag(fIsAttributePacked, value);
        -:  527:    }
        -:  528:    bool isAttributeNodiscard() const {
        -:  529:        return getFlag(fIsAttributeNodiscard);
        -:  530:    }
        -:  531:    void isAttributeNodiscard(const bool value) {
        -:  532:        setFlag(fIsAttributeNodiscard, value);
        -:  533:    }
        -:  534:    void setCppcheckAttribute(TokenImpl::CppcheckAttributes::Type type, MathLib::bigint value) {
        -:  535:        mImpl->setCppcheckAttribute(type, value);
        -:  536:    }
function _ZNK5Token20getCppcheckAttributeEN9TokenImpl18CppcheckAttributes4TypeEPx called 228 returned 100% blocks executed 100%
      228:  537:    bool getCppcheckAttribute(TokenImpl::CppcheckAttributes::Type type, MathLib::bigint *value) const {
      228:  538:        return mImpl->getCppcheckAttribute(type, value);
call    0 returned 100%
        -:  539:    }
        -:  540:    bool isControlFlowKeyword() const {
        -:  541:        return getFlag(fIsControlFlowKeyword);
        -:  542:    }
        -:  543:    bool isOperatorKeyword() const {
        -:  544:        return getFlag(fIsOperatorKeyword);
        -:  545:    }
        -:  546:    void isOperatorKeyword(const bool value) {
        -:  547:        setFlag(fIsOperatorKeyword, value);
        -:  548:    }
        -:  549:    bool isComplex() const {
        -:  550:        return getFlag(fIsComplex);
        -:  551:    }
        -:  552:    void isComplex(const bool value) {
        -:  553:        setFlag(fIsComplex, value);
        -:  554:    }
        -:  555:    bool isEnumType() const {
        -:  556:        return getFlag(fIsEnumType);
        -:  557:    }
        -:  558:    void isEnumType(const bool value) {
        -:  559:        setFlag(fIsEnumType, value);
        -:  560:    }
        -:  561:    bool isAtAddress() const {
        -:  562:        return getFlag(fAtAddress);
        -:  563:    }
        -:  564:    void isAtAddress(bool b) {
        -:  565:        setFlag(fAtAddress, b);
        -:  566:    }
function _ZNK5Token15isIncompleteVarEv called 34086 returned 100% blocks executed 100%
    34086:  567:    bool isIncompleteVar() const {
    34086:  568:        return getFlag(fIncompleteVar);
call    0 returned 100%
        -:  569:    }
        -:  570:    void isIncompleteVar(bool b) {
        -:  571:        setFlag(fIncompleteVar, b);
        -:  572:    }
        -:  573:
        -:  574:    bool isConstexpr() const {
        -:  575:        return getFlag(fConstexpr);
        -:  576:    }
        -:  577:    void isConstexpr(bool b) {
        -:  578:        setFlag(fConstexpr, b);
        -:  579:    }
        -:  580:
        -:  581:
        -:  582:    bool isBitfield() const {
        -:  583:        return mImpl->mBits > 0;
        -:  584:    }
        -:  585:    unsigned char bits() const {
        -:  586:        return mImpl->mBits;
        -:  587:    }
        -:  588:    std::set<TemplateSimplifier::TokenAndName*> &templateSimplifierPointers() const {
        -:  589:        return mImpl->mTemplateSimplifierPointers;
        -:  590:    }
        -:  591:    void templateSimplifierPointer(TemplateSimplifier::TokenAndName* tokenAndName) {
        -:  592:        mImpl->mTemplateSimplifierPointers.insert(tokenAndName);
        -:  593:    }
        -:  594:    void setBits(const unsigned char b) {
        -:  595:        mImpl->mBits = b;
        -:  596:    }
        -:  597:
        -:  598:    /**
        -:  599:     * @brief Is current token a template argument?
        -:  600:     *
        -:  601:     * Original code:
        -:  602:     *
        -:  603:     *     template<class C> struct S {
        -:  604:     *         C x;
        -:  605:     *     };
        -:  606:     *     S<int> s;
        -:  607:     *
        -:  608:     * Resulting code:
        -:  609:     *
        -:  610:     *     struct S<int> {
        -:  611:     *         int x ;  // <- "int" is a template argument
        -:  612:     *     }
        -:  613:     *     S<int> s;
        -:  614:     */
function _ZNK5Token13isTemplateArgEv called 0 returned 0% blocks executed 0%
    #####:  615:    bool isTemplateArg() const {
    #####:  616:        return getFlag(fIsTemplateArg);
call    0 never executed
        -:  617:    }
        -:  618:    void isTemplateArg(const bool value) {
        -:  619:        setFlag(fIsTemplateArg, value);
        -:  620:    }
        -:  621:
        -:  622:    static const Token *findsimplematch(const Token * const startTok, const char pattern[]);
        -:  623:    static const Token *findsimplematch(const Token * const startTok, const char pattern[], const Token * const end);
        -:  624:    static const Token *findmatch(const Token * const startTok, const char pattern[], const nonneg int varId = 0);
        -:  625:    static const Token *findmatch(const Token * const startTok, const char pattern[], const Token * const end, const nonneg int varId = 0);
        -:  626:    static Token *findsimplematch(Token * const startTok, const char pattern[]) {
        -:  627:        return const_cast<Token *>(findsimplematch(const_cast<const Token *>(startTok), pattern));
        -:  628:    }
        -:  629:    static Token *findsimplematch(Token * const startTok, const char pattern[], const Token * const end) {
        -:  630:        return const_cast<Token *>(findsimplematch(const_cast<const Token *>(startTok), pattern, end));
        -:  631:    }
        -:  632:    static Token *findmatch(Token * const startTok, const char pattern[], const nonneg int varId = 0) {
        -:  633:        return const_cast<Token *>(findmatch(const_cast<const Token *>(startTok), pattern, varId));
        -:  634:    }
function _ZN5Token9findmatchEPS_PKcPKS_i called 0 returned 0% blocks executed 0%
    #####:  635:    static Token *findmatch(Token * const startTok, const char pattern[], const Token * const end, const nonneg int varId = 0) {
    #####:  636:        return const_cast<Token *>(findmatch(const_cast<const Token *>(startTok), pattern, end, varId));
call    0 never executed
        -:  637:    }
        -:  638:
        -:  639:    /**
        -:  640:     * Needle is build from multiple alternatives. If one of
        -:  641:     * them is equal to haystack, return value is 1. If there
        -:  642:     * are no matches, but one alternative to needle is empty
        -:  643:     * string, return value is 0. If needle was not found, return
        -:  644:     * value is -1.
        -:  645:     *
        -:  646:     * @param tok Current token (needle)
        -:  647:     * @param haystack e.g. "one|two" or "|one|two"
        -:  648:     * @param varid optional varid of token
        -:  649:     * @return 1 if needle is found from the haystack
        -:  650:     *         0 if needle was empty string
        -:  651:     *        -1 if needle was not found
        -:  652:     */
        -:  653:    static int multiCompare(const Token *tok, const char *haystack, nonneg int varid);
        -:  654:
        -:  655:    nonneg int fileIndex() const {
        -:  656:        return mImpl->mFileIndex;
        -:  657:    }
        -:  658:    void fileIndex(nonneg int indexOfFile) {
        -:  659:        mImpl->mFileIndex = indexOfFile;
        -:  660:    }
        -:  661:
        -:  662:    nonneg int linenr() const {
        -:  663:        return mImpl->mLineNumber;
        -:  664:    }
        -:  665:    void linenr(nonneg int lineNumber) {
        -:  666:        mImpl->mLineNumber = lineNumber;
        -:  667:    }
        -:  668:
        -:  669:    nonneg int column() const {
        -:  670:        return mImpl->mColumn;
        -:  671:    }
        -:  672:    void column(nonneg int c) {
        -:  673:        mImpl->mColumn = c;
        -:  674:    }
        -:  675:
function _ZNK5Token4nextEv called 0 returned 0% blocks executed 0%
    #####:  676:    Token *next() const {
    #####:  677:        return mNext;
        -:  678:    }
        -:  679:
        -:  680:
        -:  681:    /**
        -:  682:     * Delete tokens between begin and end. E.g. if begin = 1
        -:  683:     * and end = 5, tokens 2,3 and 4 would be erased.
        -:  684:     *
        -:  685:     * @param begin Tokens after this will be erased.
        -:  686:     * @param end Tokens before this will be erased.
        -:  687:     */
        -:  688:    static void eraseTokens(Token *begin, const Token *end);
        -:  689:
        -:  690:    /**
        -:  691:     * Insert new token after this token. This function will handle
        -:  692:     * relations between next and previous token also.
        -:  693:     * @param tokenStr String for the new token.
        -:  694:     * @param originalNameStr String used for Token::originalName().
        -:  695:     * @param prepend Insert the new token before this token when it's not
        -:  696:     * the first one on the tokens list.
        -:  697:     */
        -:  698:    void insertToken(const std::string &tokenStr, const std::string &originalNameStr=emptyString, bool prepend=false);
        -:  699:
function _ZNK5Token8previousEv called 0 returned 0% blocks executed 0%
    #####:  700:    Token *previous() const {
    #####:  701:        return mPrevious;
        -:  702:    }
        -:  703:
        -:  704:
function _ZNK5Token5varIdEv called 0 returned 0% blocks executed 0%
    #####:  705:    nonneg int varId() const {
    #####:  706:        return mImpl->mVarId;
        -:  707:    }
        -:  708:    void varId(nonneg int id) {
        -:  709:        mImpl->mVarId = id;
        -:  710:        if (id != 0) {
        -:  711:            tokType(eVariable);
        -:  712:            isStandardType(false);
        -:  713:        } else {
        -:  714:            update_property_info();
        -:  715:        }
        -:  716:    }
        -:  717:
        -:  718:    /**
        -:  719:     * For debugging purposes, prints token and all tokens
        -:  720:     * followed by it.
        -:  721:     * @param title Title for the printout or use default parameter or 0
        -:  722:     * for no title.
        -:  723:     */
        -:  724:    void printOut(const char *title = nullptr) const;
        -:  725:
        -:  726:    /**
        -:  727:     * For debugging purposes, prints token and all tokens
        -:  728:     * followed by it.
        -:  729:     * @param title Title for the printout or use default parameter or 0
        -:  730:     * for no title.
        -:  731:     * @param fileNames Prints out file name instead of file index.
        -:  732:     * File index should match the index of the string in this vector.
        -:  733:     */
        -:  734:    void printOut(const char *title, const std::vector<std::string> &fileNames) const;
        -:  735:
        -:  736:    /**
        -:  737:     * Replace token replaceThis with tokens between start and end,
        -:  738:     * including start and end. The replaceThis token is deleted.
        -:  739:     * @param replaceThis This token will be deleted.
        -:  740:     * @param start This will be in the place of replaceThis
        -:  741:     * @param end This is also in the place of replaceThis
        -:  742:     */
        -:  743:    static void replace(Token *replaceThis, Token *start, Token *end);
        -:  744:
        -:  745:    /**
        -:  746:     * Stringify a token
        -:  747:     * @param os The result is shifted into that output stream
        -:  748:     * @param varid Print varids. (Style: "varname@id")
        -:  749:     * @param attributes Print attributes of tokens like "unsigned" in front of it.
        -:  750:     * @param macro Prints $ in front of the token if it was expanded from a macro.
        -:  751:     */
        -:  752:    void stringify(std::ostream& os, bool varid, bool attributes, bool macro) const;
        -:  753:
        -:  754:    /**
        -:  755:     * Stringify a list of token, from current instance on.
        -:  756:     * @param varid Print varids. (Style: "varname@id")
        -:  757:     * @param attributes Print attributes of tokens like "unsigned" in front of it.
        -:  758:     * @param linenumbers Print line number in front of each line
        -:  759:     * @param linebreaks Insert "\\n" into string when line number changes
        -:  760:     * @param files print Files as numbers or as names (if fileNames is given)
        -:  761:     * @param fileNames Vector of filenames. Used (if given) to print filenames as strings instead of numbers.
        -:  762:     * @param end Stringification ends before this token is reached. 0 to stringify until end of list.
        -:  763:     * @return Stringified token list as a string
        -:  764:     */
        -:  765:    std::string stringifyList(bool varid, bool attributes, bool linenumbers, bool linebreaks, bool files, const std::vector<std::string>* fileNames = nullptr, const Token* end = nullptr) const;
        -:  766:    std::string stringifyList(const Token* end, bool attributes = true) const;
        -:  767:    std::string stringifyList(bool varid = false) const;
        -:  768:
        -:  769:    /**
        -:  770:     * Remove the contents for this token from the token list.
        -:  771:     *
        -:  772:     * The contents are replaced with the contents of the next token and
        -:  773:     * the next token is unlinked and deleted from the token list.
        -:  774:     *
        -:  775:     * So this token will still be valid after the 'deleteThis()'.
        -:  776:     */
        -:  777:    void deleteThis();
        -:  778:
        -:  779:    /**
        -:  780:     * Create link to given token
        -:  781:     * @param linkToToken The token where this token should link
        -:  782:     * to.
        -:  783:     */
        -:  784:    void link(Token *linkToToken) {
        -:  785:        mLink = linkToToken;
        -:  786:        if (mStr == "<" || mStr == ">")
        -:  787:            update_property_info();
        -:  788:    }
        -:  789:
        -:  790:    /**
        -:  791:     * Return token where this token links to.
        -:  792:     * Supported links are:
        -:  793:     * "{" <-> "}"
        -:  794:     * "(" <-> ")"
        -:  795:     * "[" <-> "]"
        -:  796:     *
        -:  797:     * @return The token where this token links to.
        -:  798:     */
function _ZNK5Token4linkEv called 0 returned 0% blocks executed 0%
    #####:  799:    Token *link() const {
    #####:  800:        return mLink;
        -:  801:    }
        -:  802:
        -:  803:    /**
        -:  804:     * Associate this token with given scope
        -:  805:     * @param s Scope to be associated
        -:  806:     */
        -:  807:    void scope(const Scope *s) {
        -:  808:        mImpl->mScope = s;
        -:  809:    }
        -:  810:
        -:  811:    /**
        -:  812:     * @return a pointer to the scope containing this token.
        -:  813:     */
function _ZNK5Token5scopeEv called 0 returned 0% blocks executed 0%
    #####:  814:    const Scope *scope() const {
    #####:  815:        return mImpl->mScope;
        -:  816:    }
        -:  817:
        -:  818:    /**
        -:  819:     * Associate this token with given function
        -:  820:     * @param f Function to be associated
        -:  821:     */
        -:  822:    void function(const Function *f);
        -:  823:
        -:  824:    /**
        -:  825:     * @return a pointer to the Function associated with this token.
        -:  826:     */
function _ZNK5Token8functionEv called 0 returned 0% blocks executed 0%
    #####:  827:    const Function *function() const {
    #####:  828:        return mTokType == eFunction || mTokType == eLambda ? mImpl->mFunction : nullptr;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  829:    }
        -:  830:
        -:  831:    /**
        -:  832:     * Associate this token with given variable
        -:  833:     * @param v Variable to be associated
        -:  834:     */
        -:  835:    void variable(const Variable *v) {
        -:  836:        mImpl->mVariable = v;
        -:  837:        if (v || mImpl->mVarId)
        -:  838:            tokType(eVariable);
        -:  839:        else if (mTokType == eVariable)
        -:  840:            tokType(eName);
        -:  841:    }
        -:  842:
        -:  843:    /**
        -:  844:     * @return a pointer to the variable associated with this token.
        -:  845:     */
function _ZNK5Token8variableEv called 0 returned 0% blocks executed 0%
    #####:  846:    const Variable *variable() const {
    #####:  847:        return mTokType == eVariable ? mImpl->mVariable : nullptr;
branch  0 never executed
branch  1 never executed
        -:  848:    }
        -:  849:
        -:  850:    /**
        -:  851:    * Associate this token with given type
        -:  852:    * @param t Type to be associated
        -:  853:    */
        -:  854:    void type(const ::Type *t);
        -:  855:
        -:  856:    /**
        -:  857:    * @return a pointer to the type associated with this token.
        -:  858:    */
function _ZNK5Token4typeEv called 0 returned 0% blocks executed 0%
    #####:  859:    const ::Type *type() const {
    #####:  860:        return mTokType == eType ? mImpl->mType : nullptr;
branch  0 never executed
branch  1 never executed
        -:  861:    }
        -:  862:
        -:  863:    static const ::Type *typeOf(const Token *tok);
        -:  864:
        -:  865:    static std::pair<const Token*, const Token*> typeDecl(const Token * tok);
        -:  866:
        -:  867:    static std::string typeStr(const Token* tok);
        -:  868:
        -:  869:    /**
        -:  870:    * @return a pointer to the Enumerator associated with this token.
        -:  871:    */
function _ZNK5Token10enumeratorEv called 0 returned 0% blocks executed 0%
    #####:  872:    const Enumerator *enumerator() const {
    #####:  873:        return mTokType == eEnumerator ? mImpl->mEnumerator : nullptr;
branch  0 never executed
branch  1 never executed
        -:  874:    }
        -:  875:
        -:  876:    /**
        -:  877:     * Associate this token with given enumerator
        -:  878:     * @param e Enumerator to be associated
        -:  879:     */
        -:  880:    void enumerator(const Enumerator *e) {
        -:  881:        mImpl->mEnumerator = e;
        -:  882:        if (e)
        -:  883:            tokType(eEnumerator);
        -:  884:        else if (mTokType == eEnumerator)
        -:  885:            tokType(eName);
        -:  886:    }
        -:  887:
        -:  888:    /**
        -:  889:     * Links two elements against each other.
        -:  890:     **/
        -:  891:    static void createMutualLinks(Token *begin, Token *end);
        -:  892:
        -:  893:    /**
        -:  894:     * This can be called only for tokens that are strings, else
        -:  895:     * the assert() is called. If Token is e.g. '"hello"', this will return
        -:  896:     * 'hello' (removing the double quotes).
        -:  897:     * @return String value
        -:  898:     */
        -:  899:    std::string strValue() const;
        -:  900:
        -:  901:    /**
        -:  902:     * Move srcStart and srcEnd tokens and all tokens between them
        -:  903:     * into new a location. Only links between tokens are changed.
        -:  904:     * @param srcStart This is the first token to be moved
        -:  905:     * @param srcEnd The last token to be moved
        -:  906:     * @param newLocation srcStart will be placed after this token.
        -:  907:     */
        -:  908:    static void move(Token *srcStart, Token *srcEnd, Token *newLocation);
        -:  909:
        -:  910:    /** Get progressValue (0 - 100) */
        -:  911:    nonneg int progressValue() const {
        -:  912:        return mImpl->mProgressValue;
        -:  913:    }
        -:  914:
        -:  915:    /** Calculate progress values for all tokens */
        -:  916:    static void assignProgressValues(Token *tok);
        -:  917:
        -:  918:    /**
        -:  919:     * @return the first token of the next argument. Does only work on argument
        -:  920:     * lists. Requires that Tokenizer::createLinks2() has been called before.
        -:  921:     * Returns 0, if there is no next argument.
        -:  922:     */
        -:  923:    Token* nextArgument() const;
        -:  924:
        -:  925:    /**
        -:  926:     * @return the first token of the next argument. Does only work on argument
        -:  927:     * lists. Should be used only before Tokenizer::createLinks2() was called.
        -:  928:     * Returns 0, if there is no next argument.
        -:  929:     */
        -:  930:    Token* nextArgumentBeforeCreateLinks2() const;
        -:  931:
        -:  932:    /**
        -:  933:    * @return the first token of the next template argument. Does only work on template argument
        -:  934:    * lists. Requires that Tokenizer::createLinks2() has been called before.
        -:  935:    * Returns 0, if there is no next argument.
        -:  936:    */
        -:  937:    Token* nextTemplateArgument() const;
        -:  938:
        -:  939:    /**
        -:  940:     * Returns the closing bracket of opening '<'. Should only be used if link()
        -:  941:     * is unavailable.
        -:  942:     * @return closing '>', ')', ']' or '}'. if no closing bracket is found, NULL is returned
        -:  943:     */
        -:  944:    const Token* findClosingBracket() const;
        -:  945:    Token* findClosingBracket();
        -:  946:
        -:  947:    const Token* findOpeningBracket() const;
        -:  948:    Token* findOpeningBracket();
        -:  949:
        -:  950:    /**
        -:  951:     * @return the original name.
        -:  952:     */
function _ZNK5Token12originalNameB5cxx11Ev called 0 returned 0% blocks executed 0%
    #####:  953:    const std::string & originalName() const {
    #####:  954:        return mImpl->mOriginalName ? *mImpl->mOriginalName : emptyString;
branch  0 never executed
branch  1 never executed
        -:  955:    }
        -:  956:
function _ZNK5Token6valuesEv called 0 returned 0% blocks executed 0%
    #####:  957:    const std::list<ValueFlow::Value>& values() const {
    #####:  958:        return mImpl->mValues ? *mImpl->mValues : mImpl->mEmptyValueList;
branch  0 never executed
branch  1 never executed
        -:  959:    }
        -:  960:
        -:  961:    /**
        -:  962:     * Sets the original name.
        -:  963:     */
        -:  964:    template<typename T>
        -:  965:    void originalName(T&& name) {
        -:  966:        if (!mImpl->mOriginalName)
        -:  967:            mImpl->mOriginalName = new std::string(name);
        -:  968:        else
        -:  969:            *mImpl->mOriginalName = name;
        -:  970:    }
        -:  971:
function _ZNK5Token16hasKnownIntValueEv called 0 returned 0% blocks executed 0%
    #####:  972:    bool hasKnownIntValue() const {
    #####:  973:        if (!mImpl->mValues)
branch  0 never executed
branch  1 never executed
    #####:  974:            return false;
function _ZZNK5Token16hasKnownIntValueEvENUlRKN9ValueFlow5ValueEE_4_FUNES3_ called 0 returned 0% blocks executed 0%
function _ZZNK5Token16hasKnownIntValueEvENKUlRKN9ValueFlow5ValueEE_clES3_ called 0 returned 0% blocks executed 0%
    #####:  975:        return std::any_of(mImpl->mValues->begin(), mImpl->mValues->end(), [](const ValueFlow::Value &value) {
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####:  976:            return value.isKnown() && value.isIntValue();
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  977:        });
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  978:    }
        -:  979:
function _ZNK5Token13hasKnownValueEv called 0 returned 0% blocks executed 0%
    #####:  980:    bool hasKnownValue() const {
    #####:  981:        return mImpl->mValues && std::any_of(mImpl->mValues->begin(), mImpl->mValues->end(), std::mem_fn(&ValueFlow::Value::isKnown));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
call   12 never executed
branch 13 never executed
branch 14 never executed
call   15 never executed
branch 16 never executed
branch 17 never executed
call   18 never executed
branch 19 never executed
branch 20 never executed
call   21 never executed
        -:  982:    }
        -:  983:
function _ZNK5Token16getKnownIntValueEv called 0 returned 0% blocks executed 0%
    #####:  984:    MathLib::bigint getKnownIntValue() const {
    #####:  985:        return mImpl->mValues->front().intvalue;
call    0 never executed
        -:  986:    }
        -:  987:
function _ZNK5Token8getValueEx called 0 returned 0% blocks executed 0%
    #####:  988:    const ValueFlow::Value * getValue(const MathLib::bigint val) const {
    #####:  989:        if (!mImpl->mValues)
branch  0 never executed
branch  1 never executed
    #####:  990:            return nullptr;
function _ZZNK5Token8getValueExENKUlRKN9ValueFlow5ValueEE_clES3_ called 0 returned 0% blocks executed 0%
    #####:  991:        const auto it = std::find_if(mImpl->mValues->begin(), mImpl->mValues->end(), [=](const ValueFlow::Value& value) {
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  992:            return value.isIntValue() && !value.isImpossible() && value.intvalue == val;
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:  993:        });
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####:  994:        return it == mImpl->mValues->end() ? nullptr : &*it;;
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
        -:  995:    }
        -:  996:
        -:  997:    const ValueFlow::Value * getMaxValue(bool condition) const {
        -:  998:        if (!mImpl->mValues)
        -:  999:            return nullptr;
        -: 1000:        const ValueFlow::Value *ret = nullptr;
        -: 1001:        for (const ValueFlow::Value &value : *mImpl->mValues) {
        -: 1002:            if (!value.isIntValue())
        -: 1003:                continue;
        -: 1004:            if (value.isImpossible())
        -: 1005:                continue;
        -: 1006:            if ((!ret || value.intvalue > ret->intvalue) &&
        -: 1007:                ((value.condition != nullptr) == condition))
        -: 1008:                ret = &value;
        -: 1009:        }
        -: 1010:        return ret;
        -: 1011:    }
        -: 1012:
        -: 1013:    const ValueFlow::Value * getMovedValue() const {
        -: 1014:        if (!mImpl->mValues)
        -: 1015:            return nullptr;
        -: 1016:        const auto it = std::find_if(mImpl->mValues->begin(), mImpl->mValues->end(), [](const ValueFlow::Value& value) {
        -: 1017:            return value.isMovedValue() && !value.isImpossible() &&
        -: 1018:                   value.moveKind != ValueFlow::Value::MoveKind::NonMovedVariable;
        -: 1019:        });
        -: 1020:        return it == mImpl->mValues->end() ? nullptr : &*it;;
        -: 1021:    }
        -: 1022:
        -: 1023:    const ValueFlow::Value * getValueLE(const MathLib::bigint val, const Settings *settings) const;
        -: 1024:    const ValueFlow::Value * getValueGE(const MathLib::bigint val, const Settings *settings) const;
        -: 1025:
        -: 1026:    const ValueFlow::Value * getInvalidValue(const Token *ftok, nonneg int argnr, const Settings *settings) const;
        -: 1027:
        -: 1028:    const ValueFlow::Value * getContainerSizeValue(const MathLib::bigint val) const {
        -: 1029:        if (!mImpl->mValues)
        -: 1030:            return nullptr;
        -: 1031:        const auto it = std::find_if(mImpl->mValues->begin(), mImpl->mValues->end(), [=](const ValueFlow::Value& value) {
        -: 1032:            return value.isContainerSizeValue() && !value.isImpossible() && value.intvalue == val;
        -: 1033:        });
        -: 1034:        return it == mImpl->mValues->end() ? nullptr : &*it;
        -: 1035:    }
        -: 1036:
        -: 1037:    const Token *getValueTokenMaxStrLength() const;
        -: 1038:    const Token *getValueTokenMinStrSize() const;
        -: 1039:
        -: 1040:    const Token *getValueTokenDeadPointer() const;
        -: 1041:
        -: 1042:    /** Add token value. Return true if value is added. */
        -: 1043:    bool addValue(const ValueFlow::Value &value);
        -: 1044:
        -: 1045:    template<class Predicate>
function _ZN5Token12removeValuesISt7_Mem_fnIMN9ValueFlow5ValueEKFbvEEEEvT_ called 0 returned 0% blocks executed 0%
    #####: 1046:    void removeValues(Predicate pred) {
    #####: 1047:        if (mImpl->mValues)
branch  0 never executed
branch  1 never executed
    #####: 1048:            mImpl->mValues->remove_if(pred);
call    0 never executed
    #####: 1049:    }
        -: 1050:
        -: 1051:    nonneg int index() const {
        -: 1052:        return mImpl->mIndex;
        -: 1053:    }
        -: 1054:
        -: 1055:    void assignIndexes();
        -: 1056:
        -: 1057:private:
        -: 1058:
        -: 1059:    void next(Token *nextToken) {
        -: 1060:        mNext = nextToken;
        -: 1061:    }
        -: 1062:    void previous(Token *previousToken) {
        -: 1063:        mPrevious = previousToken;
        -: 1064:    }
        -: 1065:
        -: 1066:    /** used by deleteThis() to take data from token to delete */
        -: 1067:    void takeData(Token *fromToken);
        -: 1068:
        -: 1069:    /**
        -: 1070:     * Works almost like strcmp() except returns only true or false and
        -: 1071:     * if str has empty space &apos; &apos; character, that character is handled
        -: 1072:     * as if it were &apos;\\0&apos;
        -: 1073:     */
        -: 1074:    static bool firstWordEquals(const char *str, const char *word);
        -: 1075:
        -: 1076:    /**
        -: 1077:     * Works almost like strchr() except
        -: 1078:     * if str has empty space &apos; &apos; character, that character is handled
        -: 1079:     * as if it were &apos;\\0&apos;
        -: 1080:     */
        -: 1081:    static const char *chrInFirstWord(const char *str, char c);
        -: 1082:
        -: 1083:    std::string mStr;
        -: 1084:
        -: 1085:    Token *mNext;
        -: 1086:    Token *mPrevious;
        -: 1087:    Token *mLink;
        -: 1088:
        -: 1089:    enum {
        -: 1090:        fIsUnsigned             = (1 << 0),
        -: 1091:        fIsSigned               = (1 << 1),
        -: 1092:        fIsPointerCompare       = (1 << 2),
        -: 1093:        fIsLong                 = (1 << 3),
        -: 1094:        fIsStandardType         = (1 << 4),
        -: 1095:        fIsExpandedMacro        = (1 << 5),
        -: 1096:        fIsCast                 = (1 << 6),
        -: 1097:        fIsAttributeConstructor = (1 << 7),  // __attribute__((constructor)) __attribute__((constructor(priority)))
        -: 1098:        fIsAttributeDestructor  = (1 << 8),  // __attribute__((destructor))  __attribute__((destructor(priority)))
        -: 1099:        fIsAttributeUnused      = (1 << 9),  // __attribute__((unused))
        -: 1100:        fIsAttributePure        = (1 << 10), // __attribute__((pure))
        -: 1101:        fIsAttributeConst       = (1 << 11), // __attribute__((const))
        -: 1102:        fIsAttributeNoreturn    = (1 << 12), // __attribute__((noreturn)), __declspec(noreturn)
        -: 1103:        fIsAttributeNothrow     = (1 << 13), // __attribute__((nothrow)), __declspec(nothrow)
        -: 1104:        fIsAttributeUsed        = (1 << 14), // __attribute__((used))
        -: 1105:        fIsAttributePacked      = (1 << 15), // __attribute__((packed))
        -: 1106:        fIsControlFlowKeyword   = (1 << 16), // if/switch/while/...
        -: 1107:        fIsOperatorKeyword      = (1 << 17), // operator=, etc
        -: 1108:        fIsComplex              = (1 << 18), // complex/_Complex type
        -: 1109:        fIsEnumType             = (1 << 19), // enumeration type
        -: 1110:        fIsName                 = (1 << 20),
        -: 1111:        fIsLiteral              = (1 << 21),
        -: 1112:        fIsTemplateArg          = (1 << 22),
        -: 1113:        fIsAttributeNodiscard   = (1 << 23), // __attribute__ ((warn_unused_result)), [[nodiscard]]
        -: 1114:        fAtAddress              = (1 << 24), // @ 0x4000
        -: 1115:        fIncompleteVar          = (1 << 25),
        -: 1116:        fConstexpr              = (1 << 26),
        -: 1117:    };
        -: 1118:
        -: 1119:    Token::Type mTokType;
        -: 1120:
        -: 1121:    unsigned int mFlags;
        -: 1122:
        -: 1123:    TokenImpl *mImpl;
        -: 1124:
        -: 1125:    /**
        -: 1126:     * Get specified flag state.
        -: 1127:     * @param flag_ flag to get state of
        -: 1128:     * @return true if flag set or false in flag not set
        -: 1129:     */
function _ZNK5Token7getFlagEj called 0 returned 0% blocks executed 0%
    #####: 1130:    bool getFlag(unsigned int flag_) const {
    #####: 1131:        return ((mFlags & flag_) != 0);
        -: 1132:    }
        -: 1133:
        -: 1134:    /**
        -: 1135:     * Set specified flag state.
        -: 1136:     * @param flag_ flag to set state
        -: 1137:     * @param state_ new state of flag
        -: 1138:     */
        -: 1139:    void setFlag(unsigned int flag_, bool state_) {
        -: 1140:        mFlags = state_ ? mFlags | flag_ : mFlags & ~flag_;
        -: 1141:    }
        -: 1142:
        -: 1143:    /** Updates internal property cache like _isName or _isBoolean.
        -: 1144:        Called after any mStr() modification. */
        -: 1145:    void update_property_info();
        -: 1146:
        -: 1147:    /** Update internal property cache about isStandardType() */
        -: 1148:    void update_property_isStandardType();
        -: 1149:
        -: 1150:    /** Update internal property cache about string and char literals */
        -: 1151:    void update_property_char_string_literal();
        -: 1152:
        -: 1153:    /** Internal helper function to avoid excessive string allocations */
        -: 1154:    void astStringVerboseRecursive(std::string& ret, const nonneg int indent1 = 0, const nonneg int indent2 = 0) const;
        -: 1155:
        -: 1156:public:
        -: 1157:    void astOperand1(Token *tok);
        -: 1158:    void astOperand2(Token *tok);
        -: 1159:
function _ZN5Token11astOperand1Ev called 0 returned 0% blocks executed 0%
    #####: 1160:    Token * astOperand1() {
    #####: 1161:        return mImpl->mAstOperand1;
        -: 1162:    }
function _ZNK5Token11astOperand1Ev called 0 returned 0% blocks executed 0%
    #####: 1163:    const Token * astOperand1() const {
    #####: 1164:        return mImpl->mAstOperand1;
        -: 1165:    }
function _ZN5Token11astOperand2Ev called 0 returned 0% blocks executed 0%
    #####: 1166:    Token * astOperand2() {
    #####: 1167:        return mImpl->mAstOperand2;
        -: 1168:    }
function _ZNK5Token11astOperand2Ev called 0 returned 0% blocks executed 0%
    #####: 1169:    const Token * astOperand2() const {
    #####: 1170:        return mImpl->mAstOperand2;
        -: 1171:    }
function _ZN5Token9astParentEv called 0 returned 0% blocks executed 0%
    #####: 1172:    Token * astParent() {
    #####: 1173:        return mImpl->mAstParent;
        -: 1174:    }
function _ZNK5Token9astParentEv called 0 returned 0% blocks executed 0%
    #####: 1175:    const Token * astParent() const {
    #####: 1176:        return mImpl->mAstParent;
        -: 1177:    }
function _ZN5Token6astTopEv called 0 returned 0% blocks executed 0%
    #####: 1178:    Token *astTop() {
    #####: 1179:        Token *ret = this;
    #####: 1180:        while (ret->mImpl->mAstParent)
branch  0 never executed
branch  1 never executed
    #####: 1181:            ret = ret->mImpl->mAstParent;
    #####: 1182:        return ret;
        -: 1183:    }
        -: 1184:
function _ZNK5Token6astTopEv called 0 returned 0% blocks executed 0%
    #####: 1185:    const Token *astTop() const {
    #####: 1186:        const Token *ret = this;
    #####: 1187:        while (ret->mImpl->mAstParent)
branch  0 never executed
branch  1 never executed
    #####: 1188:            ret = ret->mImpl->mAstParent;
    #####: 1189:        return ret;
        -: 1190:    }
        -: 1191:
        -: 1192:    std::pair<const Token *, const Token *> findExpressionStartEndTokens() const;
        -: 1193:
        -: 1194:    /**
        -: 1195:     * Is current token a calculation? Only true for operands.
        -: 1196:     * For '*' and '&' tokens it is looked up if this is a
        -: 1197:     * dereference or address-of. A dereference or address-of is not
        -: 1198:     * counted as a calculation.
        -: 1199:     * @return returns true if current token is a calculation
        -: 1200:     */
        -: 1201:    bool isCalculation() const;
        -: 1202:
        -: 1203:    void clearAst() {
        -: 1204:        mImpl->mAstOperand1 = mImpl->mAstOperand2 = mImpl->mAstParent = nullptr;
        -: 1205:    }
        -: 1206:
function _ZN5Token14clearValueFlowEv called 0 returned 0% blocks executed 0%
    #####: 1207:    void clearValueFlow() {
    #####: 1208:        delete mImpl->mValues;
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####: 1209:        mImpl->mValues = nullptr;
    #####: 1210:    }
        -: 1211:
        -: 1212:    std::string astString(const char *sep = "") const {
        -: 1213:        std::string ret;
        -: 1214:        if (mImpl->mAstOperand1)
        -: 1215:            ret = mImpl->mAstOperand1->astString(sep);
        -: 1216:        if (mImpl->mAstOperand2)
        -: 1217:            ret += mImpl->mAstOperand2->astString(sep);
        -: 1218:        return ret + sep + mStr;
        -: 1219:    }
        -: 1220:
        -: 1221:    std::string astStringVerbose() const;
        -: 1222:
        -: 1223:    std::string expressionString() const;
        -: 1224:
        -: 1225:    void printAst(bool verbose, bool xml, std::ostream &out) const;
        -: 1226:
        -: 1227:    void printValueFlow(bool xml, std::ostream &out) const;
        -: 1228:
        -: 1229:    void scopeInfo(std::shared_ptr<ScopeInfo2> newScopeInfo);
        -: 1230:    std::shared_ptr<ScopeInfo2> scopeInfo() const;
        -: 1231:
        -: 1232:    void setCpp11init(bool cpp11init) const {
        -: 1233:        mImpl->mCpp11init=cpp11init ? TokenImpl::Cpp11init::CPP11INIT : TokenImpl::Cpp11init::NOINIT;
        -: 1234:    }
        -: 1235:    TokenImpl::Cpp11init isCpp11init() const {
        -: 1236:        return mImpl->mCpp11init;
        -: 1237:    }
        -: 1238:};
        -: 1239:
        -: 1240:/// @}
        -: 1241://---------------------------------------------------------------------------
        -: 1242:#endif // tokenH
