        -:    0:Source:/home/workspace/lib/library.h
        -:    0:Graph:/home/workspace/build/lib/CMakeFiles/lib_objs.dir/valueflow.gcno
        -:    0:Data:/home/workspace/build/lib/CMakeFiles/lib_objs.dir/valueflow.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*
        -:    2: * Cppcheck - A tool for static C/C++ code analysis
        -:    3: * Copyright (C) 2007-2019 Cppcheck team.
        -:    4: *
        -:    5: * This program is free software: you can redistribute it and/or modify
        -:    6: * it under the terms of the GNU General Public License as published by
        -:    7: * the Free Software Foundation, either version 3 of the License, or
        -:    8: * (at your option) any later version.
        -:    9: *
        -:   10: * This program is distributed in the hope that it will be useful,
        -:   11: * but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   12: * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   13: * GNU General Public License for more details.
        -:   14: *
        -:   15: * You should have received a copy of the GNU General Public License
        -:   16: * along with this program.  If not, see <http://www.gnu.org/licenses/>.
        -:   17: */
        -:   18:
        -:   19://---------------------------------------------------------------------------
        -:   20:#ifndef libraryH
        -:   21:#define libraryH
        -:   22://---------------------------------------------------------------------------
        -:   23:
        -:   24:#include "config.h"
        -:   25:#include "errorlogger.h"
        -:   26:#include "mathlib.h"
        -:   27:#include "standards.h"
        -:   28:
        -:   29:#include <cstddef>
        -:   30:#include <map>
        -:   31:#include <set>
        -:   32:#include <string>
        -:   33:#include <utility>
        -:   34:#include <vector>
        -:   35:
        -:   36:class Token;
        -:   37:
        -:   38:namespace tinyxml2 {
        -:   39:    class XMLDocument;
        -:   40:    class XMLElement;
        -:   41:}
        -:   42:
        -:   43:/// @addtogroup Core
        -:   44:/// @{
        -:   45:
        -:   46:/**
        -:   47: * @brief Library definitions handling
        -:   48: */
        -:   49:class CPPCHECKLIB Library {
        -:   50:    friend class TestSymbolDatabase; // For testing only
        -:   51:
        -:   52:public:
        -:   53:    Library();
        -:   54:
        -:   55:    enum ErrorCode { OK, FILE_NOT_FOUND, BAD_XML, UNKNOWN_ELEMENT, MISSING_ATTRIBUTE, BAD_ATTRIBUTE_VALUE, UNSUPPORTED_FORMAT, DUPLICATE_PLATFORM_TYPE, PLATFORM_TYPE_REDEFINED };
        -:   56:
        -:   57:    class Error {
        -:   58:    public:
        -:   59:        Error() : errorcode(OK) {}
        -:   60:        explicit Error(ErrorCode e) : errorcode(e) {}
        -:   61:        template<typename T>
        -:   62:        Error(ErrorCode e, T&& r) : errorcode(e), reason(r) {}
        -:   63:        ErrorCode     errorcode;
        -:   64:        std::string   reason;
        -:   65:    };
        -:   66:
        -:   67:    Error load(const char exename [], const char path []);
        -:   68:    Error load(const tinyxml2::XMLDocument &doc);
        -:   69:
        -:   70:    /** this is primarily meant for unit tests. it only returns true/false */
        -:   71:    bool loadxmldata(const char xmldata[], std::size_t len);
        -:   72:
        -:   73:    struct AllocFunc {
        -:   74:        int groupId;
        -:   75:        int arg;
        -:   76:        enum class BufferSize {none,malloc,calloc,strdup};
        -:   77:        BufferSize bufferSize;
        -:   78:        int bufferSizeArg1;
        -:   79:        int bufferSizeArg2;
        -:   80:        int reallocArg;
        -:   81:    };
        -:   82:
        -:   83:    /** get allocation info for function */
        -:   84:    const AllocFunc* getAllocFuncInfo(const Token *tok) const;
        -:   85:
        -:   86:    /** get deallocation info for function */
        -:   87:    const AllocFunc* getDeallocFuncInfo(const Token *tok) const;
        -:   88:
        -:   89:    /** get reallocation info for function */
        -:   90:    const AllocFunc* getReallocFuncInfo(const Token *tok) const;
        -:   91:
        -:   92:    /** get allocation id for function */
        -:   93:    int getAllocId(const Token *tok, int arg) const;
        -:   94:
        -:   95:    /** get deallocation id for function */
        -:   96:    int getDeallocId(const Token *tok, int arg) const;
        -:   97:
        -:   98:    /** get reallocation id for function */
        -:   99:    int getReallocId(const Token *tok, int arg) const;
        -:  100:
        -:  101:    /** get allocation info for function by name (deprecated, use other alloc) */
        -:  102:    const AllocFunc* getAllocFuncInfo(const char name[]) const {
        -:  103:        return getAllocDealloc(mAlloc, name);
        -:  104:    }
        -:  105:
        -:  106:    /** get deallocation info for function by name (deprecated, use other alloc) */
        -:  107:    const AllocFunc* getDeallocFuncInfo(const char name[]) const {
        -:  108:        return getAllocDealloc(mDealloc, name);
        -:  109:    }
        -:  110:
        -:  111:    /** get allocation id for function by name (deprecated, use other alloc) */
        -:  112:    int allocId(const char name[]) const {
        -:  113:        const AllocFunc* af = getAllocDealloc(mAlloc, name);
        -:  114:        return af ? af->groupId : 0;
        -:  115:    }
        -:  116:
        -:  117:    /** get deallocation id for function by name (deprecated, use other alloc) */
        -:  118:    int deallocId(const char name[]) const {
        -:  119:        const AllocFunc* af = getAllocDealloc(mDealloc, name);
        -:  120:        return af ? af->groupId : 0;
        -:  121:    }
        -:  122:
        -:  123:    /** set allocation id for function */
        -:  124:    void setalloc(const std::string &functionname, int id, int arg) {
        -:  125:        mAlloc[functionname].groupId = id;
        -:  126:        mAlloc[functionname].arg = arg;
        -:  127:    }
        -:  128:
        -:  129:    void setdealloc(const std::string &functionname, int id, int arg) {
        -:  130:        mDealloc[functionname].groupId = id;
        -:  131:        mDealloc[functionname].arg = arg;
        -:  132:    }
        -:  133:
        -:  134:    void setrealloc(const std::string &functionname, int id, int arg, int reallocArg = 1) {
        -:  135:        mRealloc[functionname].groupId = id;
        -:  136:        mRealloc[functionname].arg = arg;
        -:  137:        mRealloc[functionname].reallocArg = reallocArg;
        -:  138:    }
        -:  139:
        -:  140:    /** add noreturn function setting */
        -:  141:    void setnoreturn(const std::string& funcname, bool noreturn) {
        -:  142:        mNoReturn[funcname] = noreturn;
        -:  143:    }
        -:  144:
        -:  145:    /** is allocation type memory? */
        -:  146:    static bool ismemory(const int id) {
        -:  147:        return ((id > 0) && ((id & 1) == 0));
        -:  148:    }
        -:  149:    static bool ismemory(const AllocFunc* const func) {
        -:  150:        return ((func->groupId > 0) && ((func->groupId & 1) == 0));
        -:  151:    }
        -:  152:
        -:  153:    /** is allocation type resource? */
        -:  154:    static bool isresource(const int id) {
        -:  155:        return ((id > 0) && ((id & 1) == 1));
        -:  156:    }
        -:  157:    static bool isresource(const AllocFunc* const func) {
        -:  158:        return ((func->groupId > 0) && ((func->groupId & 1) == 1));
        -:  159:    }
        -:  160:
        -:  161:    bool formatstr_function(const Token* ftok) const;
        -:  162:    int formatstr_argno(const Token* ftok) const;
        -:  163:    bool formatstr_scan(const Token* ftok) const;
        -:  164:    bool formatstr_secure(const Token* ftok) const;
        -:  165:
        -:  166:    struct WarnInfo {
        -:  167:        std::string message;
        -:  168:        Standards standards;
        -:  169:        Severity::SeverityType severity;
        -:  170:    };
        -:  171:    std::map<std::string, WarnInfo> functionwarn;
        -:  172:
        -:  173:    const WarnInfo* getWarnInfo(const Token* ftok) const;
        -:  174:
        -:  175:    // returns true if ftok is not a library function
        -:  176:    bool isNotLibraryFunction(const Token *ftok) const;
        -:  177:    bool matchArguments(const Token *ftok, const std::string &functionName) const;
        -:  178:
        -:  179:    bool isUseRetVal(const Token* ftok) const;
        -:  180:
        -:  181:    const std::string& returnValue(const Token *ftok) const;
        -:  182:    const std::string& returnValueType(const Token *ftok) const;
        -:  183:    int returnValueContainer(const Token *ftok) const;
        -:  184:    std::vector<MathLib::bigint> unknownReturnValues(const Token *ftok) const;
        -:  185:
        -:  186:    bool isnoreturn(const Token *ftok) const;
        -:  187:    bool isnotnoreturn(const Token *ftok) const;
        -:  188:
        -:  189:    bool isScopeNoReturn(const Token *end, std::string *unknownFunc) const;
        -:  190:
        -:  191:    class Container {
        -:  192:    public:
        -:  193:        Container() :
        -:  194:            type_templateArgNo(-1),
        -:  195:            size_templateArgNo(-1),
        -:  196:            arrayLike_indexOp(false),
        -:  197:            stdStringLike(false),
        -:  198:            stdAssociativeLike(false),
        -:  199:            opLessAllowed(true) {
        -:  200:        }
        -:  201:
        -:  202:        enum class Action {
        -:  203:            RESIZE, CLEAR, PUSH, POP, FIND, INSERT, ERASE, CHANGE_CONTENT, CHANGE, CHANGE_INTERNAL,
        -:  204:            NO_ACTION
        -:  205:        };
        -:  206:        enum class Yield {
        -:  207:            AT_INDEX, ITEM, BUFFER, BUFFER_NT, START_ITERATOR, END_ITERATOR, ITERATOR, SIZE, EMPTY,
        -:  208:            NO_YIELD
        -:  209:        };
        -:  210:        struct Function {
        -:  211:            Action action;
        -:  212:            Yield yield;
        -:  213:        };
        -:  214:        std::string startPattern, startPattern2, endPattern, itEndPattern;
        -:  215:        std::map<std::string, Function> functions;
        -:  216:        int type_templateArgNo;
        -:  217:        int size_templateArgNo;
        -:  218:        bool arrayLike_indexOp;
        -:  219:        bool stdStringLike;
        -:  220:        bool stdAssociativeLike;
        -:  221:        bool opLessAllowed;
        -:  222:
function _ZNK7Library9Container9getActionERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 0 returned 0% blocks executed 0%
    #####:  223:        Action getAction(const std::string& function) const {
    #####:  224:            const std::map<std::string, Function>::const_iterator i = functions.find(function);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  225:            if (i != functions.end())
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  226:                return i->second.action;
call    0 never executed
    #####:  227:            return Action::NO_ACTION;
        -:  228:        }
        -:  229:
function _ZNK7Library9Container8getYieldERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 0 returned 0% blocks executed 0%
    #####:  230:        Yield getYield(const std::string& function) const {
    #####:  231:            const std::map<std::string, Function>::const_iterator i = functions.find(function);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  232:            if (i != functions.end())
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  233:                return i->second.yield;
call    0 never executed
    #####:  234:            return Yield::NO_YIELD;
        -:  235:        }
        -:  236:    };
        -:  237:    std::map<std::string, Container> containers;
        -:  238:    const Container* detectContainer(const Token* typeStart, bool iterator = false) const;
        -:  239:
        -:  240:    class ArgumentChecks {
        -:  241:    public:
        -:  242:        ArgumentChecks() :
        -:  243:            notbool(false),
        -:  244:            notnull(false),
        -:  245:            notuninit(false),
        -:  246:            formatstr(false),
        -:  247:            strz(false),
        -:  248:            optional(false),
        -:  249:            variadic(false),
        -:  250:            iteratorInfo(),
        -:  251:            direction(Direction::DIR_UNKNOWN) {
        -:  252:        }
        -:  253:
        -:  254:        bool         notbool;
        -:  255:        bool         notnull;
        -:  256:        bool         notuninit;
        -:  257:        bool         formatstr;
        -:  258:        bool         strz;
        -:  259:        bool         optional;
        -:  260:        bool         variadic;
        -:  261:        std::string  valid;
        -:  262:
        -:  263:        class IteratorInfo {
        -:  264:        public:
        -:  265:            IteratorInfo() : container(0), it(false), first(false), last(false) {}
        -:  266:
        -:  267:            int  container;
        -:  268:            bool it;
        -:  269:            bool first;
        -:  270:            bool last;
        -:  271:        };
        -:  272:        IteratorInfo iteratorInfo;
        -:  273:
        -:  274:        class MinSize {
        -:  275:        public:
        -:  276:            enum Type { NONE, STRLEN, ARGVALUE, SIZEOF, MUL, VALUE };
        -:  277:            MinSize(Type t, int a) : type(t), arg(a), arg2(0), value(0) {}
        -:  278:            Type type;
        -:  279:            int arg;
        -:  280:            int arg2;
        -:  281:            long long value;
        -:  282:        };
        -:  283:        std::vector<MinSize> minsizes;
        -:  284:
        -:  285:        enum class Direction {
        -:  286:            DIR_IN,     ///< Input to called function. Data is treated as read-only.
        -:  287:            DIR_OUT,    ///< Output to caller. Data is passed by reference or address and is potentially written.
        -:  288:            DIR_INOUT,  ///< Input to called function, and output to caller. Data is passed by reference or address and is potentially modified.
        -:  289:            DIR_UNKNOWN ///< direction not known / specified
        -:  290:        };
        -:  291:        Direction direction;
        -:  292:    };
        -:  293:
        -:  294:
        -:  295:    struct Function {
        -:  296:        std::map<int, ArgumentChecks> argumentChecks; // argument nr => argument data
        -:  297:        bool use;
        -:  298:        bool leakignore;
        -:  299:        bool isconst;
        -:  300:        bool ispure;
        -:  301:        bool useretval;
        -:  302:        bool ignore;  // ignore functions/macros from a library (gtk, qt etc)
        -:  303:        bool formatstr;
        -:  304:        bool formatstr_scan;
        -:  305:        bool formatstr_secure;
        -:  306:        Function() : use(false), leakignore(false), isconst(false), ispure(false), useretval(false), ignore(false), formatstr(false), formatstr_scan(false), formatstr_secure(false) {}
        -:  307:    };
        -:  308:
        -:  309:    std::map<std::string, Function> functions;
        -:  310:    bool isUse(const std::string& functionName) const;
        -:  311:    bool isLeakIgnore(const std::string& functionName) const;
        -:  312:    bool isFunctionConst(const std::string& functionName, bool pure) const;
        -:  313:    bool isFunctionConst(const Token *ftok) const;
        -:  314:
        -:  315:    bool isboolargbad(const Token *ftok, int argnr) const {
        -:  316:        const ArgumentChecks *arg = getarg(ftok, argnr);
        -:  317:        return arg && arg->notbool;
        -:  318:    }
        -:  319:
        -:  320:    bool isnullargbad(const Token *ftok, int argnr) const;
        -:  321:    bool isuninitargbad(const Token *ftok, int argnr) const;
        -:  322:
        -:  323:    bool isargformatstr(const Token *ftok, int argnr) const {
        -:  324:        const ArgumentChecks *arg = getarg(ftok, argnr);
        -:  325:        return arg && arg->formatstr;
        -:  326:    }
        -:  327:
        -:  328:    bool isargstrz(const Token *ftok, int argnr) const {
        -:  329:        const ArgumentChecks *arg = getarg(ftok, argnr);
        -:  330:        return arg && arg->strz;
        -:  331:    }
        -:  332:
        -:  333:    bool isIntArgValid(const Token *ftok, int argnr, const MathLib::bigint argvalue) const;
        -:  334:    bool isFloatArgValid(const Token *ftok, int argnr, double argvalue) const;
        -:  335:
        -:  336:    const std::string& validarg(const Token *ftok, int argnr) const {
        -:  337:        const ArgumentChecks *arg = getarg(ftok, argnr);
        -:  338:        return arg ? arg->valid : emptyString;
        -:  339:    }
        -:  340:
        -:  341:    const ArgumentChecks::IteratorInfo *getArgIteratorInfo(const Token *ftok, int argnr) const {
        -:  342:        const ArgumentChecks *arg = getarg(ftok, argnr);
        -:  343:        return arg && arg->iteratorInfo.it ? &arg->iteratorInfo : nullptr;
        -:  344:    }
        -:  345:
        -:  346:    bool hasminsize(const Token *ftok) const;
        -:  347:
        -:  348:    const std::vector<ArgumentChecks::MinSize> *argminsizes(const Token *ftok, int argnr) const {
        -:  349:        const ArgumentChecks *arg = getarg(ftok, argnr);
        -:  350:        return arg ? &arg->minsizes : nullptr;
        -:  351:    }
        -:  352:
        -:  353:    ArgumentChecks::Direction getArgDirection(const Token *ftok, int argnr) const {
        -:  354:        const ArgumentChecks *arg = getarg(ftok, argnr);
        -:  355:        return arg ? arg->direction : ArgumentChecks::Direction::DIR_UNKNOWN;
        -:  356:    }
        -:  357:
        -:  358:    bool markupFile(const std::string &path) const;
        -:  359:
        -:  360:    bool processMarkupAfterCode(const std::string &path) const;
        -:  361:
        -:  362:    const std::set<std::string> &markupExtensions() const {
        -:  363:        return mMarkupExtensions;
        -:  364:    }
        -:  365:
        -:  366:    bool reportErrors(const std::string &path) const;
        -:  367:
        -:  368:    bool ignorefunction(const std::string &functionName) const;
        -:  369:
        -:  370:    bool isexecutableblock(const std::string &file, const std::string &token) const;
        -:  371:
        -:  372:    int blockstartoffset(const std::string &file) const;
        -:  373:
        -:  374:    const std::string& blockstart(const std::string &file) const;
        -:  375:    const std::string& blockend(const std::string &file) const;
        -:  376:
        -:  377:    bool iskeyword(const std::string &file, const std::string &keyword) const;
        -:  378:
        -:  379:    bool isexporter(const std::string &prefix) const {
        -:  380:        return mExporters.find(prefix) != mExporters.end();
        -:  381:    }
        -:  382:
        -:  383:    bool isexportedprefix(const std::string &prefix, const std::string &token) const {
        -:  384:        const std::map<std::string, ExportedFunctions>::const_iterator it = mExporters.find(prefix);
        -:  385:        return (it != mExporters.end() && it->second.isPrefix(token));
        -:  386:    }
        -:  387:
        -:  388:    bool isexportedsuffix(const std::string &prefix, const std::string &token) const {
        -:  389:        const std::map<std::string, ExportedFunctions>::const_iterator it = mExporters.find(prefix);
        -:  390:        return (it != mExporters.end() && it->second.isSuffix(token));
        -:  391:    }
        -:  392:
        -:  393:    bool isimporter(const std::string& file, const std::string &importer) const;
        -:  394:
        -:  395:    bool isreflection(const std::string &token) const {
        -:  396:        return mReflection.find(token) != mReflection.end();
        -:  397:    }
        -:  398:
        -:  399:    int reflectionArgument(const std::string &token) const {
        -:  400:        const std::map<std::string, int>::const_iterator it = mReflection.find(token);
        -:  401:        if (it != mReflection.end())
        -:  402:            return it->second;
        -:  403:        return -1;
        -:  404:    }
        -:  405:
        -:  406:    std::set<std::string> returnuninitdata;
        -:  407:    std::vector<std::string> defines; // to provide some library defines
        -:  408:
        -:  409:    std::set<std::string> smartPointers;
        -:  410:    bool isSmartPointer(const Token *tok) const;
        -:  411:
        -:  412:    struct PodType {
        -:  413:        unsigned int   size;
        -:  414:        char           sign;
        -:  415:    };
        -:  416:    const struct PodType *podtype(const std::string &name) const {
        -:  417:        const std::map<std::string, struct PodType>::const_iterator it = mPodTypes.find(name);
        -:  418:        return (it != mPodTypes.end()) ? &(it->second) : nullptr;
        -:  419:    }
        -:  420:
        -:  421:    struct PlatformType {
        -:  422:        PlatformType()
        -:  423:            : _signed(false)
        -:  424:            , _unsigned(false)
        -:  425:            , _long(false)
        -:  426:            , _pointer(false)
        -:  427:            , _ptr_ptr(false)
        -:  428:            , _const_ptr(false) {
        -:  429:        }
        -:  430:        bool operator == (const PlatformType & type) const {
        -:  431:            return (_signed == type._signed &&
        -:  432:                    _unsigned == type._unsigned &&
        -:  433:                    _long == type._long &&
        -:  434:                    _pointer == type._pointer &&
        -:  435:                    _ptr_ptr == type._ptr_ptr &&
        -:  436:                    _const_ptr == type._const_ptr &&
        -:  437:                    mType == type.mType);
        -:  438:        }
        -:  439:        bool operator != (const PlatformType & type) const {
        -:  440:            return !(*this == type);
        -:  441:        }
        -:  442:        std::string mType;
        -:  443:        bool _signed;
        -:  444:        bool _unsigned;
        -:  445:        bool _long;
        -:  446:        bool _pointer;
        -:  447:        bool _ptr_ptr;
        -:  448:        bool _const_ptr;
        -:  449:    };
        -:  450:
        -:  451:    struct Platform {
        -:  452:        const PlatformType *platform_type(const std::string &name) const {
        -:  453:            const std::map<std::string, struct PlatformType>::const_iterator it = mPlatformTypes.find(name);
        -:  454:            return (it != mPlatformTypes.end()) ? &(it->second) : nullptr;
        -:  455:        }
        -:  456:        std::map<std::string, PlatformType> mPlatformTypes;
        -:  457:    };
        -:  458:
        -:  459:    const PlatformType *platform_type(const std::string &name, const std::string & platform) const {
        -:  460:        const std::map<std::string, Platform>::const_iterator it = mPlatforms.find(platform);
        -:  461:        if (it != mPlatforms.end()) {
        -:  462:            const PlatformType * const type = it->second.platform_type(name);
        -:  463:            if (type)
        -:  464:                return type;
        -:  465:        }
        -:  466:
        -:  467:        const std::map<std::string, PlatformType>::const_iterator it2 = mPlatformTypes.find(name);
        -:  468:        return (it2 != mPlatformTypes.end()) ? &(it2->second) : nullptr;
        -:  469:    }
        -:  470:
        -:  471:    /**
        -:  472:     * Get function name for function call
        -:  473:     */
        -:  474:    std::string getFunctionName(const Token *ftok) const;
        -:  475:
        -:  476:    static bool isContainerYield(const Token * const cond, Library::Container::Yield y, const std::string& fallback="");
        -:  477:
        -:  478:private:
        -:  479:    // load a <function> xml node
        -:  480:    Error loadFunction(const tinyxml2::XMLElement * const node, const std::string &name, std::set<std::string> &unknown_elements);
        -:  481:
        -:  482:    class ExportedFunctions {
        -:  483:    public:
        -:  484:        void addPrefix(const std::string& prefix) {
        -:  485:            mPrefixes.insert(prefix);
        -:  486:        }
        -:  487:        void addSuffix(const std::string& suffix) {
        -:  488:            mSuffixes.insert(suffix);
        -:  489:        }
        -:  490:        bool isPrefix(const std::string& prefix) const {
        -:  491:            return (mPrefixes.find(prefix) != mPrefixes.end());
        -:  492:        }
        -:  493:        bool isSuffix(const std::string& suffix) const {
        -:  494:            return (mSuffixes.find(suffix) != mSuffixes.end());
        -:  495:        }
        -:  496:
        -:  497:    private:
        -:  498:        std::set<std::string> mPrefixes;
        -:  499:        std::set<std::string> mSuffixes;
        -:  500:    };
        -:  501:    class CodeBlock {
        -:  502:    public:
        -:  503:        CodeBlock() : mOffset(0) {}
        -:  504:
        -:  505:        void setStart(const char* s) {
        -:  506:            mStart = s;
        -:  507:        }
        -:  508:        void setEnd(const char* e) {
        -:  509:            mEnd = e;
        -:  510:        }
        -:  511:        void setOffset(const int o) {
        -:  512:            mOffset = o;
        -:  513:        }
        -:  514:        void addBlock(const char* blockName) {
        -:  515:            mBlocks.insert(blockName);
        -:  516:        }
        -:  517:        const std::string& start() const {
        -:  518:            return mStart;
        -:  519:        }
        -:  520:        const std::string& end() const {
        -:  521:            return mEnd;
        -:  522:        }
        -:  523:        int offset() const {
        -:  524:            return mOffset;
        -:  525:        }
        -:  526:        bool isBlock(const std::string& blockName) const {
        -:  527:            return mBlocks.find(blockName) != mBlocks.end();
        -:  528:        }
        -:  529:
        -:  530:    private:
        -:  531:        std::string mStart;
        -:  532:        std::string mEnd;
        -:  533:        int mOffset;
        -:  534:        std::set<std::string> mBlocks;
        -:  535:    };
        -:  536:    int mAllocId;
        -:  537:    std::set<std::string> mFiles;
        -:  538:    std::map<std::string, AllocFunc> mAlloc; // allocation functions
        -:  539:    std::map<std::string, AllocFunc> mDealloc; // deallocation functions
        -:  540:    std::map<std::string, AllocFunc> mRealloc; // reallocation functions
        -:  541:    std::map<std::string, bool> mNoReturn; // is function noreturn?
        -:  542:    std::map<std::string, std::string> mReturnValue;
        -:  543:    std::map<std::string, std::string> mReturnValueType;
        -:  544:    std::map<std::string, int> mReturnValueContainer;
        -:  545:    std::map<std::string, std::vector<MathLib::bigint>> mUnknownReturnValues;
        -:  546:    std::map<std::string, bool> mReportErrors;
        -:  547:    std::map<std::string, bool> mProcessAfterCode;
        -:  548:    std::set<std::string> mMarkupExtensions; // file extensions of markup files
        -:  549:    std::map<std::string, std::set<std::string> > mKeywords; // keywords for code in the library
        -:  550:    std::map<std::string, CodeBlock> mExecutableBlocks; // keywords for blocks of executable code
        -:  551:    std::map<std::string, ExportedFunctions> mExporters; // keywords that export variables/functions to libraries (meta-code/macros)
        -:  552:    std::map<std::string, std::set<std::string> > mImporters; // keywords that import variables/functions
        -:  553:    std::map<std::string, int> mReflection; // invocation of reflection
        -:  554:    std::map<std::string, struct PodType> mPodTypes; // pod types
        -:  555:    std::map<std::string, PlatformType> mPlatformTypes; // platform independent typedefs
        -:  556:    std::map<std::string, Platform> mPlatforms; // platform dependent typedefs
        -:  557:
        -:  558:    const ArgumentChecks * getarg(const Token *ftok, int argnr) const;
        -:  559:
        -:  560:    std::string getFunctionName(const Token *ftok, bool *error) const;
        -:  561:
        -:  562:    static const AllocFunc* getAllocDealloc(const std::map<std::string, AllocFunc> &data, const std::string &name) {
        -:  563:        const std::map<std::string, AllocFunc>::const_iterator it = data.find(name);
        -:  564:        return (it == data.end()) ? nullptr : &it->second;
        -:  565:    }
        -:  566:};
        -:  567:
        -:  568:CPPCHECKLIB const Library::Container * getLibraryContainer(const Token * tok);
        -:  569:
        -:  570:/// @}
        -:  571://---------------------------------------------------------------------------
        -:  572:#endif // libraryH
