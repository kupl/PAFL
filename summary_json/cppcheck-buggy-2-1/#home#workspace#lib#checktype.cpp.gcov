        -:    0:Source:/home/workspace/lib/checktype.cpp
        -:    0:Graph:/home/workspace/build/lib/CMakeFiles/lib_objs.dir/checktype.gcno
        -:    0:Data:/home/workspace/build/lib/CMakeFiles/lib_objs.dir/checktype.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*
        -:    2: * Cppcheck - A tool for static C/C++ code analysis
        -:    3: * Copyright (C) 2007-2019 Cppcheck team.
        -:    4: *
        -:    5: * This program is free software: you can redistribute it and/or modify
        -:    6: * it under the terms of the GNU General Public License as published by
        -:    7: * the Free Software Foundation, either version 3 of the License, or
        -:    8: * (at your option) any later version.
        -:    9: *
        -:   10: * This program is distributed in the hope that it will be useful,
        -:   11: * but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   12: * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   13: * GNU General Public License for more details.
        -:   14: *
        -:   15: * You should have received a copy of the GNU General Public License
        -:   16: * along with this program.  If not, see <http://www.gnu.org/licenses/>.
        -:   17: */
        -:   18:
        -:   19:
        -:   20://---------------------------------------------------------------------------
        -:   21:#include "checktype.h"
        -:   22:
        -:   23:#include "errorlogger.h"
        -:   24:#include "mathlib.h"
        -:   25:#include "platform.h"
        -:   26:#include "settings.h"
        -:   27:#include "symboldatabase.h"
        -:   28:#include "token.h"
        -:   29:#include "tokenize.h"
        -:   30:
        -:   31:#include <cstddef>
        -:   32:#include <list>
        -:   33:#include <ostream>
        -:   34:#include <stack>
        -:   35://---------------------------------------------------------------------------
        -:   36:
        -:   37:// Register this check class (by creating a static instance of it)
        -:   38:namespace {
        1:   39:    CheckType instance;
call    0 returned 100%
call    1 returned 100%
        -:   40:}
        -:   41:
        -:   42://---------------------------------------------------------------------------
        -:   43:// Checking for shift by too many bits
        -:   44://---------------------------------------------------------------------------
        -:   45://
        -:   46:
        -:   47:// CWE ids used:
        1:   48:static const struct CWE CWE195(195U);   // Signed to Unsigned Conversion Error
call    0 returned 100%
        1:   49:static const struct CWE CWE197(197U);   // Numeric Truncation Error
call    0 returned 100%
        1:   50:static const struct CWE CWE758(758U);   // Reliance on Undefined, Unspecified, or Implementation-Defined Behavior
call    0 returned 100%
        1:   51:static const struct CWE CWE190(190U);   // Integer Overflow or Wraparound
call    0 returned 100%
        -:   52:
        -:   53:
function _ZN9CheckType23checkTooBigBitwiseShiftEv called 0 returned 0% blocks executed 0%
    #####:   54:void CheckType::checkTooBigBitwiseShift()
        -:   55:{
        -:   56:    // unknown sizeof(int) => can't run this checker
    #####:   57:    if (mSettings->platformType == Settings::Unspecified)
branch  0 never executed
branch  1 never executed
    #####:   58:        return;
        -:   59:
    #####:   60:    for (const Token *tok = mTokenizer->tokens(); tok; tok = tok->next()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:   61:        // C++ and macro: OUT(x<<y)
    #####:   62:        if (mTokenizer->isCPP() && Token::Match(tok, "[;{}] %name% (") && Token::simpleMatch(tok->linkAt(2), ") ;") && tok->next()->isUpperCaseName() && !tok->next()->function())
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
call    7 never executed
branch  8 never executed
branch  9 never executed
call   10 never executed
call   11 never executed
branch 12 never executed
branch 13 never executed
call   14 never executed
call   15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
    #####:   63:            tok = tok->linkAt(2);
call    0 never executed
        -:   64:
    #####:   65:        if (!tok->astOperand1() || !tok->astOperand2())
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:   66:            continue;
        -:   67:
    #####:   68:        if (!Token::Match(tok, "<<|>>|<<=|>>="))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   69:            continue;
        -:   70:
        -:   71:        // get number of bits of lhs
    #####:   72:        const ValueType * const lhstype = tok->astOperand1()->valueType();
call    0 never executed
call    1 never executed
    #####:   73:        if (!lhstype || !lhstype->isIntegral() || lhstype->pointer >= 1)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
    #####:   74:            continue;
        -:   75:        // C11 Standard, section 6.5.7 Bitwise shift operators, states:
        -:   76:        //   The integer promotions are performed on each of the operands.
        -:   77:        //   The type of the result is that of the promoted left operand.
        -:   78:        int lhsbits;
    #####:   79:        if ((lhstype->type == ValueType::Type::CHAR) ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:   80:            (lhstype->type == ValueType::Type::SHORT) ||
branch  0 never executed
branch  1 never executed
    #####:   81:            (lhstype->type == ValueType::Type::WCHAR_T) ||
branch  0 never executed
branch  1 never executed
    #####:   82:            (lhstype->type == ValueType::Type::BOOL) ||
branch  0 never executed
branch  1 never executed
    #####:   83:            (lhstype->type == ValueType::Type::INT))
    #####:   84:            lhsbits = mSettings->int_bit;
    #####:   85:        else if (lhstype->type == ValueType::Type::LONG)
branch  0 never executed
branch  1 never executed
    #####:   86:            lhsbits = mSettings->long_bit;
    #####:   87:        else if (lhstype->type == ValueType::Type::LONGLONG)
branch  0 never executed
branch  1 never executed
    #####:   88:            lhsbits = mSettings->long_long_bit;
        -:   89:        else
    #####:   90:            continue;
        -:   91:
        -:   92:        // Get biggest rhs value. preferably a value which doesn't have 'condition'.
    #####:   93:        const ValueFlow::Value * value = tok->astOperand2()->getValueGE(lhsbits, mSettings);
call    0 never executed
call    1 never executed
    #####:   94:        if (value && mSettings->isEnabled(value, false))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:   95:            tooBigBitwiseShiftError(tok, lhsbits, *value);
call    0 never executed
    #####:   96:        else if (lhstype->sign == ValueType::Sign::SIGNED) {
branch  0 never executed
branch  1 never executed
    #####:   97:            value = tok->astOperand2()->getValueGE(lhsbits-1, mSettings);
call    0 never executed
call    1 never executed
    #####:   98:            if (value && mSettings->isEnabled(value, false))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:   99:                tooBigSignedBitwiseShiftError(tok, lhsbits, *value);
call    0 never executed
        -:  100:        }
        -:  101:    }
        -:  102:}
        -:  103:
function _ZN9CheckType23tooBigBitwiseShiftErrorEPK5TokeniRKN9ValueFlow5ValueE called 0 returned 0% blocks executed 0%
    #####:  104:void CheckType::tooBigBitwiseShiftError(const Token *tok, int lhsbits, const ValueFlow::Value &rhsbits)
        -:  105:{
    #####:  106:    const char id[] = "shiftTooManyBits";
        -:  107:
    #####:  108:    if (!tok) {
branch  0 never executed
branch  1 never executed
    #####:  109:        reportError(tok, Severity::error, id, "Shifting 32-bit value by 40 bits is undefined behaviour", CWE758, false);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  110:        return;
        -:  111:    }
        -:  112:
    #####:  113:    const ErrorPath errorPath = getErrorPath(tok, &rhsbits, "Shift");
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
call   12 never executed
        -:  114:
    #####:  115:    std::ostringstream errmsg;
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
    #####:  116:    errmsg << "Shifting " << lhsbits << "-bit value by " << rhsbits.intvalue << " bits is undefined behaviour";
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
call    9 never executed
branch 10 never executed
branch 11 never executed
call   12 never executed
branch 13 never executed
branch 14 never executed
    #####:  117:    if (rhsbits.condition)
branch  0 never executed
branch  1 never executed
    #####:  118:        errmsg << ". See condition at line " << rhsbits.condition->linenr() << ".";
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
branch  8 never executed
branch  9 never executed
        -:  119:
    #####:  120:    reportError(errorPath, rhsbits.errorSeverity() ? Severity::error : Severity::warning, id, errmsg.str(), CWE758, rhsbits.isInconclusive());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
branch  8 never executed
branch  9 never executed
call   10 never executed
call   11 never executed
        -:  121:}
        -:  122:
function _ZN9CheckType29tooBigSignedBitwiseShiftErrorEPK5TokeniRKN9ValueFlow5ValueE called 0 returned 0% blocks executed 0%
    #####:  123:void CheckType::tooBigSignedBitwiseShiftError(const Token *tok, int lhsbits, const ValueFlow::Value &rhsbits)
        -:  124:{
    #####:  125:    const char id[] = "shiftTooManyBitsSigned";
        -:  126:
    #####:  127:    const bool cpp14 = mSettings->standards.cpp >= Standards::CPP14;
        -:  128:
    #####:  129:    std::string behaviour = "undefined";
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
    #####:  130:    if (cpp14)
branch  0 never executed
branch  1 never executed
    #####:  131:        behaviour = "implementation-defined";
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  132:    if (!tok) {
branch  0 never executed
branch  1 never executed
    #####:  133:        reportError(tok, Severity::error, id, "Shifting signed 32-bit value by 31 bits is " + behaviour + " behaviour", CWE758, false);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
call   12 never executed
call   13 never executed
    #####:  134:        return;
        -:  135:    }
        -:  136:
    #####:  137:    const ErrorPath errorPath = getErrorPath(tok, &rhsbits, "Shift");
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
branch 10 never executed
branch 11 never executed
call   12 never executed
call   13 never executed
        -:  138:
    #####:  139:    std::ostringstream errmsg;
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
    #####:  140:    errmsg << "Shifting signed " << lhsbits << "-bit value by " << rhsbits.intvalue << " bits is " + behaviour + " behaviour";
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
call    9 never executed
branch 10 never executed
branch 11 never executed
call   12 never executed
branch 13 never executed
branch 14 never executed
call   15 never executed
branch 16 never executed
branch 17 never executed
call   18 never executed
branch 19 never executed
branch 20 never executed
call   21 never executed
call   22 never executed
call   23 never executed
call   24 never executed
    #####:  141:    if (rhsbits.condition)
branch  0 never executed
branch  1 never executed
    #####:  142:        errmsg << ". See condition at line " << rhsbits.condition->linenr() << ".";
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
branch  8 never executed
branch  9 never executed
        -:  143:
    #####:  144:    Severity::SeverityType severity = rhsbits.errorSeverity() ? Severity::error : Severity::warning;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  145:    if (cpp14)
branch  0 never executed
branch  1 never executed
    #####:  146:        severity = Severity::portability;
        -:  147:
    #####:  148:    if ((severity == Severity::portability) && !mSettings->isEnabled(Settings::PORTABILITY))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:  149:        return;
    #####:  150:    reportError(errorPath, severity, id, errmsg.str(), CWE758, rhsbits.isInconclusive());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
call    8 never executed
branch  9 never executed
branch 10 never executed
call   11 never executed
        -:  151:}
        -:  152:
        -:  153://---------------------------------------------------------------------------
        -:  154:// Checking for integer overflow
        -:  155://---------------------------------------------------------------------------
        -:  156:
function _ZN9CheckType20checkIntegerOverflowEv called 0 returned 0% blocks executed 0%
    #####:  157:void CheckType::checkIntegerOverflow()
        -:  158:{
        -:  159:    // unknown sizeof(int) => can't run this checker
    #####:  160:    if (mSettings->platformType == Settings::Unspecified || mSettings->int_bit >= MathLib::bigint_bits)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  161:        return;
        -:  162:
    #####:  163:    for (const Token *tok = mTokenizer->tokens(); tok; tok = tok->next()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  164:        if (!tok->isArithmeticalOp())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  165:            continue;
        -:  166:
        -:  167:        // is result signed integer?
    #####:  168:        const ValueType *vt = tok->valueType();
call    0 never executed
    #####:  169:        if (!vt || !vt->isIntegral() || vt->sign != ValueType::Sign::SIGNED)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
    #####:  170:            continue;
        -:  171:
        -:  172:        unsigned int bits;
    #####:  173:        if (vt->type == ValueType::Type::INT)
branch  0 never executed
branch  1 never executed
    #####:  174:            bits = mSettings->int_bit;
    #####:  175:        else if (vt->type == ValueType::Type::LONG)
branch  0 never executed
branch  1 never executed
    #####:  176:            bits = mSettings->long_bit;
    #####:  177:        else if (vt->type == ValueType::Type::LONGLONG)
branch  0 never executed
branch  1 never executed
    #####:  178:            bits = mSettings->long_long_bit;
        -:  179:        else
    #####:  180:            continue;
        -:  181:
    #####:  182:        if (bits >= MathLib::bigint_bits)
branch  0 never executed
branch  1 never executed
    #####:  183:            continue;
        -:  184:
        -:  185:        // max value according to platform settings.
    #####:  186:        const MathLib::bigint maxvalue = (((MathLib::bigint)1) << (bits - 1)) - 1;
        -:  187:
        -:  188:        // is there a overflow result value
    #####:  189:        const ValueFlow::Value *value = tok->getValueGE(maxvalue + 1, mSettings);
call    0 never executed
    #####:  190:        if (!value)
branch  0 never executed
branch  1 never executed
    #####:  191:            value = tok->getValueLE(-maxvalue - 2, mSettings);
call    0 never executed
    #####:  192:        if (!value || !mSettings->isEnabled(value,false))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:  193:            continue;
        -:  194:
        -:  195:        // For left shift, it's common practice to shift into the sign bit
    #####:  196:        if (tok->str() == "<<" && value->intvalue > 0 && value->intvalue < (((MathLib::bigint)1) << bits))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####:  197:            continue;
        -:  198:
    #####:  199:        integerOverflowError(tok, *value);
call    0 never executed
        -:  200:    }
        -:  201:}
        -:  202:
function _ZN9CheckType20integerOverflowErrorEPK5TokenRKN9ValueFlow5ValueE called 0 returned 0% blocks executed 0%
    #####:  203:void CheckType::integerOverflowError(const Token *tok, const ValueFlow::Value &value)
        -:  204:{
    #####:  205:    const std::string expr(tok ? tok->expressionString() : "");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
call   11 never executed
call   12 never executed
branch 13 never executed
branch 14 never executed
call   15 never executed
call   16 never executed
        -:  206:
    #####:  207:    std::string msg;
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  208:    if (value.condition)
branch  0 never executed
branch  1 never executed
    #####:  209:        msg = ValueFlow::eitherTheConditionIsRedundant(value.condition) +
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
    #####:  210:              " or there is signed integer overflow for expression '" + expr + "'.";
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
        -:  211:    else
    #####:  212:        msg = "Signed integer overflow for expression '" + expr + "'.";
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
        -:  213:
    #####:  214:    if (value.safe)
branch  0 never executed
branch  1 never executed
    #####:  215:        msg = "Safe checks: " + msg;
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
        -:  216:
    #####:  217:    reportError(getErrorPath(tok, &value, "Integer overflow"),
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
branch  8 never executed
branch  9 never executed
call   10 never executed
branch 11 never executed
branch 12 never executed
call   13 never executed
call   14 never executed
call   15 never executed
call   16 never executed
call   17 never executed
call   18 never executed
    #####:  218:                value.errorSeverity() ? Severity::error : Severity::warning,
call    0 never executed
    #####:  219:                getMessageId(value, "integerOverflow").c_str(),
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
        -:  220:                msg,
        -:  221:                CWE190,
    #####:  222:                value.isInconclusive());
call    0 never executed
    #####:  223:}
        -:  224:
        -:  225://---------------------------------------------------------------------------
        -:  226:// Checking for sign conversion when operand can be negative
        -:  227://---------------------------------------------------------------------------
        -:  228:
function _ZN9CheckType19checkSignConversionEv called 0 returned 0% blocks executed 0%
    #####:  229:void CheckType::checkSignConversion()
        -:  230:{
    #####:  231:    if (!mSettings->isEnabled(Settings::WARNING))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  232:        return;
        -:  233:
    #####:  234:    for (const Token *tok = mTokenizer->tokens(); tok; tok = tok->next()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  235:        if (!tok->isArithmeticalOp() || Token::Match(tok,"+|-"))
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####:  236:            continue;
        -:  237:
        -:  238:        // Is result unsigned?
    #####:  239:        if (!(tok->valueType() && tok->valueType()->sign == ValueType::Sign::UNSIGNED))
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:  240:            continue;
        -:  241:
        -:  242:        // Check if an operand can be negative..
    #####:  243:        std::stack<const Token *> tokens;
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
    #####:  244:        tokens.push(tok->astOperand1());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  245:        tokens.push(tok->astOperand2());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  246:        while (!tokens.empty()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  247:            const Token *tok1 = tokens.top();
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  248:            tokens.pop();
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  249:            if (!tok1)
branch  0 never executed
branch  1 never executed
    #####:  250:                continue;
    #####:  251:            const ValueFlow::Value *negativeValue = tok1->getValueLE(-1,mSettings);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  252:            if (!negativeValue)
branch  0 never executed
branch  1 never executed
    #####:  253:                continue;
    #####:  254:            if (tok1->valueType() && tok1->valueType()->sign != ValueType::Sign::UNSIGNED)
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:  255:                signConversionError(tok1, negativeValue, tok1->isNumber());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  256:        }
        -:  257:    }
        -:  258:}
        -:  259:
function _ZN9CheckType19signConversionErrorEPK5TokenPKN9ValueFlow5ValueEb called 0 returned 0% blocks executed 0%
    #####:  260:void CheckType::signConversionError(const Token *tok, const ValueFlow::Value *negativeValue, const bool constvalue)
        -:  261:{
    #####:  262:    const std::string expr(tok ? tok->expressionString() : "var");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
call   11 never executed
call   12 never executed
branch 13 never executed
branch 14 never executed
call   15 never executed
call   16 never executed
        -:  263:
    #####:  264:    std::ostringstream msg;
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
    #####:  265:    if (tok && tok->isName())
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
    #####:  266:        msg << "$symbol:" << expr << "\n";
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
    #####:  267:    if (constvalue)
branch  0 never executed
branch  1 never executed
    #####:  268:        msg << "Expression '" << expr << "' has a negative value. That is converted to an unsigned value and used in an unsigned calculation.";
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
        -:  269:    else
    #####:  270:        msg << "Expression '" << expr << "' can have a negative value. That is converted to an unsigned value and used in an unsigned calculation.";
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
        -:  271:
    #####:  272:    if (!negativeValue)
branch  0 never executed
branch  1 never executed
    #####:  273:        reportError(tok, Severity::warning, "signConversion", msg.str(), CWE195, false);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
call    7 never executed
        -:  274:    else {
    #####:  275:        const ErrorPath &errorPath = getErrorPath(tok,negativeValue,"Negative value is converted to an unsigned value");
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
call   12 never executed
    #####:  276:        reportError(errorPath,
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  277:                    Severity::warning,
    #####:  278:                    Check::getMessageId(*negativeValue, "signConversion").c_str(),
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
    #####:  279:                    msg.str(),
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
        -:  280:                    CWE195,
    #####:  281:                    negativeValue->isInconclusive());
call    0 never executed
        -:  282:    }
    #####:  283:}
        -:  284:
        -:  285:
        -:  286://---------------------------------------------------------------------------
        -:  287:// Checking for long cast of int result   const long x = var1 * var2;
        -:  288://---------------------------------------------------------------------------
        -:  289:
function _ZN9CheckType13checkLongCastEv called 0 returned 0% blocks executed 0%
    #####:  290:void CheckType::checkLongCast()
        -:  291:{
    #####:  292:    if (!mSettings->isEnabled(Settings::STYLE))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  293:        return;
        -:  294:
        -:  295:    // Assignments..
    #####:  296:    for (const Token *tok = mTokenizer->tokens(); tok; tok = tok->next()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  297:        if (tok->str() != "=" || !Token::Match(tok->astOperand2(), "*|<<"))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####:  298:            continue;
        -:  299:
    #####:  300:        if (tok->astOperand2()->hasKnownIntValue()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  301:            const ValueFlow::Value &v = tok->astOperand2()->values().front();
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  302:            if (mSettings->isIntValue(v.intvalue))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  303:                continue;
        -:  304:        }
        -:  305:
    #####:  306:        const ValueType *lhstype = tok->astOperand1() ? tok->astOperand1()->valueType() : nullptr;
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
    #####:  307:        const ValueType *rhstype = tok->astOperand2()->valueType();
call    0 never executed
call    1 never executed
        -:  308:
    #####:  309:        if (!lhstype || !rhstype)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  310:            continue;
        -:  311:
        -:  312:        // assign int result to long/longlong const nonpointer?
    #####:  313:        if (rhstype->type == ValueType::Type::INT &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  314:            rhstype->pointer == 0U &&
branch  0 never executed
branch  1 never executed
    #####:  315:            rhstype->originalTypeName.empty() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  316:            (lhstype->type == ValueType::Type::LONG || lhstype->type == ValueType::Type::LONGLONG) &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  317:            lhstype->pointer == 0U &&
branch  0 never executed
branch  1 never executed
    #####:  318:            lhstype->constness == 1U &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  319:            lhstype->originalTypeName.empty())
call    0 never executed
    #####:  320:            longCastAssignError(tok);
call    0 never executed
        -:  321:    }
        -:  322:
        -:  323:    // Return..
    #####:  324:    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
call    0 never executed
    #####:  325:    for (const Scope * scope : symbolDatabase->functionScopes) {
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
        -:  326:
        -:  327:        // function must return long data
    #####:  328:        const Token * def = scope->classDef;
    #####:  329:        bool islong = false;
    #####:  330:        while (Token::Match(def, "%type%|::")) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  331:            if (def->str() == "long" && def->originalName().empty()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####:  332:                islong = true;
    #####:  333:                break;
        -:  334:            }
    #####:  335:            def = def->previous();
call    0 never executed
        -:  336:        }
    #####:  337:        if (!islong)
branch  0 never executed
branch  1 never executed
    #####:  338:            continue;
        -:  339:
        -:  340:        // return statements
    #####:  341:        const Token *ret = nullptr;
    #####:  342:        for (const Token *tok = scope->bodyStart; tok != scope->bodyEnd; tok = tok->next()) {
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  343:            if (tok->str() == "return") {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  344:                if (Token::Match(tok->astOperand1(), "<<|*")) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  345:                    const ValueType *type = tok->astOperand1()->valueType();
call    0 never executed
call    1 never executed
    #####:  346:                    if (type && type->type == ValueType::Type::INT && type->pointer == 0U && type->originalTypeName.empty())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
    #####:  347:                        ret = tok;
        -:  348:                }
        -:  349:                // All return statements must have problem otherwise no warning
    #####:  350:                if (ret != tok) {
branch  0 never executed
branch  1 never executed
    #####:  351:                    ret = nullptr;
    #####:  352:                    break;
        -:  353:                }
        -:  354:            }
        -:  355:        }
        -:  356:
    #####:  357:        if (ret)
branch  0 never executed
branch  1 never executed
    #####:  358:            longCastReturnError(ret);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  359:    }
        -:  360:}
        -:  361:
function _ZN9CheckType19longCastAssignErrorEPK5Token called 0 returned 0% blocks executed 0%
    #####:  362:void CheckType::longCastAssignError(const Token *tok)
        -:  363:{
    #####:  364:    reportError(tok,
call    0 never executed
        -:  365:                Severity::style,
        -:  366:                "truncLongCastAssignment",
        -:  367:                "int result is assigned to long variable. If the variable is long to avoid loss of information, then you have loss of information.\n"
        -:  368:                "int result is assigned to long variable. If the variable is long to avoid loss of information, then there is loss of information. To avoid loss of information you must cast a calculation operand to long, for example 'l = a * b;' => 'l = (long)a * b;'.", CWE197, false);
    #####:  369:}
        -:  370:
function _ZN9CheckType19longCastReturnErrorEPK5Token called 0 returned 0% blocks executed 0%
    #####:  371:void CheckType::longCastReturnError(const Token *tok)
        -:  372:{
    #####:  373:    reportError(tok,
call    0 never executed
        -:  374:                Severity::style,
        -:  375:                "truncLongCastReturn",
        -:  376:                "int result is returned as long value. If the return value is long to avoid loss of information, then you have loss of information.\n"
        -:  377:                "int result is returned as long value. If the return value is long to avoid loss of information, then there is loss of information. To avoid loss of information you must cast a calculation operand to long, for example 'return a*b;' => 'return (long)a*b'.", CWE197, false);
    #####:  378:}
        -:  379:
        -:  380://---------------------------------------------------------------------------
        -:  381:// Checking for float to integer overflow
        -:  382://---------------------------------------------------------------------------
        -:  383:
function _ZN9CheckType27checkFloatToIntegerOverflowEv called 0 returned 0% blocks executed 0%
    #####:  384:void CheckType::checkFloatToIntegerOverflow()
        -:  385:{
    #####:  386:    for (const Token *tok = mTokenizer->tokens(); tok; tok = tok->next()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  387:        const ValueType *vtint, *vtfloat;
        -:  388:        const std::list<ValueFlow::Value> *floatValues;
        -:  389:
        -:  390:        // Explicit cast
    #####:  391:        if (Token::Match(tok, "( %name%") && tok->astOperand1() && !tok->astOperand2()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
    #####:  392:            vtint = tok->valueType();
call    0 never executed
    #####:  393:            vtfloat = tok->astOperand1()->valueType();
call    0 never executed
call    1 never executed
    #####:  394:            floatValues = &tok->astOperand1()->values();
call    0 never executed
call    1 never executed
    #####:  395:            checkFloatToIntegerOverflow(tok, vtint, vtfloat, floatValues);
call    0 never executed
        -:  396:        }
        -:  397:
        -:  398:        // Assignment
    #####:  399:        else if (tok->str() == "=" && tok->astOperand1() && tok->astOperand2()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
    #####:  400:            vtint = tok->astOperand1()->valueType();
call    0 never executed
call    1 never executed
    #####:  401:            vtfloat = tok->astOperand2()->valueType();
call    0 never executed
call    1 never executed
    #####:  402:            floatValues = &tok->astOperand2()->values();
call    0 never executed
call    1 never executed
    #####:  403:            checkFloatToIntegerOverflow(tok, vtint, vtfloat, floatValues);
call    0 never executed
        -:  404:        }
        -:  405:
    #####:  406:        else if (tok->str() == "return" && tok->astOperand1() && tok->astOperand1()->valueType() && tok->astOperand1()->valueType()->isFloat()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
call    8 never executed
branch  9 never executed
branch 10 never executed
call   11 never executed
call   12 never executed
call   13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
    #####:  407:            const Scope *scope = tok->scope();
call    0 never executed
    #####:  408:            while (scope && scope->type != Scope::ScopeType::eLambda && scope->type != Scope::ScopeType::eFunction)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  409:                scope = scope->nestedIn;
    #####:  410:            if (scope && scope->type == Scope::ScopeType::eFunction && scope->function && scope->function->retDef) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:  411:                const ValueType &valueType = ValueType::parseDecl(scope->function->retDef, mSettings);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
    #####:  412:                vtfloat = tok->astOperand1()->valueType();
call    0 never executed
call    1 never executed
    #####:  413:                floatValues = &tok->astOperand1()->values();
call    0 never executed
call    1 never executed
    #####:  414:                checkFloatToIntegerOverflow(tok, &valueType, vtfloat, floatValues);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  415:            }
        -:  416:        }
        -:  417:    }
    #####:  418:}
        -:  419:
function _ZN9CheckType27checkFloatToIntegerOverflowEPK5TokenPK9ValueTypeS5_PKNSt7__debug4listIN9ValueFlow5ValueESaIS9_EEE called 0 returned 0% blocks executed 0%
    #####:  420:void CheckType::checkFloatToIntegerOverflow(const Token *tok, const ValueType *vtint, const ValueType *vtfloat, const std::list<ValueFlow::Value> *floatValues)
        -:  421:{
        -:  422:    // Conversion of float to integer?
    #####:  423:    if (!vtint || !vtint->isIntegral())
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:  424:        return;
    #####:  425:    if (!vtfloat || !vtfloat->isFloat())
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:  426:        return;
        -:  427:
    #####:  428:    for (const ValueFlow::Value &f : *floatValues) {
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
    #####:  429:        if (f.valueType != ValueFlow::Value::ValueType::FLOAT)
branch  0 never executed
branch  1 never executed
    #####:  430:            continue;
    #####:  431:        if (!mSettings->isEnabled(&f, false))
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  432:            continue;
    #####:  433:        if (f.floatValue > ~0ULL)
branch  0 never executed
branch  1 never executed
    #####:  434:            floatToIntegerOverflowError(tok, f);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  435:        else if ((-f.floatValue) > (1ULL<<62))
branch  0 never executed
branch  1 never executed
    #####:  436:            floatToIntegerOverflowError(tok, f);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  437:        else if (mSettings->platformType != Settings::Unspecified) {
branch  0 never executed
branch  1 never executed
    #####:  438:            int bits = 0;
    #####:  439:            if (vtint->type == ValueType::Type::CHAR)
branch  0 never executed
branch  1 never executed
    #####:  440:                bits = mSettings->char_bit;
    #####:  441:            else if (vtint->type == ValueType::Type::SHORT)
branch  0 never executed
branch  1 never executed
    #####:  442:                bits = mSettings->short_bit;
    #####:  443:            else if (vtint->type == ValueType::Type::INT)
branch  0 never executed
branch  1 never executed
    #####:  444:                bits = mSettings->int_bit;
    #####:  445:            else if (vtint->type == ValueType::Type::LONG)
branch  0 never executed
branch  1 never executed
    #####:  446:                bits = mSettings->long_bit;
    #####:  447:            else if (vtint->type == ValueType::Type::LONGLONG)
branch  0 never executed
branch  1 never executed
    #####:  448:                bits = mSettings->long_long_bit;
        -:  449:            else
    #####:  450:                continue;
    #####:  451:            if (bits < MathLib::bigint_bits && f.floatValue >= (((MathLib::biguint)1) << bits))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  452:                floatToIntegerOverflowError(tok, f);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  453:        }
        -:  454:    }
        -:  455:}
        -:  456:
function _ZN9CheckType27floatToIntegerOverflowErrorEPK5TokenRKN9ValueFlow5ValueE called 0 returned 0% blocks executed 0%
    #####:  457:void CheckType::floatToIntegerOverflowError(const Token *tok, const ValueFlow::Value &value)
        -:  458:{
    #####:  459:    std::ostringstream errmsg;
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
    #####:  460:    errmsg << "Undefined behaviour: float (" << value.floatValue << ") to integer conversion overflow.";
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
    #####:  461:    reportError(getErrorPath(tok, &value, "float to integer conversion"),
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
call    9 never executed
branch 10 never executed
branch 11 never executed
call   12 never executed
call   13 never executed
call   14 never executed
call   15 never executed
call   16 never executed
call   17 never executed
    #####:  462:                value.errorSeverity() ? Severity::error : Severity::warning,
call    0 never executed
        -:  463:                "floatConversionOverflow",
    #####:  464:                errmsg.str(), CWE190, value.isInconclusive());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
function _GLOBAL__sub_I__ZN9CheckType23checkTooBigBitwiseShiftEv called 1 returned 100% blocks executed 100%
function _Z41__static_initialization_and_destruction_0ii called 1 returned 100% blocks executed 100%
        3:  465:}
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
