        -:    0:Source:/home/workspace/lib/checkother.cpp
        -:    0:Graph:/home/workspace/build/lib/CMakeFiles/lib_objs.dir/checkother.gcno
        -:    0:Data:/home/workspace/build/lib/CMakeFiles/lib_objs.dir/checkother.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*
        -:    2: * Cppcheck - A tool for static C/C++ code analysis
        -:    3: * Copyright (C) 2007-2019 Cppcheck team.
        -:    4: *
        -:    5: * This program is free software: you can redistribute it and/or modify
        -:    6: * it under the terms of the GNU General Public License as published by
        -:    7: * the Free Software Foundation, either version 3 of the License, or
        -:    8: * (at your option) any later version.
        -:    9: *
        -:   10: * This program is distributed in the hope that it will be useful,
        -:   11: * but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   12: * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   13: * GNU General Public License for more details.
        -:   14: *
        -:   15: * You should have received a copy of the GNU General Public License
        -:   16: * along with this program.  If not, see <http://www.gnu.org/licenses/>.
        -:   17: */
        -:   18:
        -:   19:
        -:   20://---------------------------------------------------------------------------
        -:   21:#include "checkother.h"
        -:   22:#include "checkuninitvar.h" // CheckUninitVar::isVariableUsage
        -:   23:
        -:   24:#include "astutils.h"
        -:   25:#include "errorlogger.h"
        -:   26:#include "library.h"
        -:   27:#include "mathlib.h"
        -:   28:#include "settings.h"
        -:   29:#include "standards.h"
        -:   30:#include "symboldatabase.h"
        -:   31:#include "token.h"
        -:   32:#include "tokenize.h"
        -:   33:#include "utils.h"
        -:   34:
        -:   35:#include <algorithm> // find_if()
        -:   36:#include <list>
        -:   37:#include <map>
        -:   38:#include <ostream>
        -:   39:#include <set>
        -:   40:#include <utility>
        -:   41://---------------------------------------------------------------------------
        -:   42:
        -:   43:// Register this check class (by creating a static instance of it)
        -:   44:namespace {
        1:   45:    CheckOther instance;
call    0 returned 100%
call    1 returned 100%
        -:   46:}
        -:   47:
        1:   48:static const struct CWE CWE128(128U);   // Wrap-around Error
call    0 returned 100%
        1:   49:static const struct CWE CWE131(131U);   // Incorrect Calculation of Buffer Size
call    0 returned 100%
        1:   50:static const struct CWE CWE197(197U);   // Numeric Truncation Error
call    0 returned 100%
        1:   51:static const struct CWE CWE362(362U);   // Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')
call    0 returned 100%
        1:   52:static const struct CWE CWE369(369U);   // Divide By Zero
call    0 returned 100%
        1:   53:static const struct CWE CWE398(398U);   // Indicator of Poor Code Quality
call    0 returned 100%
        1:   54:static const struct CWE CWE475(475U);   // Undefined Behavior for Input to API
call    0 returned 100%
        1:   55:static const struct CWE CWE482(482U);   // Comparing instead of Assigning
call    0 returned 100%
        1:   56:static const struct CWE CWE561(561U);   // Dead Code
call    0 returned 100%
        1:   57:static const struct CWE CWE563(563U);   // Assignment to Variable without Use ('Unused Variable')
call    0 returned 100%
        1:   58:static const struct CWE CWE570(570U);   // Expression is Always False
call    0 returned 100%
        1:   59:static const struct CWE CWE571(571U);   // Expression is Always True
call    0 returned 100%
        1:   60:static const struct CWE CWE672(672U);   // Operation on a Resource after Expiration or Release
call    0 returned 100%
        1:   61:static const struct CWE CWE628(628U);   // Function Call with Incorrectly Specified Arguments
call    0 returned 100%
        1:   62:static const struct CWE CWE683(683U);   // Function Call With Incorrect Order of Arguments
call    0 returned 100%
        1:   63:static const struct CWE CWE686(686U);   // Function Call With Incorrect Argument Type
call    0 returned 100%
        1:   64:static const struct CWE CWE704(704U);   // Incorrect Type Conversion or Cast
call    0 returned 100%
        1:   65:static const struct CWE CWE758(758U);   // Reliance on Undefined, Unspecified, or Implementation-Defined Behavior
call    0 returned 100%
        1:   66:static const struct CWE CWE768(768U);   // Incorrect Short Circuit Evaluation
call    0 returned 100%
        1:   67:static const struct CWE CWE783(783U);   // Operator Precedence Logic Error
call    0 returned 100%
        -:   68:
        -:   69://----------------------------------------------------------------------------------
        -:   70:// The return value of fgetc(), getc(), ungetc(), getchar() etc. is an integer value.
        -:   71:// If this return value is stored in a character variable and then compared
        -:   72:// to EOF, which is an integer, the comparison maybe be false.
        -:   73://
        -:   74:// Reference:
        -:   75:// - Ticket #160
        -:   76:// - http://www.cplusplus.com/reference/cstdio/fgetc/
        -:   77:// - http://www.cplusplus.com/reference/cstdio/getc/
        -:   78:// - http://www.cplusplus.com/reference/cstdio/getchar/
        -:   79:// - http://www.cplusplus.com/reference/cstdio/ungetc/ ...
        -:   80://----------------------------------------------------------------------------------
function _ZN10CheckOther25checkCastIntToCharAndBackEv called 927 returned 100% blocks executed 62%
      927:   81:void CheckOther::checkCastIntToCharAndBack()
        -:   82:{
      927:   83:    if (!mSettings->isEnabled(Settings::WARNING))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:   84:        return;
        -:   85:
      927:   86:    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
call    0 returned 100%
     1908:   87:    for (const Scope * scope : symbolDatabase->functionScopes) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 51% (fallthrough)
branch  4 taken 49%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
     1962:   88:        std::map<int, std::string> vars;
call    0 returned 100%
call    1 returned 100%
call    2 never executed
    17795:   89:        for (const Token* tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
call    0 returned 100%
branch  1 taken 94% (fallthrough)
branch  2 taken 6%
call    3 returned 100%
        -:   90:            // Quick check to see if any of the matches below have any chances
    16814:   91:            if (!Token::Match(tok, "%var%|EOF %comp%|="))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 94% (fallthrough)
branch  4 taken 6%
    15798:   92:                continue;
     1016:   93:            if (Token::Match(tok, "%var% = fclose|fflush|fputc|fputs|fscanf|getchar|getc|fgetc|putchar|putc|puts|scanf|sscanf|ungetc (")) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 2% (fallthrough)
branch  4 taken 98%
       18:   94:                const Variable *var = tok->variable();
call    0 returned 100%
       18:   95:                if (var && var->typeEndToken()->str() == "char" && !var->typeEndToken()->isSigned()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
branch  5 taken 56% (fallthrough)
branch  6 taken 44%
call    7 returned 100%
call    8 returned 100%
branch  9 taken 100% (fallthrough)
branch 10 taken 0% (throw)
branch 11 taken 90% (fallthrough)
branch 12 taken 10%
branch 13 taken 50% (fallthrough)
branch 14 taken 50%
        9:   96:                    vars[tok->varId()] = tok->strAt(2);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
branch  8 taken 100% (fallthrough)
branch  9 taken 0% (throw)
        -:   97:                }
      998:   98:            } else if (Token::Match(tok, "EOF %comp% ( %var% = fclose|fflush|fputc|fputs|fscanf|getchar|getc|fgetc|putchar|putc|puts|scanf|sscanf|ungetc (")) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####:   99:                tok = tok->tokAt(3);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  100:                const Variable *var = tok->variable();
call    0 never executed
    #####:  101:                if (var && var->typeEndToken()->str() == "char" && !var->typeEndToken()->isSigned()) {
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
call    8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
    #####:  102:                    checkCastIntToCharAndBackError(tok, tok->strAt(2));
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -:  103:                }
      998:  104:            } else if (mTokenizer->isCPP() && (Token::Match(tok, "EOF %comp% ( %var% = std :: cin . get (") || Token::Match(tok, "EOF %comp% ( %var% = cin . get ("))) {
call    0 returned 100%
branch  1 taken 98% (fallthrough)
branch  2 taken 2%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
branch  6 taken 100% (fallthrough)
branch  7 taken 0%
call    8 returned 100%
branch  9 taken 100% (fallthrough)
branch 10 taken 0% (throw)
branch 11 taken 0% (fallthrough)
branch 12 taken 100%
branch 13 taken 0% (fallthrough)
branch 14 taken 100%
    #####:  105:                tok = tok->tokAt(3);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  106:                const Variable *var = tok->variable();
call    0 never executed
    #####:  107:                if (var && var->typeEndToken()->str() == "char" && !var->typeEndToken()->isSigned()) {
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
call    8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
    #####:  108:                    checkCastIntToCharAndBackError(tok, "cin.get");
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
        -:  109:                }
      998:  110:            } else if (mTokenizer->isCPP() && (Token::Match(tok, "%var% = std :: cin . get (") || Token::Match(tok, "%var% = cin . get ("))) {
call    0 returned 100%
branch  1 taken 98% (fallthrough)
branch  2 taken 2%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
branch  6 taken 99% (fallthrough)
branch  7 taken 1%
call    8 returned 100%
branch  9 taken 100% (fallthrough)
branch 10 taken 0% (throw)
branch 11 taken 0% (fallthrough)
branch 12 taken 100%
branch 13 taken 1% (fallthrough)
branch 14 taken 99%
        8:  111:                const Variable *var = tok->variable();
call    0 returned 100%
        8:  112:                if (var && var->typeEndToken()->str() == "char" && !var->typeEndToken()->isSigned()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
branch  5 taken 50% (fallthrough)
branch  6 taken 50%
call    7 returned 100%
call    8 returned 100%
branch  9 taken 100% (fallthrough)
branch 10 taken 0% (throw)
branch 11 taken 100% (fallthrough)
branch 12 taken 0%
branch 13 taken 50% (fallthrough)
branch 14 taken 50%
        4:  113:                    vars[tok->varId()] = "cin.get";
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
        -:  114:                }
      990:  115:            } else if (Token::Match(tok, "%var% %comp% EOF")) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 1% (fallthrough)
branch  4 taken 99%
        8:  116:                if (vars.find(tok->varId()) != vars.end()) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
branch  8 taken 50% (fallthrough)
branch  9 taken 50%
call   10 never executed
        4:  117:                    checkCastIntToCharAndBackError(tok, vars[tok->varId()]);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
        -:  118:                }
      982:  119:            } else if (Token::Match(tok, "EOF %comp% %var%")) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 1% (fallthrough)
branch  4 taken 99%
       10:  120:                tok = tok->tokAt(2);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       10:  121:                if (vars.find(tok->varId()) != vars.end()) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
branch  8 taken 50% (fallthrough)
branch  9 taken 50%
call   10 never executed
        5:  122:                    checkCastIntToCharAndBackError(tok, vars[tok->varId()]);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
        -:  123:                }
        -:  124:            }
        -:  125:        }
        -:  126:    }
        -:  127:}
        -:  128:
function _ZN10CheckOther30checkCastIntToCharAndBackErrorEPK5TokenRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 9 returned 100% blocks executed 58%
        9:  129:void CheckOther::checkCastIntToCharAndBackError(const Token *tok, const std::string &strFunctionName)
        -:  130:{
       18:  131:    reportError(
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  132:        tok,
        -:  133:        Severity::warning,
        -:  134:        "checkCastIntToCharAndBack",
       18:  135:        "$symbol:" + strFunctionName + "\n"
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
call    5 returned 100%
call    6 never executed
call    7 never executed
        -:  136:        "Storing $symbol() return value in char variable and then comparing with EOF.\n"
        -:  137:        "When saving $symbol() return value in char variable there is loss of precision. "
        -:  138:        " When $symbol() returns EOF this value is truncated. Comparing the char "
        -:  139:        "variable with EOF can have unexpected results. For instance a loop \"while (EOF != (c = $symbol());\" "
        -:  140:        "loops forever on some compilers/platforms and on other compilers/platforms it will stop "
        -:  141:        "when the file contains a matching character.", CWE197, false
        -:  142:    );
        9:  143:}
        -:  144:
        -:  145:
        -:  146://---------------------------------------------------------------------------
        -:  147:// Clarify calculation precedence for ternary operators.
        -:  148://---------------------------------------------------------------------------
function _ZN10CheckOther18clarifyCalculationEv called 927 returned 100% blocks executed 92%
      927:  149:void CheckOther::clarifyCalculation()
        -:  150:{
      927:  151:    if (!mSettings->isEnabled(Settings::STYLE))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  152:        return;
        -:  153:
      927:  154:    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
call    0 returned 100%
     1908:  155:    for (const Scope * scope : symbolDatabase->functionScopes) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 51% (fallthrough)
branch  4 taken 49%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
    17815:  156:        for (const Token* tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
call    0 returned 100%
branch  1 taken 94% (fallthrough)
branch  2 taken 6%
call    3 returned 100%
        -:  157:            // ? operator where lhs is arithmetical expression
    16834:  158:            if (tok->str() != "?" || !tok->astOperand1() || !tok->astOperand1()->isCalculation())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 1% (fallthrough)
branch  3 taken 99%
call    4 returned 100%
branch  5 taken 95% (fallthrough)
branch  6 taken 5%
call    7 returned 100%
call    8 returned 100%
branch  9 taken 100% (fallthrough)
branch 10 taken 0% (throw)
branch 11 taken 37% (fallthrough)
branch 12 taken 63%
branch 13 taken 99% (fallthrough)
branch 14 taken 1%
    16808:  159:                continue;
       26:  160:            if (!tok->astOperand1()->isArithmeticalOp() && tok->astOperand1()->tokType() != Token::eBitOp)
call    0 returned 100%
call    1 returned 100%
branch  2 taken 73% (fallthrough)
branch  3 taken 27%
call    4 returned 100%
call    5 returned 100%
branch  6 taken 95% (fallthrough)
branch  7 taken 5%
branch  8 taken 69% (fallthrough)
branch  9 taken 31%
       18:  161:                continue;
        -:  162:
        -:  163:            // Is code clarified by parentheses already?
        8:  164:            const Token *tok2 = tok->astOperand1();
call    0 returned 100%
       42:  165:            for (; tok2; tok2 = tok2->next()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
       25:  166:                if (tok2->str() == "(")
call    0 returned 100%
call    1 returned 100%
branch  2 taken 8% (fallthrough)
branch  3 taken 92%
        2:  167:                    tok2 = tok2->link();
call    0 returned 100%
       23:  168:                else if (tok2->str() == ")")
call    0 returned 100%
call    1 returned 100%
branch  2 taken 4% (fallthrough)
branch  3 taken 96%
        1:  169:                    break;
       22:  170:                else if (tok2->str() == "?") {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 32% (fallthrough)
branch  3 taken 68%
        7:  171:                    clarifyCalculationError(tok, tok->astOperand1()->str());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
        7:  172:                    break;
        -:  173:                }
        -:  174:            }
        -:  175:        }
        -:  176:    }
        -:  177:}
        -:  178:
function _ZN10CheckOther23clarifyCalculationErrorEPK5TokenRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 7 returned 100% blocks executed 44%
        7:  179:void CheckOther::clarifyCalculationError(const Token *tok, const std::string &op)
        -:  180:{
        -:  181:    // suspicious calculation
       14:  182:    const std::string calc("'a" + op + "b?c:d'");
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 returned 100%
call    8 never executed
call    9 never executed
        -:  183:
        -:  184:    // recommended calculation #1
       14:  185:    const std::string s1("'(a" + op + "b)?c:d'");
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 returned 100%
call    8 never executed
call    9 never executed
        -:  186:
        -:  187:    // recommended calculation #2
       14:  188:    const std::string s2("'a" + op + "(b?c:d)'");
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 returned 100%
call    8 never executed
        -:  189:
       14:  190:    reportError(tok,
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  191:                Severity::style,
        -:  192:                "clarifyCalculation",
       14:  193:                "Clarify calculation precedence for '" + op + "' and '?'.\n"
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 returned 100%
call    8 never executed
call    9 never executed
        -:  194:                "Suspicious calculation. Please use parentheses to clarify the code. "
       14:  195:                "The code '" + calc + "' should be written as either '" + s1 + "' or '" + s2 + "'.", CWE783, false);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
branch 13 taken 100% (fallthrough)
branch 14 taken 0% (throw)
call   15 returned 100%
branch 16 taken 100% (fallthrough)
branch 17 taken 0% (throw)
call   18 returned 100%
call   19 returned 100%
call   20 returned 100%
call   21 returned 100%
call   22 returned 100%
call   23 returned 100%
call   24 never executed
call   25 never executed
call   26 never executed
call   27 never executed
call   28 never executed
call   29 never executed
        7:  196:}
call    0 never executed
        -:  197:
        -:  198://---------------------------------------------------------------------------
        -:  199:// Clarify (meaningless) statements like *foo++; with parentheses.
        -:  200://---------------------------------------------------------------------------
function _ZN10CheckOther16clarifyStatementEv called 927 returned 100% blocks executed 91%
      927:  201:void CheckOther::clarifyStatement()
        -:  202:{
      927:  203:    if (!mSettings->isEnabled(Settings::WARNING))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  204:        return;
        -:  205:
      927:  206:    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
call    0 returned 100%
     1908:  207:    for (const Scope * scope : symbolDatabase->functionScopes) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 51% (fallthrough)
branch  4 taken 49%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
    18796:  208:        for (const Token* tok = scope->bodyStart; tok && tok != scope->bodyEnd; tok = tok->next()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 95% (fallthrough)
branch  3 taken 5%
call    4 returned 100%
    17815:  209:            if (Token::Match(tok, "* %name%") && tok->astOperand1()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 1% (fallthrough)
branch  4 taken 99%
call    5 returned 100%
branch  6 taken 98% (fallthrough)
branch  7 taken 2%
branch  8 taken 1% (fallthrough)
branch  9 taken 99%
      126:  210:                const Token *tok2 = tok->previous();
call    0 returned 100%
        -:  211:
      146:  212:                while (tok2 && tok2->str() == "*")
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 7% (fallthrough)
branch  5 taken 93%
branch  6 taken 7% (fallthrough)
branch  7 taken 93%
       10:  213:                    tok2 = tok2->previous();
call    0 returned 100%
        -:  214:
      126:  215:                if (tok2 && !tok2->astParent() && Token::Match(tok2, "[{};]")) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 40% (fallthrough)
branch  4 taken 60%
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0% (throw)
branch  8 taken 42% (fallthrough)
branch  9 taken 58%
branch 10 taken 17% (fallthrough)
branch 11 taken 83%
       21:  216:                    tok2 = tok->astOperand1();
call    0 returned 100%
       21:  217:                    if (Token::Match(tok2, "++|-- [;,]"))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 33% (fallthrough)
branch  4 taken 67%
        7:  218:                        clarifyStatementError(tok2);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  219:                }
        -:  220:            }
        -:  221:        }
        -:  222:    }
        -:  223:}
        -:  224:
function _ZN10CheckOther21clarifyStatementErrorEPK5Token called 7 returned 100% blocks executed 100%
        7:  225:void CheckOther::clarifyStatementError(const Token *tok)
        -:  226:{
        7:  227:    reportError(tok, Severity::warning, "clarifyStatement", "In expression like '*A++' the result of '*' is unused. Did you intend to write '(*A)++;'?\n"
call    0 returned 100%
        -:  228:                "A statement like '*A++;' might not do what you intended. Postfix 'operator++' is executed before 'operator*'. "
        -:  229:                "Thus, the dereference is meaningless. Did you intend to write '(*A)++;'?", CWE783, false);
        7:  230:}
        -:  231:
        -:  232://---------------------------------------------------------------------------
        -:  233:// Check for suspicious occurrences of 'if(); {}'.
        -:  234://---------------------------------------------------------------------------
function _ZN10CheckOther24checkSuspiciousSemicolonEv called 927 returned 100% blocks executed 91%
      927:  235:void CheckOther::checkSuspiciousSemicolon()
        -:  236:{
      927:  237:    if (!mSettings->inconclusive || !mSettings->isEnabled(Settings::WARNING))
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
branch  5 taken 11% (fallthrough)
branch  6 taken 89%
      101:  238:        return;
        -:  239:
      826:  240:    const SymbolDatabase* const symbolDatabase = mTokenizer->getSymbolDatabase();
call    0 returned 100%
        -:  241:
        -:  242:    // Look for "if(); {}", "for(); {}" or "while(); {}"
     3154:  243:    for (const Scope &scope : symbolDatabase->scopeList) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 74% (fallthrough)
branch  4 taken 26%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
     2328:  244:        if (scope.type == Scope::eIf || scope.type == Scope::eElse || scope.type == Scope::eWhile || scope.type == Scope::eFor) {
branch  0 taken 88% (fallthrough)
branch  1 taken 12%
branch  2 taken 99% (fallthrough)
branch  3 taken 1%
branch  4 taken 99% (fallthrough)
branch  5 taken 1%
branch  6 taken 2% (fallthrough)
branch  7 taken 98%
        -:  245:            // Ensure the semicolon is at the same line number as the if/for/while statement
        -:  246:            // and the {..} block follows it without an extra empty line.
      737:  247:            if (Token::simpleMatch(scope.bodyStart, "{ ; } {") &&
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 80% (fallthrough)
branch  4 taken 20%
branch  5 taken 1% (fallthrough)
branch  6 taken 99%
        5:  248:                scope.bodyStart->previous()->linenr() == scope.bodyStart->tokAt(2)->linenr()
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
call    5 returned 100%
      370:  249:                && scope.bodyStart->linenr()+1 >= scope.bodyStart->tokAt(3)->linenr()) {
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 75% (fallthrough)
branch  8 taken 25%
        3:  250:                SuspiciousSemicolonError(scope.classDef);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  251:            }
        -:  252:        }
        -:  253:    }
        -:  254:}
        -:  255:
function _ZN10CheckOther24SuspiciousSemicolonErrorEPK5Token called 3 returned 100% blocks executed 55%
        3:  256:void CheckOther::SuspiciousSemicolonError(const Token* tok)
        -:  257:{
        6:  258:    reportError(tok, Severity::warning, "suspiciousSemicolon",
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        6:  259:                "Suspicious use of ; at the end of '" + (tok ? tok->str() : std::string()) + "' statement.", CWE398, true);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
call    4 never executed
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0% (throw)
call    8 returned 100%
branch  9 taken 100% (fallthrough)
branch 10 taken 0% (throw)
call   11 returned 100%
call   12 returned 100%
call   13 returned 100%
call   14 never executed
call   15 never executed
call   16 never executed
        3:  260:}
        -:  261:
        -:  262:
        -:  263://---------------------------------------------------------------------------
        -:  264:// For C++ code, warn if C-style casts are used on pointer types
        -:  265://---------------------------------------------------------------------------
function _ZN10CheckOther26warningOldStylePointerCastEv called 944 returned 100% blocks executed 94%
      944:  266:void CheckOther::warningOldStylePointerCast()
        -:  267:{
        -:  268:    // Only valid on C++ code
      944:  269:    if (!mSettings->isEnabled(Settings::STYLE) || !mTokenizer->isCPP())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 2% (fallthrough)
branch  5 taken 98%
branch  6 taken 2% (fallthrough)
branch  7 taken 98%
       22:  270:        return;
        -:  271:
      922:  272:    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
call    0 returned 100%
     1896:  273:    for (const Scope * scope : symbolDatabase->functionScopes) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 51% (fallthrough)
branch  4 taken 49%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
        -:  274:        const Token* tok;
      974:  275:        if (scope->function && scope->function->isConstructor())
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
call    2 returned 100%
branch  3 taken 3% (fallthrough)
branch  4 taken 97%
branch  5 taken 3% (fallthrough)
branch  6 taken 97%
       30:  276:            tok = scope->classDef;
        -:  277:        else
      944:  278:            tok = scope->bodyStart;
    36792:  279:        for (; tok && tok != scope->bodyEnd; tok = tok->next()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 95% (fallthrough)
branch  3 taken 5%
call    4 returned 100%
        -:  280:            // Old style pointer casting..
    17909:  281:            if (!Token::Match(tok, "( const|volatile| const|volatile| %type% * const| ) (| %name%|%num%|%bool%|%char%|%str%"))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 99% (fallthrough)
branch  4 taken 1%
    17895:  282:                continue;
        -:  283:
        -:  284:            // skip first "const" in "const Type* const"
       11:  285:            while (Token::Match(tok->next(), "const|volatile"))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
branch  4 taken 44% (fallthrough)
branch  5 taken 56%
       11:  286:                tok = tok->next();
call    0 returned 100%
       14:  287:            const Token* typeTok = tok->next();
call    0 returned 100%
        -:  288:            // skip second "const" in "const Type* const"
       14:  289:            if (tok->strAt(3) == "const")
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 21% (fallthrough)
branch  5 taken 79%
        3:  290:                tok = tok->next();
call    0 returned 100%
        -:  291:
       14:  292:            const Token *p = tok->tokAt(4);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       14:  293:            if (p->hasKnownIntValue() && p->values().front().intvalue==0) // Casting nullpointers is safe
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 14% (fallthrough)
branch  4 taken 86%
call    5 returned 100%
call    6 returned 100%
branch  7 taken 50% (fallthrough)
branch  8 taken 50%
branch  9 taken 7% (fallthrough)
branch 10 taken 93%
        1:  294:                continue;
        -:  295:
        -:  296:            // Is "type" a class?
       13:  297:            if (typeTok->type())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
       13:  298:                cstyleCastError(tok);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  299:        }
        -:  300:    }
        -:  301:}
        -:  302:
function _ZN10CheckOther15cstyleCastErrorEPK5Token called 13 returned 100% blocks executed 100%
       13:  303:void CheckOther::cstyleCastError(const Token *tok)
        -:  304:{
       13:  305:    reportError(tok, Severity::style, "cstyleCast",
call    0 returned 100%
        -:  306:                "C-style pointer casting\n"
        -:  307:                "C-style pointer casting detected. C++ offers four different kinds of casts as replacements: "
        -:  308:                "static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to "
        -:  309:                "any of those automatically, thus it is considered safer if the programmer explicitly states "
        -:  310:                "which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts.", CWE398, false);
       13:  311:}
        -:  312:
        -:  313://---------------------------------------------------------------------------
        -:  314:// float* f; double* d = (double*)f; <-- Pointer cast to a type with an incompatible binary data representation
        -:  315://---------------------------------------------------------------------------
        -:  316:
function _ZN10CheckOther18invalidPointerCastEv called 939 returned 100% blocks executed 82%
      939:  317:void CheckOther::invalidPointerCast()
        -:  318:{
      939:  319:    if (!mSettings->isEnabled(Settings::PORTABILITY))
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 99%
        1:  320:        return;
        -:  321:
      938:  322:    const bool printInconclusive = mSettings->inconclusive;
      938:  323:    const SymbolDatabase* const symbolDatabase = mTokenizer->getSymbolDatabase();
call    0 returned 100%
     1929:  324:    for (const Scope * scope : symbolDatabase->functionScopes) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 51% (fallthrough)
branch  4 taken 49%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
    18017:  325:        for (const Token* tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
call    0 returned 100%
branch  1 taken 94% (fallthrough)
branch  2 taken 6%
call    3 returned 100%
    17026:  326:            const Token* toTok = nullptr;
    17026:  327:            const Token* fromTok = nullptr;
        -:  328:            // Find cast
    17026:  329:            if (Token::Match(tok, "( const|volatile| const|volatile| %type% %type%| const| * )")) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 1% (fallthrough)
branch  4 taken 99%
       13:  330:                toTok = tok;
       13:  331:                fromTok = tok->astOperand1();
call    0 returned 100%
    17013:  332:            } else if (Token::simpleMatch(tok, "reinterpret_cast <") && tok->linkAt(1)) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 1% (fallthrough)
branch  4 taken 99%
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0% (throw)
branch  8 taken 100% (fallthrough)
branch  9 taken 0%
branch 10 taken 1% (fallthrough)
branch 11 taken 99%
        3:  333:                toTok = tok->linkAt(1)->next();
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
        3:  334:                fromTok = toTok->astOperand2();
call    0 returned 100%
        -:  335:            }
    17026:  336:            if (!fromTok)
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
    17010:  337:                continue;
        -:  338:
       16:  339:            const ValueType* fromType = fromTok->valueType();
call    0 returned 100%
       16:  340:            const ValueType* toType = toTok->valueType();
call    0 returned 100%
       16:  341:            if (!fromType || !toType || !fromType->pointer || !toType->pointer)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 88% (fallthrough)
branch  5 taken 13%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
        2:  342:                continue;
        -:  343:
       14:  344:            if (fromType->type != toType->type && fromType->type >= ValueType::Type::BOOL && toType->type >= ValueType::Type::BOOL && (toType->type != ValueType::Type::CHAR || printInconclusive)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 taken 14% (fallthrough)
branch  7 taken 86%
branch  8 taken 50% (fallthrough)
branch  9 taken 50%
       13:  345:                if (toType->isIntegral() && fromType->isIntegral())
call    0 returned 100%
branch  1 taken 23% (fallthrough)
branch  2 taken 77%
call    3 returned 100%
branch  4 taken 33% (fallthrough)
branch  5 taken 67%
branch  6 taken 8% (fallthrough)
branch  7 taken 92%
        1:  346:                    continue;
       24:  347:                std::string toStr = toType->isIntegral() ? "integer *" : toType->str();
call    0 returned 100%
branch  1 taken 17% (fallthrough)
branch  2 taken 83%
call    3 returned 100%
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
branch  8 taken 100% (fallthrough)
branch  9 taken 0% (throw)
branch 10 taken 17% (fallthrough)
branch 11 taken 83%
call   12 returned 100%
call   13 returned 100%
branch 14 never executed
branch 15 never executed
call   16 never executed
call   17 never executed
       12:  348:                toStr.erase(toStr.size()-2);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
       24:  349:                std::string fromStr = fromType->isIntegral() ? "integer *" : fromType->str();
call    0 returned 100%
branch  1 taken 33% (fallthrough)
branch  2 taken 67%
call    3 returned 100%
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
branch  8 taken 100% (fallthrough)
branch  9 taken 0% (throw)
branch 10 taken 33% (fallthrough)
branch 11 taken 67%
call   12 returned 100%
call   13 returned 100%
branch 14 never executed
branch 15 never executed
call   16 never executed
call   17 never executed
       12:  350:                fromStr.erase(fromStr.size() - 2);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
        -:  351:
       12:  352:                invalidPointerCastError(tok, fromStr, toStr, toType->type == ValueType::Type::CHAR);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  353:            }
        -:  354:        }
        -:  355:    }
        -:  356:}
        -:  357:
function _ZN10CheckOther23invalidPointerCastErrorEPK5TokenRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESA_b called 12 returned 100% blocks executed 55%
       12:  358:void CheckOther::invalidPointerCastError(const Token* tok, const std::string& from, const std::string& to, bool inconclusive)
        -:  359:{
       12:  360:    if (to == "integer") { // If we cast something to int*, this can be useful to play with its binary data representation
call    0 returned 100%
branch  1 taken 17% (fallthrough)
branch  2 taken 83%
        2:  361:        if (!inconclusive)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        1:  362:            reportError(tok, Severity::portability, "invalidPointerCast", "Casting from " + from + "* to integer* is not portable due to different binary data representations on different platforms.", CWE704, false);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
call   11 never executed
        -:  363:        else
        1:  364:            reportError(tok, Severity::portability, "invalidPointerCast", "Casting from " + from + "* to char* is not portable due to different binary data representations on different platforms.", CWE704, true);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
call   11 never executed
        -:  365:    } else
       10:  366:        reportError(tok, Severity::portability, "invalidPointerCast", "Casting between " + from + "* and " + to + "* which have an incompatible binary data representation.", CWE704, false);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
branch  8 taken 100% (fallthrough)
branch  9 taken 0% (throw)
call   10 returned 100%
branch 11 taken 100% (fallthrough)
branch 12 taken 0% (throw)
call   13 returned 100%
call   14 returned 100%
call   15 returned 100%
call   16 returned 100%
call   17 never executed
call   18 never executed
call   19 never executed
call   20 never executed
       12:  367:}
        -:  368:
        -:  369://---------------------------------------------------------------------------
        -:  370:// This check detects errors on POSIX systems, when a pipe command called
        -:  371:// with a wrong dimensioned file descriptor array. The pipe command requires
        -:  372:// exactly an integer array of dimension two as parameter.
        -:  373://
        -:  374:// References:
        -:  375://  - http://linux.die.net/man/2/pipe
        -:  376://  - ticket #3521
        -:  377://---------------------------------------------------------------------------
function _ZN10CheckOther22checkPipeParameterSizeEv called 927 returned 100% blocks executed 86%
      927:  378:void CheckOther::checkPipeParameterSize()
        -:  379:{
      927:  380:    if (!mSettings->posix())
call    0 returned 100%
branch  1 taken 99% (fallthrough)
branch  2 taken 1%
      921:  381:        return;
        -:  382:
        6:  383:    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
call    0 returned 100%
       12:  384:    for (const Scope * scope : symbolDatabase->functionScopes) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 50% (fallthrough)
branch  4 taken 50%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
      126:  385:        for (const Token* tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
call    0 returned 100%
branch  1 taken 95% (fallthrough)
branch  2 taken 5%
call    3 returned 100%
      237:  386:            if (Token::Match(tok, "pipe ( %var% )") ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 98% (fallthrough)
branch  4 taken 3%
branch  5 taken 3% (fallthrough)
branch  6 taken 97%
branch  7 taken 5% (fallthrough)
branch  8 taken 95%
      117:  387:                Token::Match(tok, "pipe2 ( %var% ,")) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        6:  388:                const Token * const varTok = tok->tokAt(2);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  389:
        6:  390:                const Variable *var = varTok->variable();
call    0 returned 100%
        -:  391:                MathLib::bigint dim;
        6:  392:                if (var && var->isArray() && !var->isArgument() && ((dim=var->dimension(0U)) < 2)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0%
call    8 returned 100%
branch  9 taken 33% (fallthrough)
branch 10 taken 67%
branch 11 taken 33% (fallthrough)
branch 12 taken 67%
        4:  393:                    const std::string strDim = MathLib::toString(dim);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
call    4 never executed
        2:  394:                    checkPipeParameterSizeError(varTok,varTok->str(), strDim);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
        -:  395:                }
        -:  396:            }
        -:  397:        }
        -:  398:    }
        -:  399:}
        -:  400:
function _ZN10CheckOther27checkPipeParameterSizeErrorEPK5TokenRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESA_ called 2 returned 100% blocks executed 50%
        2:  401:void CheckOther::checkPipeParameterSizeError(const Token *tok, const std::string &strVarName, const std::string &strDim)
        -:  402:{
        4:  403:    reportError(tok, Severity::error,
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  404:                "wrongPipeParameterSize",
        4:  405:                "$symbol:" + strVarName + "\n"
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
call    5 returned 100%
call    6 never executed
call    7 never executed
        -:  406:                "Buffer '$symbol' must have size of 2 integers if used as parameter of pipe().\n"
        -:  407:                "The pipe()/pipe2() system command takes an argument, which is an array of exactly two integers.\n"
        4:  408:                "The variable '$symbol' is an array of size " + strDim + ", which does not match.", CWE686, false);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 returned 100%
call    8 never executed
call    9 never executed
        2:  409:}
        -:  410:
        -:  411://---------------------------------------------------------------------------
        -:  412:// Detect redundant assignments: x = 0; x = 4;
        -:  413://---------------------------------------------------------------------------
        -:  414:
function _ZN10CheckOther24checkRedundantAssignmentEv called 927 returned 100% blocks executed 88%
      927:  415:void CheckOther::checkRedundantAssignment()
        -:  416:{
      927:  417:    if (!mSettings->isEnabled(Settings::STYLE))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  418:        return;
      927:  419:    const SymbolDatabase* symbolDatabase = mTokenizer->getSymbolDatabase();
call    0 returned 100%
     1908:  420:    for (const Scope *scope : symbolDatabase->functionScopes) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 51% (fallthrough)
branch  4 taken 49%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
      981:  421:        if (!scope->bodyStart)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  422:            continue;
    17536:  423:        for (const Token* tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
call    0 returned 100%
branch  1 taken 94% (fallthrough)
branch  2 taken 6%
call    3 returned 100%
    16562:  424:            if (Token::simpleMatch(tok, "] ("))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 1% (fallthrough)
branch  4 taken 99%
        -:  425:                // todo: handle lambdas
        7:  426:                break;
    16555:  427:            if (Token::simpleMatch(tok, "try {"))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 1% (fallthrough)
branch  4 taken 99%
        -:  428:                // todo: check try blocks
        6:  429:                tok = tok->linkAt(1);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
    16555:  430:            if ((tok->isAssignmentOp() || Token::Match(tok, "++|--")) && tok->astOperand1()) {
call    0 returned 100%
branch  1 taken 95% (fallthrough)
branch  2 taken 5%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
branch  6 taken 1% (fallthrough)
branch  7 taken 99%
call    8 returned 100%
branch  9 taken 99% (fallthrough)
branch 10 taken 1%
branch 11 taken 6% (fallthrough)
branch 12 taken 94%
     1002:  431:                if (tok->astParent())
call    0 returned 100%
branch  1 taken 12% (fallthrough)
branch  2 taken 88%
     1078:  432:                    continue;
        -:  433:
        -:  434:                // Do not warn about redundant initialization when rhs is trivial
        -:  435:                // TODO : do not simplify the variable declarations
      886:  436:                bool isInitialization = false;
      886:  437:                if (Token::Match(tok->tokAt(-3), "%var% ; %var% =") && tok->previous()->variable() && tok->previous()->variable()->nameToken() == tok->tokAt(-3) && tok->tokAt(-3)->linenr() == tok->previous()->linenr()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
branch  6 taken 48% (fallthrough)
branch  7 taken 52%
call    8 returned 100%
call    9 returned 100%
branch 10 taken 99% (fallthrough)
branch 11 taken 1%
call   12 returned 100%
call   13 returned 100%
call   14 returned 100%
call   15 returned 100%
branch 16 taken 100% (fallthrough)
branch 17 taken 0% (throw)
branch 18 taken 98% (fallthrough)
branch 19 taken 2%
call   20 returned 100%
branch 21 taken 100% (fallthrough)
branch 22 taken 0% (throw)
call   23 returned 100%
call   24 returned 100%
call   25 returned 100%
branch 26 taken 97% (fallthrough)
branch 27 taken 3%
branch 28 taken 46% (fallthrough)
branch 29 taken 54%
      404:  438:                    isInitialization = true;
      404:  439:                    bool trivial = true;
      404:  440:                    visitAstNodes(tok->astOperand2(),
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 never executed
function _ZZN10CheckOther24checkRedundantAssignmentEvENKUlPK5TokenE_clES2_ called 404 returned 100% blocks executed 94%
      404:  441:                    [&](const Token *rhs) {
      404:  442:                        if (Token::simpleMatch(rhs, "{ 0 }"))
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 99%
        2:  443:                            return ChildrenToVisit::none;
      402:  444:                        if (Token::Match(rhs, "%str%|%num%|%name%") && !rhs->varId())
call    0 returned 100%
branch  1 taken 52% (fallthrough)
branch  2 taken 48%
call    3 returned 100%
branch  4 taken 91% (fallthrough)
branch  5 taken 9%
branch  6 taken 48% (fallthrough)
branch  7 taken 52%
      191:  445:                            return ChildrenToVisit::none;
      211:  446:                        if (rhs->isCast())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  447:                            return ChildrenToVisit::op2;
      211:  448:                        trivial = false;
      211:  449:                        return ChildrenToVisit::done;
        -:  450:                    });
      404:  451:                    if (trivial)
branch  0 taken 48% (fallthrough)
branch  1 taken 52%
      193:  452:                        continue;
        -:  453:                }
        -:  454:
        -:  455:                // Do not warn about assignment with 0 / NULL
      693:  456:                if (Token::simpleMatch(tok->astOperand2(), "0") || FwdAnalysis::isNullOperand(tok->astOperand2()))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
branch  4 taken 98% (fallthrough)
branch  5 taken 2%
call    6 returned 100%
call    7 returned 100%
branch  8 taken 100% (fallthrough)
branch  9 taken 0% (throw)
branch 10 taken 1% (fallthrough)
branch 11 taken 99%
branch 12 taken 2% (fallthrough)
branch 13 taken 98%
       13:  457:                    continue;
        -:  458:
      680:  459:                if (tok->astOperand1()->variable() && tok->astOperand1()->variable()->isReference())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 82% (fallthrough)
branch  3 taken 18%
call    4 returned 100%
call    5 returned 100%
call    6 returned 100%
branch  7 taken 6% (fallthrough)
branch  8 taken 94%
branch  9 taken 5% (fallthrough)
branch 10 taken 95%
        -:  460:                    // todo: check references
       36:  461:                    continue;
        -:  462:
      644:  463:                if (tok->astOperand1()->variable() && tok->astOperand1()->variable()->isStatic())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 81% (fallthrough)
branch  3 taken 19%
call    4 returned 100%
call    5 returned 100%
call    6 returned 100%
branch  7 taken 1% (fallthrough)
branch  8 taken 99%
branch  9 taken 1% (fallthrough)
branch 10 taken 99%
        -:  464:                    // todo: check static variables
        6:  465:                    continue;
        -:  466:
        -:  467:                // If there is a custom assignment operator => this is inconclusive
      638:  468:                bool inconclusive = false;
      638:  469:                if (mTokenizer->isCPP() && tok->astOperand1()->valueType() && tok->astOperand1()->valueType()->typeScope) {
call    0 returned 100%
branch  1 taken 98% (fallthrough)
branch  2 taken 2%
call    3 returned 100%
call    4 returned 100%
branch  5 taken 87% (fallthrough)
branch  6 taken 13%
call    7 returned 100%
call    8 returned 100%
branch  9 taken 7% (fallthrough)
branch 10 taken 93%
branch 11 taken 6% (fallthrough)
branch 12 taken 94%
       76:  470:                    const std::string op = "operator" + tok->str();
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
       63:  471:                    for (const Function &f : tok->astOperand1()->valueType()->typeScope->functionList) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
branch  5 taken 43% (fallthrough)
branch  6 taken 57%
call    7 returned 100%
call    8 returned 100%
call    9 returned 100%
call   10 returned 100%
       27:  472:                        if (f.name() == op) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 7% (fallthrough)
branch  3 taken 93%
        2:  473:                            inconclusive = true;
        2:  474:                            break;
        -:  475:                        }
        -:  476:                    }
        -:  477:                }
      638:  478:                if (inconclusive && !mSettings->inconclusive)
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  479:                    continue;
        -:  480:
      678:  481:                FwdAnalysis fwdAnalysis(mTokenizer->isCPP(), mSettings->library);
call    0 returned 100%
call    1 returned 100%
call    2 never executed
      638:  482:                if (fwdAnalysis.hasOperand(tok->astOperand2(), tok->astOperand1()))
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
branch  5 taken 5% (fallthrough)
branch  6 taken 95%
       30:  483:                    continue;
        -:  484:
        -:  485:                // Is there a redundant assignment?
        -:  486:                const Token *start;
      608:  487:                if (tok->isAssignmentOp())
call    0 returned 100%
branch  1 taken 88% (fallthrough)
branch  2 taken 12%
      533:  488:                    start = tok->next();
call    0 returned 100%
        -:  489:                else
       75:  490:                    start = tok->findExpressionStartEndTokens().second->next();
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
        -:  491:
        -:  492:                // Get next assignment..
      608:  493:                const Token *nextAssign = fwdAnalysis.reassign(tok->astOperand1(), start, scope->bodyEnd);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
        -:  494:
      608:  495:                if (!nextAssign)
branch  0 taken 93% (fallthrough)
branch  1 taken 7%
      568:  496:                    continue;
        -:  497:
        -:  498:                // there is redundant assignment. Is there a case between the assignments?
       40:  499:                bool hasCase = false;
      250:  500:                for (const Token *tok2 = tok; tok2 != nextAssign; tok2 = tok2->next()) {
branch  0 taken 91% (fallthrough)
branch  1 taken 9%
call    2 returned 100%
      227:  501:                    if (tok2->str() == "break" || tok2->str() == "return")
call    0 returned 100%
call    1 returned 100%
branch  2 taken 98% (fallthrough)
branch  3 taken 2%
call    4 returned 100%
call    5 returned 100%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
branch  8 taken 2% (fallthrough)
branch  9 taken 98%
        4:  502:                        break;
      223:  503:                    if (tok2->str() == "case") {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 6% (fallthrough)
branch  3 taken 94%
       13:  504:                        hasCase = true;
       13:  505:                        break;
        -:  506:                    }
        -:  507:                }
        -:  508:
        -:  509:                // warn
       40:  510:                if (hasCase)
branch  0 taken 33% (fallthrough)
branch  1 taken 68%
       13:  511:                    redundantAssignmentInSwitchError(tok, nextAssign, tok->astOperand1()->expressionString());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 never executed
       27:  512:                else if (isInitialization)
branch  0 taken 11% (fallthrough)
branch  1 taken 89%
        3:  513:                    redundantInitializationError(tok, nextAssign, tok->astOperand1()->expressionString(), inconclusive);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 never executed
        -:  514:                else
       24:  515:                    redundantAssignmentError(tok, nextAssign, tok->astOperand1()->expressionString(), inconclusive);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 returned 100%
branch  9 taken 6%
branch 10 taken 94%
call   11 never executed
        -:  516:            }
        -:  517:        }
        -:  518:    }
        -:  519:}
        -:  520:
function _ZN10CheckOther18redundantCopyErrorEPK5TokenS2_RKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 0 returned 0% blocks executed 0%
    #####:  521:void CheckOther::redundantCopyError(const Token *tok1, const Token* tok2, const std::string& var)
        -:  522:{
    #####:  523:    const std::list<const Token *> callstack = { tok1, tok2 };
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
    #####:  524:    reportError(callstack, Severity::performance, "redundantCopy",
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  525:                "$symbol:" + var + "\n"
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
        -:  526:                "Buffer '$symbol' is being written before its old content has been used.", CWE563, false);
    #####:  527:}
call    0 never executed
        -:  528:
function _ZN10CheckOther26redundantCopyInSwitchErrorEPK5TokenS2_RKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 0 returned 0% blocks executed 0%
    #####:  529:void CheckOther::redundantCopyInSwitchError(const Token *tok1, const Token* tok2, const std::string &var)
        -:  530:{
    #####:  531:    const std::list<const Token *> callstack = { tok1, tok2 };
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
    #####:  532:    reportError(callstack, Severity::warning, "redundantCopyInSwitch",
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  533:                "$symbol:" + var + "\n"
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
        -:  534:                "Buffer '$symbol' is being written before its old content has been used. 'break;' missing?", CWE563, false);
    #####:  535:}
call    0 never executed
        -:  536:
function _ZN10CheckOther24redundantAssignmentErrorEPK5TokenS2_RKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEb called 24 returned 100% blocks executed 50%
       24:  537:void CheckOther::redundantAssignmentError(const Token *tok1, const Token* tok2, const std::string& var, bool inconclusive)
        -:  538:{
       48:  539:    const ErrorPath errorPath = { ErrorPathItem(tok1, var + " is assigned"), ErrorPathItem(tok2, var + " is overwritten") };
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 returned 100%
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
branch 13 taken 67% (fallthrough)
branch 14 taken 33%
call   15 returned 100%
call   16 returned 100%
call   17 returned 100%
call   18 returned 100%
branch 19 never executed
branch 20 never executed
call   21 never executed
call   22 never executed
call   23 never executed
call   24 never executed
       24:  540:    if (inconclusive)
branch  0 taken 4% (fallthrough)
branch  1 taken 96%
        2:  541:        reportError(errorPath, Severity::style, "redundantAssignment",
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        2:  542:                    "$symbol:" + var + "\n"
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 returned 100%
call    8 never executed
call    9 never executed
        -:  543:                    "Variable '$symbol' is reassigned a value before the old one has been used if variable is no semaphore variable.\n"
        -:  544:                    "Variable '$symbol' is reassigned a value before the old one has been used. Make sure that this variable is not used like a semaphore in a threading environment before simplifying this code.", CWE563, true);
        -:  545:    else
       46:  546:        reportError(errorPath, Severity::style, "redundantAssignment",
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       46:  547:                    "$symbol:" + var + "\n"
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 returned 100%
call    8 never executed
call    9 never executed
        -:  548:                    "Variable '$symbol' is reassigned a value before the old one has been used.", CWE563, false);
       24:  549:}
call    0 never executed
        -:  550:
function _ZN10CheckOther28redundantInitializationErrorEPK5TokenS2_RKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEb called 3 returned 100% blocks executed 48%
        3:  551:void CheckOther::redundantInitializationError(const Token *tok1, const Token* tok2, const std::string& var, bool inconclusive)
        -:  552:{
        6:  553:    const ErrorPath errorPath = { ErrorPathItem(tok1, var + " is initialized"), ErrorPathItem(tok2, var + " is overwritten") };
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 returned 100%
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
branch 13 taken 67% (fallthrough)
branch 14 taken 33%
call   15 returned 100%
call   16 returned 100%
call   17 returned 100%
call   18 returned 100%
branch 19 never executed
branch 20 never executed
call   21 never executed
call   22 never executed
call   23 never executed
call   24 never executed
        6:  554:    reportError(errorPath, Severity::style, "redundantInitialization",
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        6:  555:                "$symbol:" + var + "\nRedundant initialization for '$symbol'. The initialized value is overwritten before it is read.",
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 returned 100%
call    8 never executed
call    9 never executed
        -:  556:                CWE563,
        -:  557:                inconclusive);
        3:  558:}
call    0 never executed
        -:  559:
function _ZN10CheckOther32redundantAssignmentInSwitchErrorEPK5TokenS2_RKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 13 returned 100% blocks executed 50%
       13:  560:void CheckOther::redundantAssignmentInSwitchError(const Token *tok1, const Token* tok2, const std::string &var)
        -:  561:{
       26:  562:    const ErrorPath errorPath = { ErrorPathItem(tok1, "$symbol is assigned"), ErrorPathItem(tok2, "$symbol is overwritten") };
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 returned 100%
branch  8 taken 100% (fallthrough)
branch  9 taken 0% (throw)
call   10 returned 100%
branch 11 taken 67% (fallthrough)
branch 12 taken 33%
call   13 returned 100%
call   14 returned 100%
branch 15 never executed
branch 16 never executed
call   17 never executed
call   18 never executed
       26:  563:    reportError(errorPath, Severity::warning, "redundantAssignInSwitch",
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       26:  564:                "$symbol:" + var + "\n"
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 returned 100%
call    8 never executed
call    9 never executed
        -:  565:                "Variable '$symbol' is reassigned a value before the old one has been used. 'break;' missing?", CWE563, false);
       13:  566:}
call    0 never executed
        -:  567:
        -:  568:
        -:  569://---------------------------------------------------------------------------
        -:  570://    switch (x)
        -:  571://    {
        -:  572://        case 2:
        -:  573://            y = a;        // <- this assignment is redundant
        -:  574://        case 3:
        -:  575://            y = b;        // <- case 2 falls through and sets y twice
        -:  576://    }
        -:  577://---------------------------------------------------------------------------
function _ZL24isFunctionOrBreakPatternPK5Token called 1286 returned 100% blocks executed 100%
     1286:  578:static inline bool isFunctionOrBreakPattern(const Token *tok)
        -:  579:{
     1286:  580:    if (Token::Match(tok, "%name% (") || Token::Match(tok, "break|continue|return|exit|goto|throw"))
call    0 returned 100%
branch  1 taken 97% (fallthrough)
branch  2 taken 3%
call    3 returned 100%
branch  4 taken 4% (fallthrough)
branch  5 taken 96%
branch  6 taken 7% (fallthrough)
branch  7 taken 93%
       84:  581:        return true;
        -:  582:
     1202:  583:    return false;
        -:  584:}
        -:  585:
function _ZN10CheckOther32checkRedundantAssignmentInSwitchEv called 927 returned 100% blocks executed 63%
      927:  586:void CheckOther::checkRedundantAssignmentInSwitch()
        -:  587:{
      927:  588:    if (!mSettings->isEnabled(Settings::WARNING))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  589:        return;
        -:  590:
      927:  591:    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
call    0 returned 100%
        -:  592:
        -:  593:    // Find the beginning of a switch. E.g.:
        -:  594:    //   switch (var) { ...
     3570:  595:    for (const Scope &switchScope : symbolDatabase->scopeList) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 74% (fallthrough)
branch  4 taken 26%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
     2643:  596:        if (switchScope.type != Scope::eSwitch || !switchScope.bodyStart)
branch  0 taken 3% (fallthrough)
branch  1 taken 97%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
     2573:  597:            continue;
        -:  598:
        -:  599:        // Check the contents of the switch statement
      140:  600:        std::map<int, const Token*> varsWithBitsSet;
call    0 returned 100%
call    1 returned 100%
call    2 never executed
      140:  601:        std::map<int, std::string> bitOperations;
call    0 returned 100%
call    1 returned 100%
call    2 never executed
        -:  602:
     1314:  603:        for (const Token *tok2 = switchScope.bodyStart->next(); tok2 != switchScope.bodyEnd; tok2 = tok2->next()) {
call    0 returned 100%
branch  1 taken 95% (fallthrough)
branch  2 taken 5%
call    3 returned 100%
     1244:  604:            if (tok2->str() == "{") {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 1% (fallthrough)
branch  3 taken 99%
        -:  605:                // Inside a conditional or loop. Don't mark variable accesses as being redundant. E.g.:
        -:  606:                //   case 3: b = 1;
        -:  607:                //   case 4: if (a) { b = 2; }    // Doesn't make the b=1 redundant because it's conditional
       16:  608:                if (Token::Match(tok2->previous(), ")|else {") && tok2->link()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
branch  4 taken 56% (fallthrough)
branch  5 taken 44%
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0%
branch  9 taken 56% (fallthrough)
branch 10 taken 44%
        9:  609:                    const Token* endOfConditional = tok2->link();
call    0 returned 100%
       59:  610:                    for (const Token* tok3 = tok2; tok3 != endOfConditional; tok3 = tok3->next()) {
branch  0 taken 85% (fallthrough)
branch  1 taken 15%
call    2 returned 100%
       50:  611:                        if (tok3->varId() != 0) {
call    0 returned 100%
branch  1 taken 16% (fallthrough)
branch  2 taken 84%
        8:  612:                            varsWithBitsSet.erase(tok3->varId());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
        8:  613:                            bitOperations.erase(tok3->varId());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
       42:  614:                        } else if (isFunctionOrBreakPattern(tok3)) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 12% (fallthrough)
branch  4 taken 88%
        5:  615:                            varsWithBitsSet.clear();
call    0 returned 100%
        5:  616:                            bitOperations.clear();
call    0 returned 100%
        -:  617:                        }
        -:  618:                    }
        9:  619:                    tok2 = endOfConditional;
        -:  620:                }
        -:  621:            }
        -:  622:
        -:  623:            // Variable assignment. Report an error if it's assigned to twice before a break. E.g.:
        -:  624:            //    case 3: b = 1;    // <== redundant
        -:  625:            //    case 4: b = 2;
        -:  626:
     1244:  627:            if (Token::Match(tok2->previous(), ";|{|}|: %var% = %any% ;")) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
branch  4 taken 4% (fallthrough)
branch  5 taken 96%
       46:  628:                varsWithBitsSet.erase(tok2->varId());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
       46:  629:                bitOperations.erase(tok2->varId());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
        -:  630:            }
        -:  631:
        -:  632:            // Bitwise operation. Report an error if it's performed twice before a break. E.g.:
        -:  633:            //    case 3: b |= 1;    // <== redundant
        -:  634:            //    case 4: b |= 1;
     2417:  635:            else if (Token::Match(tok2->previous(), ";|{|}|: %var% %assign% %num% ;") &&
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
branch  4 taken 33% (fallthrough)
branch  5 taken 67%
branch  6 taken 2% (fallthrough)
branch  7 taken 98%
     1224:  636:                     (tok2->strAt(1) == "|=" || tok2->strAt(1) == "&=") &&
branch  0 taken 2% (fallthrough)
branch  1 taken 98%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
call    5 returned 100%
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 71% (fallthrough)
branch 11 taken 29%
branch 12 taken 100% (fallthrough)
branch 13 taken 0%
       19:  637:                     Token::Match(tok2->next()->astOperand2(), "%num%")) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
       38:  638:                const std::string bitOp = tok2->strAt(1)[0] + tok2->strAt(2);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 returned 100%
branch  8 taken 100% (fallthrough)
branch  9 taken 0% (throw)
call   10 returned 100%
call   11 never executed
       38:  639:                const std::map<int, const Token*>::const_iterator i2 = varsWithBitsSet.find(tok2->varId());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
call    5 returned 100%
call    6 returned 100%
call    7 never executed
        -:  640:
        -:  641:                // This variable has not had a bit operation performed on it yet, so just make a note of it
       19:  642:                if (i2 == varsWithBitsSet.end()) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 68% (fallthrough)
branch  4 taken 32%
       13:  643:                    varsWithBitsSet[tok2->varId()] = tok2;
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
       13:  644:                    bitOperations[tok2->varId()] = bitOp;
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
        -:  645:                }
        -:  646:
        -:  647:                // The same bit operation has been performed on the same variable twice, so report an error
        6:  648:                else if (bitOperations[tok2->varId()] == bitOp)
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 50% (fallthrough)
branch  6 taken 50%
        3:  649:                    redundantBitwiseOperationInSwitchError(i2->second, i2->second->str());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        -:  650:
        -:  651:                // A different bit operation was performed on the variable, so clear it
        -:  652:                else {
        3:  653:                    varsWithBitsSet.erase(tok2->varId());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
        3:  654:                    bitOperations.erase(tok2->varId());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
        -:  655:                }
        -:  656:            }
        -:  657:
        -:  658:            // Bitwise operation. Report an error if it's performed twice before a break. E.g.:
        -:  659:            //    case 3: b = b | 1;    // <== redundant
        -:  660:            //    case 4: b = b | 1;
     1179:  661:            else if (Token::Match(tok2->previous(), ";|{|}|: %var% = %name% %or%|& %num% ;") &&
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
branch  6 never executed
branch  7 never executed
branch  8 taken 0% (fallthrough)
branch  9 taken 100%
    #####:  662:                     tok2->varId() == tok2->tokAt(2)->varId()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  663:                const std::string bitOp = tok2->strAt(3) + tok2->strAt(4);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
call    9 never executed
call   10 never executed
    #####:  664:                const std::map<int, const Token*>::const_iterator i2 = varsWithBitsSet.find(tok2->varId());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
        -:  665:
        -:  666:                // This variable has not had a bit operation performed on it yet, so just make a note of it
    #####:  667:                if (i2 == varsWithBitsSet.end()) {
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  668:                    varsWithBitsSet[tok2->varId()] = tok2;
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  669:                    bitOperations[tok2->varId()] = bitOp;
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
        -:  670:                }
        -:  671:
        -:  672:                // The same bit operation has been performed on the same variable twice, so report an error
    #####:  673:                else if (bitOperations[tok2->varId()] == bitOp)
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####:  674:                    redundantBitwiseOperationInSwitchError(i2->second, i2->second->str());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -:  675:
        -:  676:                // A different bit operation was performed on the variable, so clear it
        -:  677:                else {
    #####:  678:                    varsWithBitsSet.erase(tok2->varId());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  679:                    bitOperations.erase(tok2->varId());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  680:                }
        -:  681:            }
        -:  682:
        -:  683:            // Not a simple assignment so there may be good reason if this variable is assigned to twice. E.g.:
        -:  684:            //    case 3: b = 1;
        -:  685:            //    case 4: b++;
     1179:  686:            else if (tok2->varId() != 0 && tok2->strAt(1) != "|" && tok2->strAt(1) != "&") {
call    0 returned 100%
branch  1 taken 5% (fallthrough)
branch  2 taken 95%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0%
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
branch 13 taken 100% (fallthrough)
branch 14 taken 0%
branch 15 taken 5% (fallthrough)
branch 16 taken 95%
       54:  687:                varsWithBitsSet.erase(tok2->varId());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
       54:  688:                bitOperations.erase(tok2->varId());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
        -:  689:            }
        -:  690:
        -:  691:            // Reset our record of assignments if there is a break or function call. E.g.:
        -:  692:            //    case 3: b = 1; break;
     1244:  693:            if (isFunctionOrBreakPattern(tok2)) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 6% (fallthrough)
branch  4 taken 94%
       79:  694:                varsWithBitsSet.clear();
call    0 returned 100%
       79:  695:                bitOperations.clear();
call    0 returned 100%
        -:  696:            }
        -:  697:        }
        -:  698:    }
        -:  699:}
        -:  700:
function _ZN10CheckOther38redundantBitwiseOperationInSwitchErrorEPK5TokenRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 3 returned 100% blocks executed 58%
        3:  701:void CheckOther::redundantBitwiseOperationInSwitchError(const Token *tok, const std::string &varname)
        -:  702:{
        6:  703:    reportError(tok, Severity::warning,
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  704:                "redundantBitwiseOperationInSwitch",
        6:  705:                "$symbol:" + varname + "\n"
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
call    5 returned 100%
call    6 never executed
call    7 never executed
        -:  706:                "Redundant bitwise operation on '$symbol' in 'switch' statement. 'break;' missing?");
        3:  707:}
        -:  708:
        -:  709:
        -:  710://---------------------------------------------------------------------------
        -:  711:// Check for statements like case A||B: in switch()
        -:  712://---------------------------------------------------------------------------
function _ZN10CheckOther27checkSuspiciousCaseInSwitchEv called 927 returned 100% blocks executed 91%
      927:  713:void CheckOther::checkSuspiciousCaseInSwitch()
        -:  714:{
      927:  715:    if (!mSettings->inconclusive || !mSettings->isEnabled(Settings::WARNING))
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
branch  5 taken 11% (fallthrough)
branch  6 taken 89%
      101:  716:        return;
        -:  717:
      826:  718:    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
call    0 returned 100%
        -:  719:
     3154:  720:    for (const Scope & scope : symbolDatabase->scopeList) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 74% (fallthrough)
branch  4 taken 26%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
     2328:  721:        if (scope.type != Scope::eSwitch)
branch  0 taken 97% (fallthrough)
branch  1 taken 3%
     2265:  722:            continue;
        -:  723:
     1219:  724:        for (const Token* tok = scope.bodyStart->next(); tok != scope.bodyEnd; tok = tok->next()) {
call    0 returned 100%
branch  1 taken 95% (fallthrough)
branch  2 taken 5%
call    3 returned 100%
     1156:  725:            if (tok->str() == "case") {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 10% (fallthrough)
branch  3 taken 90%
      116:  726:                const Token* finding = nullptr;
      244:  727:                for (const Token* tok2 = tok->next(); tok2; tok2 = tok2->next()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
      244:  728:                    if (tok2->str() == ":")
call    0 returned 100%
call    1 returned 100%
branch  2 taken 48% (fallthrough)
branch  3 taken 52%
      116:  729:                        break;
      128:  730:                    if (Token::Match(tok2, "[;}{]"))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####:  731:                        break;
        -:  732:
      128:  733:                    if (tok2->str() == "?")
call    0 returned 100%
call    1 returned 100%
branch  2 taken 1% (fallthrough)
branch  3 taken 99%
        1:  734:                        finding = nullptr;
      127:  735:                    else if (Token::Match(tok2, "&&|%oror%"))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 3% (fallthrough)
branch  4 taken 97%
        4:  736:                        finding = tok2;
        -:  737:                }
      116:  738:                if (finding)
branch  0 taken 3% (fallthrough)
branch  1 taken 97%
        3:  739:                    suspiciousCaseInSwitchError(finding, finding->str());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
        -:  740:            }
        -:  741:        }
        -:  742:    }
        -:  743:}
        -:  744:
function _ZN10CheckOther27suspiciousCaseInSwitchErrorEPK5TokenRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 3 returned 100% blocks executed 50%
        3:  745:void CheckOther::suspiciousCaseInSwitchError(const Token* tok, const std::string& operatorString)
        -:  746:{
        6:  747:    reportError(tok, Severity::warning, "suspiciousCase",
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        6:  748:                "Found suspicious case label in switch(). Operator '" + operatorString + "' probably doesn't work as intended.\n"
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
call    5 returned 100%
call    6 never executed
call    7 never executed
        6:  749:                "Using an operator like '" + operatorString + "' in a case label is suspicious. Did you intend to use a bitwise operator, multiple case labels or if/else instead?", CWE398, true);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 returned 100%
call    8 never executed
call    9 never executed
        3:  750:}
        -:  751:
        -:  752://---------------------------------------------------------------------------
        -:  753://    Find consecutive return, break, continue, goto or throw statements. e.g.:
        -:  754://        break; break;
        -:  755://    Detect dead code, that follows such a statement. e.g.:
        -:  756://        return(0); foo();
        -:  757://---------------------------------------------------------------------------
function _ZN10CheckOther20checkUnreachableCodeEv called 927 returned 100% blocks executed 94%
      927:  758:void CheckOther::checkUnreachableCode()
        -:  759:{
      927:  760:    if (!mSettings->isEnabled(Settings::STYLE))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  761:        return;
      927:  762:    const bool printInconclusive = mSettings->inconclusive;
      927:  763:    const SymbolDatabase* symbolDatabase = mTokenizer->getSymbolDatabase();
call    0 returned 100%
     1908:  764:    for (const Scope * scope : symbolDatabase->functionScopes) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 51% (fallthrough)
branch  4 taken 49%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
    12620:  765:        for (const Token* tok = scope->bodyStart; tok && tok != scope->bodyEnd; tok = tok->next()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 92% (fallthrough)
branch  3 taken 8%
call    4 returned 100%
    11639:  766:            const Token* secondBreak = nullptr;
    11639:  767:            const Token* labelName = nullptr;
    11639:  768:            if (tok->link() && Token::Match(tok, "(|[|<"))
call    0 returned 100%
branch  1 taken 29% (fallthrough)
branch  2 taken 71%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
branch  6 taken 35% (fallthrough)
branch  7 taken 65%
branch  8 taken 10% (fallthrough)
branch  9 taken 90%
     1167:  769:                tok = tok->link();
call    0 returned 100%
    10472:  770:            else if (Token::Match(tok, "break|continue ;"))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 1% (fallthrough)
branch  4 taken 99%
       45:  771:                secondBreak = tok->tokAt(2);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
    10427:  772:            else if (Token::Match(tok, "[;{}:] return|throw")) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 2% (fallthrough)
branch  4 taken 98%
      234:  773:                if (Token::simpleMatch(tok->astParent(), "?"))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
branch  4 taken 1% (fallthrough)
branch  5 taken 99%
        1:  774:                    continue;
      233:  775:                tok = tok->next(); // tok should point to return or throw
call    0 returned 100%
      792:  776:                for (const Token *tok2 = tok->next(); tok2; tok2 = tok2->next()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
      792:  777:                    if (tok2->str() == "(" || tok2->str() == "{")
call    0 returned 100%
call    1 returned 100%
branch  2 taken 91% (fallthrough)
branch  3 taken 9%
call    4 returned 100%
call    5 returned 100%
branch  6 taken 1% (fallthrough)
branch  7 taken 99%
branch  8 taken 9% (fallthrough)
branch  9 taken 91%
       74:  778:                        tok2 = tok2->link();
call    0 returned 100%
      792:  779:                    if (tok2->str() == ";") {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 29% (fallthrough)
branch  3 taken 71%
      233:  780:                        secondBreak = tok2->next();
call    0 returned 100%
      233:  781:                        break;
        -:  782:                    }
        -:  783:                }
    10193:  784:            } else if (Token::Match(tok, "goto %any% ;")) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 1% (fallthrough)
branch  4 taken 99%
        7:  785:                secondBreak = tok->tokAt(3);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        7:  786:                labelName = tok->next();
call    0 returned 100%
    10186:  787:            } else if (Token::Match(tok, "%name% (") && mSettings->library.isnoreturn(tok) && !Token::Match(tok->next()->astParent(), "?|:")) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 10% (fallthrough)
branch  4 taken 90%
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0% (throw)
branch  8 taken 1% (fallthrough)
branch  9 taken 99%
call   10 returned 100%
call   11 returned 100%
call   12 returned 100%
branch 13 taken 100% (fallthrough)
branch 14 taken 0% (throw)
branch 15 taken 33% (fallthrough)
branch 16 taken 67%
branch 17 taken 1% (fallthrough)
branch 18 taken 99%
        1:  788:                if ((!tok->function() || (tok->function()->token != tok && tok->function()->tokenDef != tok)) && tok->linkAt(1)->strAt(1) != "{")
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
branch 13 taken 100% (fallthrough)
branch 14 taken 0% (throw)
call   15 returned 100%
branch 16 taken 100% (fallthrough)
branch 17 taken 0%
branch 18 taken 100% (fallthrough)
branch 19 taken 0%
        1:  789:                    secondBreak = tok->linkAt(1)->tokAt(2);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        -:  790:            }
        -:  791:
        -:  792:            // Statements follow directly, no line between them. (#3383)
        -:  793:            // TODO: Try to find a better way to avoid false positives due to preprocessor configurations.
    11638:  794:            const bool inconclusive = secondBreak && (secondBreak->linenr() - 1 > secondBreak->previous()->linenr());
branch  0 taken 2% (fallthrough)
branch  1 taken 98%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
branch  5 taken 1% (fallthrough)
branch  6 taken 99%
        -:  795:
    11638:  796:            if (secondBreak && (printInconclusive || !inconclusive)) {
branch  0 taken 2% (fallthrough)
branch  1 taken 98%
branch  2 taken 22% (fallthrough)
branch  3 taken 78%
branch  4 taken 98% (fallthrough)
branch  5 taken 2%
      575:  797:                if (Token::Match(secondBreak, "continue|goto|throw") ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 99% (fallthrough)
branch  4 taken 1%
branch  5 taken 2% (fallthrough)
branch  6 taken 98%
branch  7 taken 3% (fallthrough)
branch  8 taken 97%
      288:  798:                    (secondBreak->str() == "return" && (tok->str() == "return" || secondBreak->strAt(1) == ";"))) { // return with value after statements like throw can be necessary to make a function compile
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 33% (fallthrough)
branch  5 taken 67%
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 50% (fallthrough)
branch 11 taken 50%
        8:  799:                    duplicateBreakError(secondBreak, inconclusive);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        8:  800:                    tok = Token::findmatch(secondBreak, "[}:]");
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
      277:  801:                } else if (secondBreak->str() == "break") { // break inside switch as second break statement should not issue a warning
call    0 returned 100%
call    1 returned 100%
branch  2 taken 1% (fallthrough)
branch  3 taken 99%
        4:  802:                    if (tok->str() == "break") // If the previous was a break, too: Issue warning
call    0 returned 100%
call    1 returned 100%
branch  2 taken 50% (fallthrough)
branch  3 taken 50%
        2:  803:                        duplicateBreakError(secondBreak, inconclusive);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  804:                    else {
        2:  805:                        if (tok->scope()->type != Scope::eSwitch) // Check, if the enclosing scope is a switch
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        2:  806:                            duplicateBreakError(secondBreak, inconclusive);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  807:                    }
        4:  808:                    tok = Token::findmatch(secondBreak, "[}:]");
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
      273:  809:                } else if (!Token::Match(secondBreak, "return|}|case|default") && secondBreak->strAt(1) != ":") { // TODO: No bailout for unconditional scopes
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 4% (fallthrough)
branch  4 taken 96%
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0% (throw)
call    8 returned 100%
branch  9 taken 80% (fallthrough)
branch 10 taken 20%
branch 11 taken 3% (fallthrough)
branch 12 taken 97%
        -:  810:                    // If the goto label is followed by a loop construct in which the label is defined it's quite likely
        -:  811:                    // that the goto jump was intended to skip some code on the first loop iteration.
        8:  812:                    bool labelInFollowingLoop = false;
        8:  813:                    if (labelName && Token::Match(secondBreak, "while|do|for")) {
branch  0 taken 38% (fallthrough)
branch  1 taken 63%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
branch  5 taken 100% (fallthrough)
branch  6 taken 0%
branch  7 taken 38% (fallthrough)
branch  8 taken 63%
        3:  814:                        const Token *scope2 = Token::findsimplematch(secondBreak, "{");
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        3:  815:                        if (scope2) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       15:  816:                            for (const Token *tokIter = scope2; tokIter != scope2->link() && tokIter; tokIter = tokIter->next()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 100% (fallthrough)
branch  6 taken 0%
call    7 returned 100%
       15:  817:                                if (Token::Match(tokIter, "[;{}] %any% :") && labelName->str() == tokIter->strAt(1)) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 20% (fallthrough)
branch  4 taken 80%
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0% (throw)
call    8 returned 100%
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0%
branch 12 taken 20% (fallthrough)
branch 13 taken 80%
        3:  818:                                    labelInFollowingLoop = true;
        3:  819:                                    break;
        -:  820:                                }
        -:  821:                            }
        -:  822:                        }
        -:  823:                    }
        -:  824:
        -:  825:                    // hide FP for statements that just hide compiler warnings about unused function arguments
        8:  826:                    bool silencedCompilerWarningOnly = false;
        8:  827:                    const Token *silencedWarning = secondBreak;
        -:  828:                    for (;;) {
       23:  829:                        if (Token::Match(silencedWarning, "( void ) %name% ;")) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 38% (fallthrough)
branch  4 taken 62%
        5:  830:                            silencedWarning = silencedWarning->tokAt(5);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        5:  831:                            continue;
        8:  832:                        } else if (silencedWarning && silencedWarning == scope->bodyEnd)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 25% (fallthrough)
branch  3 taken 75%
        2:  833:                            silencedCompilerWarningOnly = true;
        -:  834:
        8:  835:                        break;
        -:  836:                    }
        8:  837:                    if (silencedWarning)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        8:  838:                        secondBreak = silencedWarning;
        -:  839:
        8:  840:                    if (!labelInFollowingLoop && !silencedCompilerWarningOnly)
branch  0 taken 63% (fallthrough)
branch  1 taken 38%
branch  2 taken 60% (fallthrough)
branch  3 taken 40%
        3:  841:                        unreachableCodeError(secondBreak, inconclusive);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        8:  842:                    tok = Token::findmatch(secondBreak, "[}:]");
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  843:                } else
      265:  844:                    tok = secondBreak;
        -:  845:
      285:  846:                if (!tok)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  847:                    break;
      285:  848:                tok = tok->previous(); // Will be advanced again by for loop
call    0 returned 100%
        -:  849:            }
        -:  850:        }
        -:  851:    }
        -:  852:}
        -:  853:
function _ZN10CheckOther19duplicateBreakErrorEPK5Tokenb called 12 returned 100% blocks executed 100%
       12:  854:void CheckOther::duplicateBreakError(const Token *tok, bool inconclusive)
        -:  855:{
       12:  856:    reportError(tok, Severity::style, "duplicateBreak",
call    0 returned 100%
        -:  857:                "Consecutive return, break, continue, goto or throw statements are unnecessary.\n"
        -:  858:                "Consecutive return, break, continue, goto or throw statements are unnecessary. "
        -:  859:                "The second statement can never be executed, and so should be removed.", CWE561, inconclusive);
       12:  860:}
        -:  861:
function _ZN10CheckOther20unreachableCodeErrorEPK5Tokenb called 3 returned 100% blocks executed 100%
        3:  862:void CheckOther::unreachableCodeError(const Token *tok, bool inconclusive)
        -:  863:{
        3:  864:    reportError(tok, Severity::style, "unreachableCode",
call    0 returned 100%
        -:  865:                "Statements following return, break, continue, goto or throw will never be executed.", CWE561, inconclusive);
        3:  866:}
        -:  867:
        -:  868://---------------------------------------------------------------------------
        -:  869:// Check scope of variables..
        -:  870://---------------------------------------------------------------------------
function _ZN10CheckOther18checkVariableScopeEv called 927 returned 100% blocks executed 95%
      927:  871:void CheckOther::checkVariableScope()
        -:  872:{
      927:  873:    if (!mSettings->isEnabled(Settings::STYLE))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  874:        return;
        -:  875:
      927:  876:    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
call    0 returned 100%
        -:  877:
     3453:  878:    for (const Variable* var : symbolDatabase->variableList()) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 73% (fallthrough)
branch  5 taken 27%
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 returned 100%
call   10 never executed
call   11 never executed
     2526:  879:        if (!var || !var->isLocal() || (!var->isPointer() && !var->isReference() && !var->typeStartToken()->isStandardType()))
branch  0 taken 60% (fallthrough)
branch  1 taken 40%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
branch  5 taken 42% (fallthrough)
branch  6 taken 58%
call    7 returned 100%
branch  8 taken 90% (fallthrough)
branch  9 taken 10%
call   10 returned 100%
branch 11 taken 96% (fallthrough)
branch 12 taken 4%
call   13 returned 100%
call   14 returned 100%
branch 15 taken 100% (fallthrough)
branch 16 taken 0% (throw)
branch 17 taken 21% (fallthrough)
branch 18 taken 79%
branch 19 taken 79% (fallthrough)
branch 20 taken 21%
     4087:  880:            continue;
        -:  881:
      523:  882:        if (var->isConst())
call    0 returned 100%
branch  1 taken 6% (fallthrough)
branch  2 taken 94%
       33:  883:            continue;
        -:  884:
        -:  885:        // reference of range for loop variable..
      490:  886:        if (Token::Match(var->nameToken()->previous(), "& %var% = %var% .")) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
branch  5 taken 1% (fallthrough)
branch  6 taken 99%
        2:  887:            const Token *otherVarToken = var->nameToken()->tokAt(2);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
        2:  888:            const Variable *otherVar = otherVarToken->variable();
call    0 returned 100%
        5:  889:            if (otherVar && Token::Match(otherVar->nameToken(), "%var% :") &&
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
branch  4 taken 50% (fallthrough)
branch  5 taken 50%
branch  6 taken 100% (fallthrough)
branch  7 taken 0%
branch  8 taken 50% (fallthrough)
branch  9 taken 50%
        4:  890:                otherVar->nameToken()->next()->astParent() &&
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0%
        1:  891:                Token::simpleMatch(otherVar->nameToken()->next()->astParent()->previous(), "for ("))
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
        1:  892:                continue;
        -:  893:        }
        -:  894:
      489:  895:        bool forHead = false; // Don't check variables declared in header of a for loop
      990:  896:        for (const Token* tok = var->typeStartToken(); tok; tok = tok->previous()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
      990:  897:            if (tok->str() == "(") {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 2% (fallthrough)
branch  3 taken 98%
       21:  898:                forHead = true;
       21:  899:                break;
      969:  900:            } else if (Token::Match(tok, "[;{}]"))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 48% (fallthrough)
branch  4 taken 52%
      468:  901:                break;
        -:  902:        }
      489:  903:        if (forHead)
branch  0 taken 4% (fallthrough)
branch  1 taken 96%
       21:  904:            continue;
        -:  905:
      468:  906:        const Token* tok = var->nameToken()->next();
call    0 returned 100%
call    1 returned 100%
      468:  907:        if (Token::Match(tok, "; %varid% = %any% ;", var->declarationId())) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
branch  4 taken 42% (fallthrough)
branch  5 taken 58%
      198:  908:            tok = tok->tokAt(3);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
      198:  909:            if (!tok->isNumber() && tok->tokType() != Token::eString && tok->tokType() != Token::eChar && !tok->isBoolean())
call    0 returned 100%
branch  1 taken 11% (fallthrough)
branch  2 taken 89%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0%
call    9 returned 100%
branch 10 taken 82% (fallthrough)
branch 11 taken 18%
branch 12 taken 9% (fallthrough)
branch 13 taken 91%
       18:  910:                continue;
        -:  911:        }
        -:  912:        // bailout if initialized with function call that has possible side effects
      450:  913:        if (Token::Match(tok, "[(=]") && Token::simpleMatch(tok->astOperand2(), "("))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 4% (fallthrough)
branch  4 taken 96%
call    5 returned 100%
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
branch  9 taken 40% (fallthrough)
branch 10 taken 60%
branch 11 taken 2% (fallthrough)
branch 12 taken 98%
        8:  914:            continue;
      442:  915:        bool reduce = true;
      442:  916:        bool used = false; // Don't warn about unused variables
     4814:  917:        for (; tok && tok != var->scope()->bodyEnd; tok = tok->next()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 99% (fallthrough)
branch  4 taken 1%
branch  5 taken 99% (fallthrough)
branch  6 taken 1%
call    7 returned 100%
     2600:  918:            if (tok->str() == "{" && tok->scope() != tok->previous()->scope() && !tok->isExpandedMacro() && tok->scope()->type != Scope::eLambda) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 5% (fallthrough)
branch  3 taken 95%
call    4 returned 100%
call    5 returned 100%
call    6 returned 100%
branch  7 taken 91% (fallthrough)
branch  8 taken 9%
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
branch 12 taken 100% (fallthrough)
branch 13 taken 0%
call   14 returned 100%
branch 15 taken 97% (fallthrough)
branch 16 taken 3%
branch 17 taken 5% (fallthrough)
branch 18 taken 96%
      117:  919:                if (used) {
branch  0 taken 5% (fallthrough)
branch  1 taken 95%
        6:  920:                    bool used2 = false;
        6:  921:                    if (!checkInnerScope(tok, var, used2) || used2) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 67% (fallthrough)
branch  6 taken 33%
branch  7 taken 67% (fallthrough)
branch  8 taken 33%
        4:  922:                        reduce = false;
        4:  923:                        break;
        -:  924:                    }
      111:  925:                } else if (!checkInnerScope(tok, var, used)) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 65% (fallthrough)
branch  4 taken 35%
       72:  926:                    reduce = false;
       72:  927:                    break;
        -:  928:                }
        -:  929:
       41:  930:                tok = tok->link();
call    0 returned 100%
        -:  931:
        -:  932:                // parse else if blocks..
     2483:  933:            } else if (Token::simpleMatch(tok, "else { if (") && Token::simpleMatch(tok->linkAt(3), ") {")) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 1% (fallthrough)
branch  4 taken 99%
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0% (throw)
call    8 returned 100%
branch  9 taken 100% (fallthrough)
branch 10 taken 0% (throw)
branch 11 taken 100% (fallthrough)
branch 12 taken 0%
branch 13 taken 1% (fallthrough)
branch 14 taken 99%
        3:  934:                const Token *endif = tok->linkAt(3)->linkAt(1);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        3:  935:                bool elseif = false;
        3:  936:                if (Token::simpleMatch(endif, "} }"))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 33% (fallthrough)
branch  4 taken 67%
        1:  937:                    elseif = true;
        2:  938:                else if (Token::simpleMatch(endif, "} else {") && Token::simpleMatch(endif->linkAt(2),"} }"))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0% (throw)
call    8 returned 100%
branch  9 taken 100% (fallthrough)
branch 10 taken 0% (throw)
branch 11 taken 100% (fallthrough)
branch 12 taken 0%
branch 13 taken 100% (fallthrough)
branch 14 taken 0%
        2:  939:                    elseif = true;
        3:  940:                if (elseif && Token::findmatch(tok->next(), "%varid%", tok->linkAt(1), var->declarationId())) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 returned 100%
branch  8 taken 100% (fallthrough)
branch  9 taken 0% (throw)
branch 10 taken 100% (fallthrough)
branch 11 taken 0%
branch 12 taken 100% (fallthrough)
branch 13 taken 0%
        3:  941:                    reduce = false;
        3:  942:                    break;
        -:  943:                }
     2480:  944:            } else if (tok->varId() == var->declarationId() || tok->str() == "goto") {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 86% (fallthrough)
branch  3 taken 14%
call    4 returned 100%
call    5 returned 100%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
branch  8 taken 14% (fallthrough)
branch  9 taken 86%
      335:  945:                reduce = false;
      335:  946:                break;
        -:  947:            }
        -:  948:        }
        -:  949:
      442:  950:        if (reduce && used)
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
branch  2 taken 46% (fallthrough)
branch  3 taken 54%
       13:  951:            variableScopeError(var->nameToken(), var->name());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
        -:  952:    }
        -:  953:}
        -:  954:
function _ZN10CheckOther15checkInnerScopeEPK5TokenPK8VariableRb called 131 returned 100% blocks executed 92%
      131:  955:bool CheckOther::checkInnerScope(const Token *tok, const Variable* var, bool& used)
        -:  956:{
      131:  957:    const Scope* scope = tok->next()->scope();
call    0 returned 100%
call    1 returned 100%
      131:  958:    bool loopVariable = scope->type == Scope::eFor || scope->type == Scope::eWhile || scope->type == Scope::eDo;
branch  0 taken 98% (fallthrough)
branch  1 taken 2%
branch  2 taken 93% (fallthrough)
branch  3 taken 7%
branch  4 taken 11% (fallthrough)
branch  5 taken 89%
      131:  959:    bool noContinue = true;
      131:  960:    const Token* forHeadEnd = nullptr;
      131:  961:    const Token* end = tok->link();
call    0 returned 100%
      131:  962:    if (scope->type == Scope::eUnconditional && (tok->strAt(-1) == ")" || tok->previous()->isName())) // Might be an unknown macro like BOOST_FOREACH
branch  0 taken 8% (fallthrough)
branch  1 taken 92%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 82% (fallthrough)
branch  5 taken 18%
call    6 returned 100%
call    7 returned 100%
branch  8 taken 22% (fallthrough)
branch  9 taken 78%
branch 10 taken 3% (fallthrough)
branch 11 taken 97%
        4:  963:        loopVariable = true;
        -:  964:
      131:  965:    if (scope->type == Scope::eDo) {
branch  0 taken 10% (fallthrough)
branch  1 taken 90%
       13:  966:        end = end->linkAt(2);
call    0 returned 100%
      118:  967:    } else if (loopVariable && tok->strAt(-1) == ")") {
branch  0 taken 13% (fallthrough)
branch  1 taken 87%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 87% (fallthrough)
branch  5 taken 13%
branch  6 taken 11% (fallthrough)
branch  7 taken 89%
       13:  968:        tok = tok->linkAt(-1); // Jump to opening ( of for/while statement
call    0 returned 100%
      105:  969:    } else if (scope->type == Scope::eSwitch) {
branch  0 taken 54% (fallthrough)
branch  1 taken 46%
       70:  970:        for (const Scope* innerScope : scope->nestedList) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 20% (fallthrough)
branch  4 taken 80%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
branch  8 taken 98%
branch  9 taken 2%
call   10 returned 100%
branch 11 taken 98%
branch 12 taken 2%
call   13 never executed
call   14 never executed
       14:  971:            if (used) {
branch  0 taken 7% (fallthrough)
branch  1 taken 93%
        1:  972:                bool used2 = false;
        1:  973:                if (!checkInnerScope(innerScope->bodyStart, var, used2) || used2) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 100% (fallthrough)
branch  6 taken 0%
branch  7 taken 100% (fallthrough)
branch  8 taken 0%
        1:  974:                    return false;
        -:  975:                }
       13:  976:            } else if (!checkInnerScope(innerScope->bodyStart, var, used)) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####:  977:                return false;
        -:  978:            }
        -:  979:        }
        -:  980:    }
        -:  981:
      130:  982:    bool bFirstAssignment=false;
     2434:  983:    for (; tok && tok != end; tok = tok->next()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 95% (fallthrough)
branch  3 taken 5%
call    4 returned 100%
     1223:  984:        if (tok->str() == "goto")
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  985:            return false;
     1223:  986:        if (tok->str() == "continue")
call    0 returned 100%
call    1 returned 100%
branch  2 taken 1% (fallthrough)
branch  3 taken 99%
        1:  987:            noContinue = false;
        -:  988:
     1223:  989:        if (Token::simpleMatch(tok, "for ("))
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 99%
        2:  990:            forHeadEnd = tok->linkAt(1);
call    0 returned 100%
     1223:  991:        if (tok == forHeadEnd)
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        2:  992:            forHeadEnd = nullptr;
        -:  993:
     1223:  994:        if (loopVariable && noContinue && tok->scope() == scope && !forHeadEnd && scope->type != Scope::eSwitch && Token::Match(tok, "%varid% =", var->declarationId())) { // Assigned in outer scope.
branch  0 taken 18% (fallthrough)
branch  1 taken 82%
branch  2 taken 94% (fallthrough)
branch  3 taken 6%
call    4 returned 100%
branch  5 taken 41% (fallthrough)
branch  6 taken 59%
branch  7 taken 100% (fallthrough)
branch  8 taken 0%
branch  9 taken 100% (fallthrough)
branch 10 taken 0%
call   11 returned 100%
call   12 returned 100%
branch 13 taken 15% (fallthrough)
branch 14 taken 85%
branch 15 taken 1% (fallthrough)
branch 16 taken 99%
       13:  995:            loopVariable = false;
       13:  996:            int indent = 0;
       60:  997:            for (const Token* tok2 = tok->tokAt(2); tok2; tok2 = tok2->next()) { // Ensure that variable isn't used on right side of =, too
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
       60:  998:                if (tok2->str() == "(")
call    0 returned 100%
call    1 returned 100%
branch  2 taken 17% (fallthrough)
branch  3 taken 83%
       10:  999:                    indent++;
       50: 1000:                else if (tok2->str() == ")") {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 20% (fallthrough)
branch  3 taken 80%
       10: 1001:                    if (indent == 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1002:                        break;
       10: 1003:                    indent--;
       40: 1004:                } else if (tok2->str() == ";")
call    0 returned 100%
call    1 returned 100%
branch  2 taken 33% (fallthrough)
branch  3 taken 68%
       13: 1005:                    break;
       27: 1006:                else if (tok2->varId() == var->declarationId()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 1007:                    loopVariable = true;
    #####: 1008:                    break;
        -: 1009:                }
        -: 1010:            }
        -: 1011:        }
        -: 1012:
     1223: 1013:        if (loopVariable && Token::Match(tok, "%varid% !!=", var->declarationId())) // Variable used in loop
branch  0 taken 17% (fallthrough)
branch  1 taken 83%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 6% (fallthrough)
branch  5 taken 94%
branch  6 taken 1% (fallthrough)
branch  7 taken 99%
       13: 1014:            return false;
        -: 1015:
     1210: 1016:        if (Token::Match(tok, "& %varid%", var->declarationId())) // Taking address of variable
call    0 returned 100%
call    1 returned 100%
branch  2 taken 1% (fallthrough)
branch  3 taken 99%
        2: 1017:            return false;
        -: 1018:
     1208: 1019:        if (Token::Match(tok, "%varid% =", var->declarationId()))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 5% (fallthrough)
branch  3 taken 95%
       61: 1020:            bFirstAssignment = true;
        -: 1021:
     1208: 1022:        if (!bFirstAssignment && Token::Match(tok, "* %varid%", var->declarationId())) // dereferencing means access to previous content
branch  0 taken 66% (fallthrough)
branch  1 taken 34%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 1% (fallthrough)
branch  5 taken 99%
branch  6 taken 1% (fallthrough)
branch  7 taken 99%
        1: 1023:            return false;
        -: 1024:
     1207: 1025:        if (Token::Match(tok, "= %varid%", var->declarationId()) && (var->isArray() || var->isPointer())) // Create a copy of array/pointer. Bailout, because the memory it points to might be necessary in outer scope
call    0 returned 100%
call    1 returned 100%
branch  2 taken 1% (fallthrough)
branch  3 taken 99%
call    4 returned 100%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
call    7 never executed
branch  8 never executed
branch  9 never executed
branch 10 taken 1% (fallthrough)
branch 11 taken 99%
        1: 1026:            return false;
        -: 1027:
     1206: 1028:        if (tok->varId() == var->declarationId()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 12% (fallthrough)
branch  3 taken 88%
      147: 1029:            used = true;
      147: 1030:            if (scope->type == Scope::eSwitch && scope == tok->scope())
branch  0 taken 44% (fallthrough)
branch  1 taken 56%
call    2 returned 100%
branch  3 taken 83% (fallthrough)
branch  4 taken 17%
branch  5 taken 37% (fallthrough)
branch  6 taken 63%
       54: 1031:                return false; // Used in outer switch scope - unsafe or impossible to reduce scope
        -: 1032:        }
        -: 1033:    }
        -: 1034:
       59: 1035:    return true;
        -: 1036:}
        -: 1037:
function _ZN10CheckOther18variableScopeErrorEPK5TokenRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 13 returned 100% blocks executed 58%
       13: 1038:void CheckOther::variableScopeError(const Token *tok, const std::string &varname)
        -: 1039:{
       26: 1040:    reportError(tok,
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -: 1041:                Severity::style,
        -: 1042:                "variableScope",
       26: 1043:                "$symbol:" + varname + "\n"
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
call    5 returned 100%
call    6 never executed
call    7 never executed
        -: 1044:                "The scope of the variable '$symbol' can be reduced.\n"
        -: 1045:                "The scope of the variable '$symbol' can be reduced. Warning: Be careful "
        -: 1046:                "when fixing this message, especially when there are inner loops. Here is an "
        -: 1047:                "example where cppcheck will write that the scope for 'i' can be reduced:\n"
        -: 1048:                "void f(int x)\n"
        -: 1049:                "{\n"
        -: 1050:                "    int i = 0;\n"
        -: 1051:                "    if (x) {\n"
        -: 1052:                "        // it's safe to move 'int i = 0;' here\n"
        -: 1053:                "        for (int n = 0; n < 10; ++n) {\n"
        -: 1054:                "            // it is possible but not safe to move 'int i = 0;' here\n"
        -: 1055:                "            do_something(&i);\n"
        -: 1056:                "        }\n"
        -: 1057:                "    }\n"
        -: 1058:                "}\n"
        -: 1059:                "When you see this message it is always safe to reduce the variable scope 1 level.", CWE398, false);
       13: 1060:}
        -: 1061:
        -: 1062://---------------------------------------------------------------------------
        -: 1063:// Comma in return statement: return a+1, b++;. (experimental)
        -: 1064://---------------------------------------------------------------------------
function _ZN10CheckOther25checkCommaSeparatedReturnEv called 927 returned 100% blocks executed 96%
      927: 1065:void CheckOther::checkCommaSeparatedReturn()
        -: 1066:{
        -: 1067:    // This is experimental for now. See #5076
      927: 1068:    if (!mSettings->experimental)
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
      921: 1069:        return;
        -: 1070:
        6: 1071:    if (!mSettings->isEnabled(Settings::STYLE))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1072:        return;
        -: 1073:
      103: 1074:    for (const Token *tok = mTokenizer->tokens(); tok; tok = tok->next()) {
call    0 returned 100%
branch  1 taken 94% (fallthrough)
branch  2 taken 6%
call    3 returned 100%
       97: 1075:        if (tok->str() == "return") {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 6% (fallthrough)
branch  3 taken 94%
        6: 1076:            tok = tok->next();
call    0 returned 100%
       60: 1077:            while (tok && tok->str() != ";") {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 82% (fallthrough)
branch  5 taken 18%
branch  6 taken 82% (fallthrough)
branch  7 taken 18%
       27: 1078:                if (tok->link() && Token::Match(tok, "[([{<]"))
call    0 returned 100%
branch  1 taken 22% (fallthrough)
branch  2 taken 78%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 taken 22% (fallthrough)
branch  7 taken 78%
        6: 1079:                    tok = tok->link();
call    0 returned 100%
        -: 1080:
       27: 1081:                if (!tok->isExpandedMacro() && tok->str() == "," && tok->linenr() != tok->next()->linenr())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
call    4 returned 100%
branch  5 taken 15% (fallthrough)
branch  6 taken 85%
call    7 returned 100%
call    8 returned 100%
call    9 returned 100%
branch 10 taken 50% (fallthrough)
branch 11 taken 50%
branch 12 taken 7% (fallthrough)
branch 13 taken 93%
        2: 1082:                    commaSeparatedReturnError(tok);
call    0 returned 100%
        -: 1083:
       27: 1084:                tok = tok->next();
call    0 returned 100%
        -: 1085:            }
        -: 1086:            // bailout: missing semicolon (invalid code / bad tokenizer)
        6: 1087:            if (!tok)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1088:                break;
        -: 1089:        }
        -: 1090:    }
        -: 1091:}
        -: 1092:
function _ZN10CheckOther25commaSeparatedReturnErrorEPK5Token called 2 returned 100% blocks executed 100%
        2: 1093:void CheckOther::commaSeparatedReturnError(const Token *tok)
        -: 1094:{
        2: 1095:    reportError(tok,
call    0 returned 100%
        -: 1096:                Severity::style,
        -: 1097:                "commaSeparatedReturn",
        -: 1098:                "Comma is used in return statement. The comma can easily be misread as a ';'.\n"
        -: 1099:                "Comma is used in return statement. When comma is used in a return statement it can "
        -: 1100:                "easily be misread as a semicolon. For example in the code below the value "
        -: 1101:                "of 'b' is returned if the condition is true, but it is easy to think that 'a+1' is "
        -: 1102:                "returned:\n"
        -: 1103:                "    if (x)\n"
        -: 1104:                "        return a + 1,\n"
        -: 1105:                "    b++;\n"
        -: 1106:                "However it can be useful to use comma in macros. Cppcheck does not warn when such a "
        -: 1107:                "macro is then used in a return statement, it is less likely such code is misunderstood.", CWE398, false);
        2: 1108:}
        -: 1109:
        -: 1110://---------------------------------------------------------------------------
        -: 1111:// Check for function parameters that should be passed by const reference
        -: 1112://---------------------------------------------------------------------------
function _ZL12estimateSizePK4TypePK8SettingsPK14SymbolDatabasei called 40 returned 100% blocks executed 85%
       40: 1113:static int estimateSize(const Type* type, const Settings* settings, const SymbolDatabase* symbolDatabase, int recursionDepth = 0)
        -: 1114:{
       40: 1115:    if (recursionDepth > 20)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1116:        return 0;
        -: 1117:
       40: 1118:    int cumulatedSize = 0;
       86: 1119:    for (const Variable&var : type->classScope->varlist) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 53% (fallthrough)
branch  4 taken 47%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
call   11 never executed
       46: 1120:        int size = 0;
       46: 1121:        if (var.isStatic())
call    0 returned 100%
branch  1 taken 2% (fallthrough)
branch  2 taken 98%
        1: 1122:            continue;
       45: 1123:        if (var.isPointer() || var.isReference())
call    0 returned 100%
branch  1 taken 89% (fallthrough)
branch  2 taken 11%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
branch  6 taken 11% (fallthrough)
branch  7 taken 89%
        5: 1124:            size = settings->sizeof_pointer;
       40: 1125:        else if (var.type() && var.type()->classScope)
call    0 returned 100%
branch  1 taken 3% (fallthrough)
branch  2 taken 98%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 taken 3% (fallthrough)
branch  7 taken 98%
        1: 1126:            size = estimateSize(var.type(), settings, symbolDatabase, recursionDepth+1);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
       39: 1127:        else if (var.valueType()->type == ValueType::Type::CONTAINER)
call    0 returned 100%
branch  1 taken 44% (fallthrough)
branch  2 taken 56%
       17: 1128:            size = 3 * settings->sizeof_pointer; // Just guess
        -: 1129:        else
       22: 1130:            size = symbolDatabase->sizeOfType(var.typeStartToken());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
        -: 1131:
       45: 1132:        if (var.isArray())
call    0 returned 100%
branch  1 taken 9% (fallthrough)
branch  2 taken 91%
        4: 1133:            cumulatedSize += size * var.dimension(0);
call    0 returned 100%
        -: 1134:        else
       41: 1135:            cumulatedSize += size;
        -: 1136:    }
       42: 1137:    for (const Type::BaseInfo &baseInfo : type->derivedFrom) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 5% (fallthrough)
branch  4 taken 95%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
        2: 1138:        if (baseInfo.type && baseInfo.type->classScope)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        2: 1139:            cumulatedSize += estimateSize(baseInfo.type, settings, symbolDatabase, recursionDepth+1);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -: 1140:    }
       40: 1141:    return cumulatedSize;
        -: 1142:}
        -: 1143:
function _ZL10canBeConstPK8Variable called 38 returned 100% blocks executed 91%
       38: 1144:static bool canBeConst(const Variable *var)
        -: 1145:{
        -: 1146:    {
        -: 1147:        // check initializer list. If variable is moved from it can't be const.
       38: 1148:        const Function* func_scope = var->scope()->function;
call    0 returned 100%
       38: 1149:        if (func_scope->type == Function::Type::eConstructor) {
branch  0 taken 21% (fallthrough)
branch  1 taken 79%
        -: 1150:            //could be initialized in initializer list
        8: 1151:            if (func_scope->arg->link()->next()->str() == ":") {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
       82: 1152:                for (const Token* tok2 = func_scope->arg->link()->next()->next(); tok2 != var->scope()->bodyStart; tok2 = tok2->next()) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 98% (fallthrough)
branch  5 taken 2%
call    6 returned 100%
       80: 1153:                    if (tok2->varId() != var->declarationId())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 90% (fallthrough)
branch  3 taken 10%
       72: 1154:                        continue;
        8: 1155:                    const Token* parent = tok2->astParent();
call    0 returned 100%
        8: 1156:                    if (parent && Token::simpleMatch(parent->previous(), "move ("))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 75% (fallthrough)
branch  5 taken 25%
branch  6 taken 75% (fallthrough)
branch  7 taken 25%
        6: 1157:                        return false;
        -: 1158:                }
        -: 1159:            }
        -: 1160:        }
        -: 1161:    }
      189: 1162:    for (const Token* tok2 = var->scope()->bodyStart; tok2 != var->scope()->bodyEnd; tok2 = tok2->next()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 92% (fallthrough)
branch  3 taken 8%
call    4 returned 100%
      173: 1163:        if (tok2->varId() != var->declarationId())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 86% (fallthrough)
branch  3 taken 14%
      149: 1164:            continue;
        -: 1165:
       24: 1166:        const Token* parent = tok2->astParent();
call    0 returned 100%
       24: 1167:        if (!parent)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1168:            continue;
       24: 1169:        if (parent->str() == "<<" || isLikelyStreamRead(true, parent)) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 96% (fallthrough)
branch  3 taken 4%
call    4 returned 100%
branch  5 taken 4% (fallthrough)
branch  6 taken 96%
branch  7 taken 8% (fallthrough)
branch  8 taken 92%
        2: 1170:            if (parent->str() == "<<" && parent->astOperand1() == tok2)
call    0 returned 100%
call    1 returned 100%
branch  2 taken 50% (fallthrough)
branch  3 taken 50%
call    4 returned 100%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
branch  7 taken 0% (fallthrough)
branch  8 taken 100%
    #####: 1171:                return false;
        2: 1172:            if (parent->str() == ">>" && parent->astOperand2() == tok2)
call    0 returned 100%
call    1 returned 100%
branch  2 taken 50% (fallthrough)
branch  3 taken 50%
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0%
branch  7 taken 50% (fallthrough)
branch  8 taken 50%
        1: 1173:                return false;
       22: 1174:        } else if (parent->str() == "," || parent->str() == "(") { // function argument
call    0 returned 100%
call    1 returned 100%
branch  2 taken 95% (fallthrough)
branch  3 taken 5%
call    4 returned 100%
call    5 returned 100%
branch  6 taken 43% (fallthrough)
branch  7 taken 57%
branch  8 taken 45% (fallthrough)
branch  9 taken 55%
       10: 1175:            const Token* tok3 = tok2->previous();
call    0 returned 100%
       10: 1176:            int argNr = 0;
       18: 1177:            while (tok3 && tok3->str() != "(") {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 29% (fallthrough)
branch  5 taken 71%
branch  6 taken 29% (fallthrough)
branch  7 taken 71%
        4: 1178:                if (tok3->link() && Token::Match(tok3, ")|]|}|>"))
call    0 returned 100%
branch  1 taken 25% (fallthrough)
branch  2 taken 75%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 taken 25% (fallthrough)
branch  7 taken 75%
        1: 1179:                    tok3 = tok3->link();
call    0 returned 100%
        3: 1180:                else if (tok3->link())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1181:                    break;
        3: 1182:                else if (tok3->str() == ";")
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 1183:                    break;
        3: 1184:                else if (tok3->str() == ",")
call    0 returned 100%
call    1 returned 100%
branch  2 taken 33% (fallthrough)
branch  3 taken 67%
        1: 1185:                    argNr++;
        4: 1186:                tok3 = tok3->previous();
call    0 returned 100%
        -: 1187:            }
       10: 1188:            if (!tok3 || tok3->str() != "(" || !tok3->astOperand1() || !tok3->astOperand1()->function())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0%
call    9 returned 100%
call   10 returned 100%
branch 11 taken 60% (fallthrough)
branch 12 taken 40%
branch 13 taken 60% (fallthrough)
branch 14 taken 40%
        6: 1189:                return false;
        -: 1190:            else {
        4: 1191:                const Variable* argVar = tok3->astOperand1()->function()->getArgumentVar(argNr);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        4: 1192:                if (!argVar|| (!argVar->isConst() && argVar->isReference()))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 50% (fallthrough)
branch  4 taken 50%
call    5 returned 100%
branch  6 taken 50% (fallthrough)
branch  7 taken 50%
branch  8 taken 25% (fallthrough)
branch  9 taken 75%
        1: 1193:                    return false;
        -: 1194:            }
       12: 1195:        } else if (parent->isUnaryOp("&")) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 returned 100%
branch  9 taken 8% (fallthrough)
branch 10 taken 92%
call   11 never executed
call   12 never executed
        -: 1196:            // TODO: check how pointer is used
        1: 1197:            return false;
       11: 1198:        } else if (parent->isConstOp())
call    0 returned 100%
branch  1 taken 9% (fallthrough)
branch  2 taken 91%
        1: 1199:            continue;
       10: 1200:        else if (parent->isAssignmentOp()) {
call    0 returned 100%
branch  1 taken 50% (fallthrough)
branch  2 taken 50%
        5: 1201:            if (parent->astOperand1() == tok2)
call    0 returned 100%
branch  1 taken 40% (fallthrough)
branch  2 taken 60%
        2: 1202:                return false;
        3: 1203:            else if (parent->astOperand1()->str() == "&") {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 33% (fallthrough)
branch  4 taken 67%
        1: 1204:                const Variable* assignedVar = parent->previous()->variable();
call    0 returned 100%
call    1 returned 100%
        1: 1205:                if (!assignedVar || !assignedVar->isConst())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 100% (fallthrough)
branch  6 taken 0%
        1: 1206:                    return false;
        -: 1207:            }
        5: 1208:        } else if (Token::Match(tok2, "%var% . %name% (")) {
call    0 returned 100%
branch  1 taken 20% (fallthrough)
branch  2 taken 80%
        1: 1209:            const Function* func = tok2->tokAt(2)->function();
call    0 returned 100%
call    1 returned 100%
        1: 1210:            if (func && (func->isConst() || func->isStatic()))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
branch  6 never executed
branch  7 never executed
branch  8 taken 100% (fallthrough)
branch  9 taken 0%
        1: 1211:                continue;
        -: 1212:            else
    #####: 1213:                return false;
        -: 1214:        } else
        4: 1215:            return false;
        -: 1216:    }
        -: 1217:
       16: 1218:    return true;
        -: 1219:}
        -: 1220:
function _ZN10CheckOther20checkPassByReferenceEv called 927 returned 100% blocks executed 96%
      927: 1221:void CheckOther::checkPassByReference()
        -: 1222:{
      927: 1223:    if (!mSettings->isEnabled(Settings::PERFORMANCE) || mTokenizer->isC())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 2% (fallthrough)
branch  5 taken 98%
branch  6 taken 2% (fallthrough)
branch  7 taken 98%
       22: 1224:        return;
        -: 1225:
      905: 1226:    const SymbolDatabase * const symbolDatabase = mTokenizer->getSymbolDatabase();
call    0 returned 100%
        -: 1227:
     3377: 1228:    for (const Variable* var : symbolDatabase->variableList()) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 73% (fallthrough)
branch  5 taken 27%
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 returned 100%
call   10 never executed
call   11 never executed
     2472: 1229:        if (!var || !var->isArgument() || !var->isClass() || var->isPointer() || var->isArray() || var->isReference() || var->isEnumType())
branch  0 taken 60% (fallthrough)
branch  1 taken 40%
call    2 returned 100%
branch  3 taken 45% (fallthrough)
branch  4 taken 55%
call    5 returned 100%
branch  6 taken 15% (fallthrough)
branch  7 taken 85%
call    8 returned 100%
branch  9 taken 100% (fallthrough)
branch 10 taken 0%
call   11 returned 100%
branch 12 taken 100% (fallthrough)
branch 13 taken 0%
call   14 returned 100%
branch 15 taken 100% (fallthrough)
branch 16 taken 0%
call   17 returned 100%
branch 18 taken 100% (fallthrough)
branch 19 taken 0% (throw)
branch 20 taken 0% (fallthrough)
branch 21 taken 100%
branch 22 taken 96% (fallthrough)
branch 23 taken 4%
     2370: 1230:            continue;
        -: 1231:
      102: 1232:        if (var->scope() && var->scope()->function->arg->link()->strAt(-1) == "...")
call    0 returned 100%
branch  1 taken 85% (fallthrough)
branch  2 taken 15%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0% (throw)
call    8 returned 100%
branch  9 taken 1% (fallthrough)
branch 10 taken 99%
branch 11 taken 1% (fallthrough)
branch 12 taken 99%
        1: 1233:            continue; // references could not be used as va_start parameters (#5824)
        -: 1234:
      202: 1235:        if ((var->declEndToken() && var->declEndToken()->isExternC()) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0% (throw)
call    8 returned 100%
branch  9 taken 100% (fallthrough)
branch 10 taken 0% (throw)
branch 11 taken 96% (fallthrough)
branch 12 taken 4%
branch 13 taken 86% (fallthrough)
branch 14 taken 14%
branch 15 taken 4% (fallthrough)
branch 16 taken 96%
      180: 1236:            (var->scope() && var->scope()->function && var->scope()->function->tokenDef && var->scope()->function->tokenDef->isExternC()))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0%
call    7 returned 100%
call    8 returned 100%
branch  9 taken 100% (fallthrough)
branch 10 taken 0% (throw)
branch 11 taken 0% (fallthrough)
branch 12 taken 100%
        4: 1237:            continue; // references cannot be used in functions in extern "C" blocks
        -: 1238:
       97: 1239:        bool inconclusive = false;
        -: 1240:
       97: 1241:        if (var->valueType()->type == ValueType::Type::CONTAINER) {
call    0 returned 100%
branch  1 taken 66% (fallthrough)
branch  2 taken 34%
       90: 1242:        } else if (var->type() && !var->type()->isEnumType()) { // Check if type is a struct or class.
call    0 returned 100%
branch  1 taken 59% (fallthrough)
branch  2 taken 41%
call    3 returned 100%
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
branch  7 taken 100% (fallthrough)
branch  8 taken 0%
branch  9 taken 59% (fallthrough)
branch 10 taken 41%
        -: 1243:            // Ensure that it is a large object.
       38: 1244:            if (!var->type()->classScope)
call    0 returned 100%
branch  1 taken 3% (fallthrough)
branch  2 taken 97%
        1: 1245:                inconclusive = true;
       37: 1246:            else if (estimateSize(var->type(), mSettings, symbolDatabase) <= 2 * mSettings->sizeof_pointer)
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
branch  4 taken 38% (fallthrough)
branch  5 taken 62%
       14: 1247:                continue;
        -: 1248:        } else
       26: 1249:            continue;
        -: 1250:
       57: 1251:        if (inconclusive && !mSettings->inconclusive)
branch  0 taken 2% (fallthrough)
branch  1 taken 98%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 1252:            continue;
        -: 1253:
       57: 1254:        const bool isConst = var->isConst();
call    0 returned 100%
       71: 1255:        if (isConst) {
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
       14: 1256:            passedByValueError(var->nameToken(), var->name(), inconclusive);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
       14: 1257:            continue;
        -: 1258:        }
        -: 1259:
        -: 1260:        // Check if variable could be const
       43: 1261:        if (!var->scope() || var->scope()->function->hasVirtualSpecifier())
call    0 returned 100%
branch  1 taken 91% (fallthrough)
branch  2 taken 9%
call    3 returned 100%
call    4 returned 100%
branch  5 taken 3% (fallthrough)
branch  6 taken 97%
branch  7 taken 12% (fallthrough)
branch  8 taken 88%
        5: 1262:            continue;
        -: 1263:
       38: 1264:        if (canBeConst(var)) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 42% (fallthrough)
branch  4 taken 58%
       16: 1265:            passedByValueError(var->nameToken(), var->name(), inconclusive);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
        -: 1266:        }
        -: 1267:    }
        -: 1268:}
        -: 1269:
function _ZN10CheckOther18passedByValueErrorEPK5TokenRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEb called 30 returned 100% blocks executed 58%
       30: 1270:void CheckOther::passedByValueError(const Token *tok, const std::string &parname, bool inconclusive)
        -: 1271:{
       60: 1272:    reportError(tok, Severity::performance, "passedByValue",
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       60: 1273:                "$symbol:" + parname + "\n"
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
call    5 returned 100%
call    6 never executed
call    7 never executed
        -: 1274:                "Function parameter '$symbol' should be passed by const reference.\n"
        -: 1275:                "Parameter '$symbol' is passed by value. It could be passed "
        -: 1276:                "as a const reference which is usually faster and recommended in C++.", CWE398, inconclusive);
       30: 1277:}
        -: 1278:
function _ZL16isUnusedVariablePK8Variable called 37 returned 100% blocks executed 74%
       37: 1279:static bool isUnusedVariable(const Variable *var)
        -: 1280:{
       37: 1281:    if (!var)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1282:        return false;
       37: 1283:    if (!var->scope())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1284:        return false;
       37: 1285:    const Token *start = var->declEndToken();
call    0 returned 100%
       37: 1286:    if (!start)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1287:        return false;
       37: 1288:    if (Token::Match(start, "; %varid% =", var->declarationId()))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 1289:        start = start->tokAt(2);
call    0 never executed
       37: 1290:    return !Token::findmatch(start->next(), "%varid%", var->scope()->bodyEnd, var->declarationId());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        -: 1291:}
        -: 1292:
function _ZL30isVariableMutableInInitializerPK5TokenS1_i called 3 returned 100% blocks executed 82%
        3: 1293:static bool isVariableMutableInInitializer(const Token* start, const Token * end, nonneg int varid)
        -: 1294:{
        3: 1295:    if (!start)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1296:        return false;
        3: 1297:    if (!end)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1298:        return false;
       13: 1299:    for (const Token *tok = start; tok != end; tok = tok->next()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
       13: 1300:        if (tok->varId() != varid)
call    0 returned 100%
branch  1 taken 77% (fallthrough)
branch  2 taken 23%
       10: 1301:            continue;
        3: 1302:        if (tok->astParent()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        3: 1303:            const Token * memberTok = tok->astParent()->previous();
call    0 returned 100%
call    1 returned 100%
        3: 1304:            if (Token::Match(memberTok, "%var% (") && memberTok->variable()) {
call    0 returned 100%
branch  1 taken 33% (fallthrough)
branch  2 taken 67%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 taken 33% (fallthrough)
branch  7 taken 67%
        1: 1305:                const Variable * memberVar = memberTok->variable();
call    0 returned 100%
        1: 1306:                if (!memberVar->isReference())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1307:                    continue;
        1: 1308:                if (memberVar->isConst())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1309:                    continue;
        -: 1310:            }
        3: 1311:            return true;
        -: 1312:        } else {
    #####: 1313:            return true;
        -: 1314:        }
        -: 1315:    }
    #####: 1316:    return false;
        -: 1317:}
        -: 1318:
function _ZN10CheckOther18checkConstVariableEv called 927 returned 100% blocks executed 90%
      927: 1319:void CheckOther::checkConstVariable()
        -: 1320:{
      927: 1321:    if (!mSettings->isEnabled(Settings::STYLE) || mTokenizer->isC())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 2% (fallthrough)
branch  5 taken 98%
branch  6 taken 2% (fallthrough)
branch  7 taken 98%
       22: 1322:        return;
        -: 1323:
      905: 1324:    const SymbolDatabase *const symbolDatabase = mTokenizer->getSymbolDatabase();
call    0 returned 100%
        -: 1325:
     3377: 1326:    for (const Variable *var : symbolDatabase->variableList()) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 73% (fallthrough)
branch  5 taken 27%
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 returned 100%
call   10 never executed
call   11 never executed
     2472: 1327:        if (!var)
branch  0 taken 40% (fallthrough)
branch  1 taken 60%
      977: 1328:            continue;
     1495: 1329:        if (!var->isReference())
call    0 returned 100%
branch  1 taken 92% (fallthrough)
branch  2 taken 8%
     1382: 1330:            continue;
      113: 1331:        if (var->isRValueReference())
call    0 returned 100%
branch  1 taken 4% (fallthrough)
branch  2 taken 96%
        5: 1332:            continue;
      108: 1333:        if (var->isConst())
call    0 returned 100%
branch  1 taken 31% (fallthrough)
branch  2 taken 69%
       34: 1334:            continue;
       74: 1335:        if (!var->scope())
call    0 returned 100%
branch  1 taken 19% (fallthrough)
branch  2 taken 81%
       14: 1336:            continue;
       60: 1337:        const Scope *scope = var->scope();
call    0 returned 100%
       60: 1338:        if (!scope->function)
branch  0 taken 7% (fallthrough)
branch  1 taken 93%
        4: 1339:            continue;
       56: 1340:        Function *function = scope->function;
       56: 1341:        if (var->isArgument()) {
call    0 returned 100%
branch  1 taken 70% (fallthrough)
branch  2 taken 30%
       39: 1342:            if (function->isImplicitlyVirtual() || function->templateDef)
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 5% (fallthrough)
branch  6 taken 95%
branch  7 taken 5% (fallthrough)
branch  8 taken 95%
        2: 1343:                continue;
       37: 1344:            if (isUnusedVariable(var))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 3% (fallthrough)
branch  4 taken 97%
        1: 1345:                continue;
       36: 1346:            if (function->isConstructor() && isVariableMutableInInitializer(function->constructorMemberInitialization(), scope->bodyStart, var->declarationId()))
call    0 returned 100%
branch  1 taken 8% (fallthrough)
branch  2 taken 92%
call    3 returned 100%
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
branch  8 taken 100% (fallthrough)
branch  9 taken 0% (throw)
branch 10 taken 100% (fallthrough)
branch 11 taken 0%
branch 12 taken 8% (fallthrough)
branch 13 taken 92%
        3: 1347:                continue;
        -: 1348:        }
       50: 1349:        if (var->isGlobal())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1350:            continue;
       50: 1351:        if (var->isStatic())
call    0 returned 100%
branch  1 taken 2% (fallthrough)
branch  2 taken 98%
        1: 1352:            continue;
       49: 1353:        if (var->isArray())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1354:            continue;
       49: 1355:        if (var->isEnumType())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####: 1356:            continue;
       49: 1357:        if (var->isVolatile())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1358:            continue;
       49: 1359:        if (isAliased(var))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####: 1360:            continue;
       49: 1361:        if (isVariableChanged(var, mSettings, mTokenizer->isCPP()))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
branch  4 taken 82% (fallthrough)
branch  5 taken 18%
       40: 1362:            continue;
       11: 1363:        if (Function::returnsReference(function) &&
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 22% (fallthrough)
branch  4 taken 78%
branch  5 taken 100% (fallthrough)
branch  6 taken 0%
branch  7 taken 22% (fallthrough)
branch  8 taken 78%
        2: 1364:            Token::findmatch(var->nameToken(), "return %varid% ;|[", scope->bodyEnd, var->declarationId()))
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
        2: 1365:            continue;
        -: 1366:        // Skip if address is taken
        7: 1367:        if (Token::findmatch(var->nameToken(), "& %varid%", scope->bodyEnd, var->declarationId()))
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
    #####: 1368:            continue;
        7: 1369:        constVariableError(var);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -: 1370:    }
        -: 1371:}
        -: 1372:
function _ZN10CheckOther18constVariableErrorEPK8Variable called 7 returned 100% blocks executed 55%
        7: 1373:void CheckOther::constVariableError(const Variable *var)
        -: 1374:{
        7: 1375:    const Token *tok = nullptr;
       14: 1376:    std::string name = "x";
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
call    5 returned 100%
call    6 never executed
call    7 never executed
       14: 1377:    std::string id = "Variable";
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
call    5 returned 100%
call    6 never executed
        7: 1378:    if (var) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        7: 1379:        tok = var->nameToken();
call    0 returned 100%
        7: 1380:        name = var->name();
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
        7: 1381:        if (var->isArgument())
call    0 returned 100%
branch  1 taken 57% (fallthrough)
branch  2 taken 43%
        4: 1382:            id = "Parameter";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -: 1383:    }
        7: 1384:    reportError(tok, Severity::style, "const" + id, id + " '" + name + "' can be declared with const", CWE398, false);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
branch 13 taken 100% (fallthrough)
branch 14 taken 0% (throw)
call   15 returned 100%
call   16 returned 100%
call   17 returned 100%
call   18 returned 100%
call   19 never executed
call   20 never executed
call   21 never executed
call   22 never executed
        7: 1385:}
call    0 never executed
        -: 1386:
        -: 1387://---------------------------------------------------------------------------
        -: 1388:// Check usage of char variables..
        -: 1389://---------------------------------------------------------------------------
        -: 1390:
function _ZN10CheckOther17checkCharVariableEv called 927 returned 100% blocks executed 47%
      927: 1391:void CheckOther::checkCharVariable()
        -: 1392:{
      927: 1393:    const bool warning = mSettings->isEnabled(Settings::WARNING);
call    0 returned 100%
      927: 1394:    const bool portability = mSettings->isEnabled(Settings::PORTABILITY);
call    0 returned 100%
      927: 1395:    if (!warning && !portability)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
    #####: 1396:        return;
        -: 1397:
      927: 1398:    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
call    0 returned 100%
     1908: 1399:    for (const Scope * scope : symbolDatabase->functionScopes) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 51% (fallthrough)
branch  4 taken 49%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
    18796: 1400:        for (const Token* tok = scope->bodyStart; tok != scope->bodyEnd; tok = tok->next()) {
branch  0 taken 95% (fallthrough)
branch  1 taken 5%
call    2 returned 100%
    17815: 1401:            if (Token::Match(tok, "%var% [")) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 1% (fallthrough)
branch  4 taken 99%
       90: 1402:                if (!tok->variable())
call    0 returned 100%
branch  1 taken 3% (fallthrough)
branch  2 taken 97%
        3: 1403:                    continue;
       87: 1404:                if (!tok->variable()->isArray() && !tok->variable()->isPointer())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 38% (fallthrough)
branch  3 taken 62%
call    4 returned 100%
call    5 returned 100%
branch  6 taken 70% (fallthrough)
branch  7 taken 30%
branch  8 taken 26% (fallthrough)
branch  9 taken 74%
       23: 1405:                    continue;
       64: 1406:                const Token *index = tok->next()->astOperand2();
call    0 returned 100%
call    1 returned 100%
       64: 1407:                if (warning && tok->variable()->isArray() && astIsSignedChar(index) && index->getValueGE(0x80, mSettings))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 84% (fallthrough)
branch  5 taken 16%
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
branch  9 taken 0% (fallthrough)
branch 10 taken 100%
call   11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 taken 0% (fallthrough)
branch 17 taken 100%
    #####: 1408:                    signedCharArrayIndexError(tok);
call    0 never executed
branch  1 never executed
branch  2 never executed
       64: 1409:                if (portability && astIsUnknownSignChar(index) && index->getValueGE(0x80, mSettings))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
call    7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 taken 0% (fallthrough)
branch 13 taken 100%
    #####: 1410:                    unknownSignCharArrayIndexError(tok);
call    0 never executed
branch  1 never executed
branch  2 never executed
    17725: 1411:            } else if (warning && Token::Match(tok, "[&|^]") && tok->isBinaryOp()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
branch  5 taken 1% (fallthrough)
branch  6 taken 99%
call    7 returned 100%
branch  8 taken 100% (fallthrough)
branch  9 taken 0% (throw)
branch 10 taken 30% (fallthrough)
branch 11 taken 70%
branch 12 taken 1% (fallthrough)
branch 13 taken 99%
       42: 1412:                bool warn = false;
       42: 1413:                if (astIsSignedChar(tok->astOperand1())) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
    #####: 1414:                    const ValueFlow::Value *v1 = tok->astOperand1()->getValueLE(-1, mSettings);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1415:                    const ValueFlow::Value *v2 = tok->astOperand2()->getMaxValue(false);
call    0 never executed
call    1 never executed
    #####: 1416:                    if (!v1)
branch  0 never executed
branch  1 never executed
    #####: 1417:                        v1 = tok->astOperand1()->getValueGE(0x80, mSettings);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1418:                    if (v1 && !(tok->str() == "&" && v2 && v2->isKnown() && v2->intvalue >= 0 && v2->intvalue < 0x100))
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
call    8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
    #####: 1419:                        warn = true;
       42: 1420:                } else if (astIsSignedChar(tok->astOperand2())) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
    #####: 1421:                    const ValueFlow::Value *v1 = tok->astOperand2()->getValueLE(-1, mSettings);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1422:                    const ValueFlow::Value *v2 = tok->astOperand1()->getMaxValue(false);
call    0 never executed
call    1 never executed
    #####: 1423:                    if (!v1)
branch  0 never executed
branch  1 never executed
    #####: 1424:                        v1 = tok->astOperand2()->getValueGE(0x80, mSettings);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1425:                    if (v1 && !(tok->str() == "&" && v2 && v2->isKnown() && v2->intvalue >= 0 && v2->intvalue < 0x100))
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
call    8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
    #####: 1426:                        warn = true;
        -: 1427:                }
        -: 1428:
        -: 1429:                // is the result stored in a short|int|long?
       42: 1430:                if (warn && Token::simpleMatch(tok->astParent(), "=")) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 taken 0% (fallthrough)
branch  9 taken 100%
    #####: 1431:                    const Token *lhs = tok->astParent()->astOperand1();
call    0 never executed
call    1 never executed
    #####: 1432:                    if (lhs && lhs->valueType() && lhs->valueType()->type >= ValueType::Type::SHORT)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 1433:                        charBitOpError(tok); // This is an error..
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1434:                }
        -: 1435:            }
        -: 1436:        }
        -: 1437:    }
        -: 1438:}
        -: 1439:
function _ZN10CheckOther25signedCharArrayIndexErrorEPK5Token called 0 returned 0% blocks executed 0%
    #####: 1440:void CheckOther::signedCharArrayIndexError(const Token *tok)
        -: 1441:{
    #####: 1442:    reportError(tok,
call    0 never executed
        -: 1443:                Severity::warning,
        -: 1444:                "signedCharArrayIndex",
        -: 1445:                "Signed 'char' type used as array index.\n"
        -: 1446:                "Signed 'char' type used as array index. If the value "
        -: 1447:                "can be greater than 127 there will be a buffer underflow "
        -: 1448:                "because of sign extension.", CWE128, false);
    #####: 1449:}
        -: 1450:
function _ZN10CheckOther30unknownSignCharArrayIndexErrorEPK5Token called 0 returned 0% blocks executed 0%
    #####: 1451:void CheckOther::unknownSignCharArrayIndexError(const Token *tok)
        -: 1452:{
    #####: 1453:    reportError(tok,
call    0 never executed
        -: 1454:                Severity::portability,
        -: 1455:                "unknownSignCharArrayIndex",
        -: 1456:                "'char' type used as array index.\n"
        -: 1457:                "'char' type used as array index. Values greater than 127 will be "
        -: 1458:                "treated depending on whether 'char' is signed or unsigned on target platform.", CWE758, false);
    #####: 1459:}
        -: 1460:
function _ZN10CheckOther14charBitOpErrorEPK5Token called 0 returned 0% blocks executed 0%
    #####: 1461:void CheckOther::charBitOpError(const Token *tok)
        -: 1462:{
    #####: 1463:    reportError(tok,
call    0 never executed
        -: 1464:                Severity::warning,
        -: 1465:                "charBitOp",
        -: 1466:                "When using 'char' variables in bit operations, sign extension can generate unexpected results.\n"
        -: 1467:                "When using 'char' variables in bit operations, sign extension can generate unexpected results. For example:\n"
        -: 1468:                "    char c = 0x80;\n"
        -: 1469:                "    int i = 0 | c;\n"
        -: 1470:                "    if (i & 0x8000)\n"
        -: 1471:                "        printf(\"not expected\");\n"
        -: 1472:                "The \"not expected\" will be printed on the screen.", CWE398, false);
    #####: 1473:}
        -: 1474:
        -: 1475://---------------------------------------------------------------------------
        -: 1476:// Incomplete statement..
        -: 1477://---------------------------------------------------------------------------
        -: 1478:
function _ZL6isTypePK5Tokenb called 5 returned 100% blocks executed 16%
        5: 1479:static bool isType(const Token * tok, bool unknown)
        -: 1480:{
        5: 1481:    if (Token::Match(tok, "%type%"))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        5: 1482:        return true;
    #####: 1483:    if (Token::simpleMatch(tok, "::"))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1484:        return isType(tok->astOperand2(), unknown);
call    0 never executed
call    1 never executed
    #####: 1485:    if (Token::simpleMatch(tok, "<") && tok->link())
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 1486:        return true;
    #####: 1487:    if (unknown && Token::Match(tok, "%name% !!("))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 1488:        return true;
    #####: 1489:    return false;
        -: 1490:}
        -: 1491:
function _ZL11isVarDeclOpPK5Token called 61 returned 100% blocks executed 94%
       61: 1492:static bool isVarDeclOp(const Token* tok)
        -: 1493:{
       61: 1494:    if (!tok)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1495:        return false;
       61: 1496:    const Token * vartok = tok->astOperand2();
call    0 returned 100%
       61: 1497:    if (vartok && vartok->variable() && vartok->variable()->nameToken() == vartok)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 92% (fallthrough)
branch  4 taken 8%
call    5 returned 100%
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0%
branch  9 taken 92% (fallthrough)
branch 10 taken 8%
       56: 1498:        return true;
        5: 1499:    const Token * typetok = tok->astOperand1();
call    0 returned 100%
        5: 1500:    return isType(typetok, Token::Match(vartok, "%var%"));
call    0 returned 100%
call    1 returned 100%
        -: 1501:}
        -: 1502:
function _ZL16isConstStatementPK5Token called 1215 returned 100% blocks executed 80%
     1215: 1503:static bool isConstStatement(const Token *tok)
        -: 1504:{
     1215: 1505:    if (!tok)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1506:        return false;
     1215: 1507:    if (tok->isExpandedMacro())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1508:        return false;
     1215: 1509:    if (Token::Match(tok, "%bool%|%num%|%str%|%char%|nullptr|NULL"))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1510:        return true;
     1215: 1511:    if (Token::Match(tok, "%var%"))
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 99%
       10: 1512:        return true;
     1329: 1513:    if (Token::Match(tok, "*|&|&&") &&
call    0 returned 100%
branch  1 taken 5% (fallthrough)
branch  2 taken 95%
branch  3 taken 98% (fallthrough)
branch  4 taken 2%
branch  5 taken 5% (fallthrough)
branch  6 taken 95%
      123: 1514:        (Token::Match(tok->previous(), "::|.|const|volatile|restrict") || isVarDeclOp(tok)))
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
       62: 1515:        return false;
     1143: 1516:    if (Token::Match(tok, "<<|>>") && !astIsIntegral(tok, false))
call    0 returned 100%
branch  1 taken 2% (fallthrough)
branch  2 taken 98%
call    3 returned 100%
branch  4 taken 91% (fallthrough)
branch  5 taken 9%
branch  6 taken 2% (fallthrough)
branch  7 taken 98%
       20: 1517:        return false;
     1123: 1518:    if (Token::Match(tok, "!|~|%cop%") && (tok->astOperand1() || tok->astOperand2()))
call    0 returned 100%
branch  1 taken 2% (fallthrough)
branch  2 taken 98%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
call    6 never executed
branch  7 never executed
branch  8 never executed
branch  9 taken 2% (fallthrough)
branch 10 taken 98%
       18: 1519:        return true;
     1105: 1520:    if (Token::simpleMatch(tok->previous(), "sizeof ("))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 1521:        return true;
     1105: 1522:    if (isCPPCast(tok))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1523:        return isConstStatement(tok->astOperand2());
call    0 never executed
call    1 never executed
     1105: 1524:    if (Token::Match(tok, "( %type%"))
call    0 returned 100%
branch  1 taken 2% (fallthrough)
branch  2 taken 98%
       20: 1525:        return isConstStatement(tok->astOperand1());
call    0 returned 100%
call    1 returned 100%
     1085: 1526:    if (Token::simpleMatch(tok, ","))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1527:        return isConstStatement(tok->astOperand2());
call    0 never executed
call    1 never executed
     1085: 1528:    return false;
        -: 1529:}
        -: 1530:
function _ZL10isVoidStmtPK5Token called 28 returned 100% blocks executed 96%
       28: 1531:static bool isVoidStmt(const Token *tok)
        -: 1532:{
       28: 1533:    if (Token::simpleMatch(tok, "( void"))
call    0 returned 100%
branch  1 taken 43% (fallthrough)
branch  2 taken 57%
       12: 1534:        return true;
       16: 1535:    const Token *tok2 = tok;
       66: 1536:    while (tok2->astOperand1())
call    0 returned 100%
branch  1 taken 61% (fallthrough)
branch  2 taken 39%
       25: 1537:        tok2 = tok2->astOperand1();
call    0 returned 100%
       16: 1538:    if (Token::simpleMatch(tok2->previous(), ")") && Token::simpleMatch(tok2->previous()->link(), "( void"))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 6% (fallthrough)
branch  3 taken 94%
call    4 returned 100%
call    5 returned 100%
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0%
branch  9 taken 6% (fallthrough)
branch 10 taken 94%
        1: 1539:        return true;
       15: 1540:    if (Token::simpleMatch(tok2, "( void"))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1541:        return true;
       15: 1542:    return Token::Match(tok2->previous(), "delete|throw|return");
call    0 returned 100%
call    1 returned 100%
        -: 1543:}
        -: 1544:
function _ZL10isConstTopPK5Token called 18720 returned 100% blocks executed 97%
    18720: 1545:static bool isConstTop(const Token *tok)
        -: 1546:{
    18720: 1547:    if (!tok)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1548:        return false;
    18720: 1549:    if (tok == tok->astTop())
call    0 returned 100%
branch  1 taken 59% (fallthrough)
branch  2 taken 41%
    10987: 1550:        return true;
    15674: 1551:    if (Token::simpleMatch(tok->astParent(), ";") && tok->astTop() &&
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 100% (fallthrough)
branch  6 taken 0%
branch  7 taken 1% (fallthrough)
branch  8 taken 99%
     7941: 1552:        Token::Match(tok->astTop()->previous(), "for|if (") && Token::simpleMatch(tok->astTop()->astOperand2(), ";")) {
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
branch  8 taken 100% (fallthrough)
branch  9 taken 0%
      104: 1553:        if (Token::simpleMatch(tok->astParent()->astParent(), ";"))
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 48% (fallthrough)
branch  4 taken 52%
       50: 1554:            return tok->astParent()->astOperand2() == tok;
call    0 returned 100%
call    1 returned 100%
        -: 1555:        else
       54: 1556:            return tok->astParent()->astOperand1() == tok;
call    0 returned 100%
call    1 returned 100%
        -: 1557:    }
     7629: 1558:    return false;
        -: 1559:}
        -: 1560:
function _ZN10CheckOther24checkIncompleteStatementEv called 927 returned 100% blocks executed 77%
      927: 1561:void CheckOther::checkIncompleteStatement()
        -: 1562:{
      927: 1563:    if (!mSettings->isEnabled(Settings::WARNING))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1564:        return;
        -: 1565:
    29119: 1566:    for (const Token *tok = mTokenizer->tokens(); tok; tok = tok->next()) {
call    0 returned 100%
branch  1 taken 97% (fallthrough)
branch  2 taken 3%
call    3 returned 100%
    28192: 1567:        const Scope *scope = tok->scope();
call    0 returned 100%
    28192: 1568:        if (scope && !scope->isExecutable())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 34% (fallthrough)
branch  4 taken 66%
branch  5 taken 34% (fallthrough)
branch  6 taken 66%
     9472: 1569:            continue;
    18720: 1570:        if (!isConstTop(tok))
call    0 returned 100%
branch  1 taken 41% (fallthrough)
branch  2 taken 59%
     7687: 1571:            continue;
    11033: 1572:        const Token *rtok = nextAfterAstRightmostLeaf(tok);
call    0 returned 100%
    20975: 1573:        if (!Token::simpleMatch(tok->astParent(), ";") && !Token::simpleMatch(rtok, ";") &&
call    0 returned 100%
call    1 returned 100%
branch  2 taken 99% (fallthrough)
branch  3 taken 1%
call    4 returned 100%
branch  5 taken 90% (fallthrough)
branch  6 taken 10%
branch  7 taken 99% (fallthrough)
branch  8 taken 1%
branch  9 taken 89% (fallthrough)
branch 10 taken 11%
     9942: 1574:            !Token::Match(tok->previous(), ";|}|{ %any% ;"))
call    0 returned 100%
call    1 returned 100%
     9833: 1575:            continue;
        -: 1576:        // Skipe statement expressions
     1200: 1577:        if (Token::simpleMatch(rtok, "; } )"))
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 99%
        5: 1578:            continue;
     1195: 1579:        if (!isConstStatement(tok))
call    0 returned 100%
branch  1 taken 98% (fallthrough)
branch  2 taken 2%
     1167: 1580:            continue;
       28: 1581:        if (isVoidStmt(tok))
call    0 returned 100%
branch  1 taken 71% (fallthrough)
branch  2 taken 29%
       20: 1582:            continue;
        8: 1583:        if (mTokenizer->isCPP() && tok->str() == "&" && !(tok->astOperand1()->valueType() && tok->astOperand1()->valueType()->isIntegral()))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
call    4 returned 100%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
call    7 never executed
call    8 never executed
branch  9 never executed
branch 10 never executed
call   11 never executed
call   12 never executed
call   13 never executed
branch 14 never executed
branch 15 never executed
branch 16 taken 0% (fallthrough)
branch 17 taken 100%
        -: 1584:            // Possible archive
    #####: 1585:            continue;
        8: 1586:        bool inconclusive = Token::Match(tok, "%cop%");
call    0 returned 100%
        8: 1587:        if (mSettings->inconclusive || !inconclusive)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
        8: 1588:            constStatementError(tok, tok->isNumber() ? "numeric" : "string", inconclusive);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
branch  8 taken 100% (fallthrough)
branch  9 taken 0% (throw)
call   10 returned 100%
call   11 returned 100%
call   12 never executed
call   13 never executed
        -: 1589:    }
        -: 1590:}
        -: 1591:
function _ZN10CheckOther19constStatementErrorEPK5TokenRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEb called 8 returned 100% blocks executed 22%
        8: 1592:void CheckOther::constStatementError(const Token *tok, const std::string &type, bool inconclusive)
        -: 1593:{
       16: 1594:    std::string msg;
call    0 returned 100%
call    1 returned 100%
call    2 never executed
        8: 1595:    if (Token::simpleMatch(tok, "=="))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
        8: 1596:        msg = "Found suspicious equality comparison. Did you intend to assign a value instead?";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
    #####: 1597:    else if (Token::Match(tok, ",|!|~|%cop%"))
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1598:        msg = "Found suspicious operator '" + tok->str() + "'";
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
    #####: 1599:    else if (Token::Match(tok, "%var%"))
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1600:        msg = "Unused variable value '" + tok->str() + "'";
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
        -: 1601:    else
    #####: 1602:        msg = "Redundant code: Found a statement that begins with " + type + " constant.";
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
        8: 1603:    reportError(tok, Severity::warning, "constStatement", msg, CWE398, inconclusive);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 never executed
        8: 1604:}
        -: 1605:
        -: 1606://---------------------------------------------------------------------------
        -: 1607:// Detect division by zero.
        -: 1608://---------------------------------------------------------------------------
function _ZN10CheckOther17checkZeroDivisionEv called 927 returned 100% blocks executed 100%
      927: 1609:void CheckOther::checkZeroDivision()
        -: 1610:{
    29119: 1611:    for (const Token *tok = mTokenizer->tokens(); tok; tok = tok->next()) {
call    0 returned 100%
branch  1 taken 97% (fallthrough)
branch  2 taken 3%
call    3 returned 100%
    28192: 1612:        if (!tok->astOperand2() || !tok->astOperand1())
call    0 returned 100%
branch  1 taken 16% (fallthrough)
branch  2 taken 84%
call    3 returned 100%
branch  4 taken 1% (fallthrough)
branch  5 taken 99%
branch  6 taken 84% (fallthrough)
branch  7 taken 16%
    23595: 1613:            continue;
     4597: 1614:        if (tok->str() != "%" && tok->str() != "/" && tok->str() != "%=" && tok->str() != "/=")
call    0 returned 100%
call    1 returned 100%
branch  2 taken 99% (fallthrough)
branch  3 taken 1%
call    4 returned 100%
call    5 returned 100%
branch  6 taken 99% (fallthrough)
branch  7 taken 1%
call    8 returned 100%
call    9 returned 100%
branch 10 taken 99% (fallthrough)
branch 11 taken 1%
call   12 returned 100%
call   13 returned 100%
branch 14 taken 99% (fallthrough)
branch 15 taken 1%
branch 16 taken 98% (fallthrough)
branch 17 taken 2%
     4523: 1615:            continue;
       74: 1616:        if (!tok->valueType() || !tok->valueType()->isIntegral())
call    0 returned 100%
branch  1 taken 62% (fallthrough)
branch  2 taken 38%
call    3 returned 100%
call    4 returned 100%
branch  5 taken 20% (fallthrough)
branch  6 taken 80%
branch  7 taken 50% (fallthrough)
branch  8 taken 50%
       37: 1617:            continue;
        -: 1618:
        -: 1619:        // Value flow..
       37: 1620:        const ValueFlow::Value *value = tok->astOperand2()->getValue(0LL);
call    0 returned 100%
call    1 returned 100%
       37: 1621:        if (value && mSettings->isEnabled(value, false))
branch  0 taken 59% (fallthrough)
branch  1 taken 41%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 59% (fallthrough)
branch  6 taken 41%
       22: 1622:            zerodivError(tok, value);
call    0 returned 100%
        -: 1623:    }
      927: 1624:}
        -: 1625:
function _ZN10CheckOther12zerodivErrorEPK5TokenPKN9ValueFlow5ValueE called 22 returned 100% blocks executed 52%
       22: 1626:void CheckOther::zerodivError(const Token *tok, const ValueFlow::Value *value)
        -: 1627:{
       22: 1628:    if (!tok && !value) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
    #####: 1629:        reportError(tok, Severity::error, "zerodiv", "Division by zero.", CWE369, false);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1630:        reportError(tok, Severity::error, "zerodivcond", ValueFlow::eitherTheConditionIsRedundant(nullptr) + " or there is division by zero.", CWE369, false);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
call   12 never executed
call   13 never executed
    #####: 1631:        return;
        -: 1632:    }
        -: 1633:
       44: 1634:    const ErrorPath errorPath = getErrorPath(tok, value, "Division by zero");
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 returned 100%
call    9 returned 100%
call   10 never executed
call   11 never executed
        -: 1635:
       44: 1636:    std::ostringstream errmsg;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
call    4 never executed
       22: 1637:    if (value->condition) {
branch  0 taken 23% (fallthrough)
branch  1 taken 77%
        5: 1638:        const int line = tok ? tok->linenr() : 0;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
       10: 1639:        errmsg << ValueFlow::eitherTheConditionIsRedundant(value->condition)
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
call    4 never executed
        5: 1640:               << " or there is division by zero at line " << line << ".";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
        -: 1641:    } else
       17: 1642:        errmsg << "Division by zero.";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -: 1643:
       88: 1644:    reportError(errorPath,
branch  0 taken 23% (fallthrough)
branch  1 taken 77%
branch  2 taken 77% (fallthrough)
branch  3 taken 23%
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
       22: 1645:                value->errorSeverity() ? Severity::error : Severity::warning,
call    0 returned 100%
       22: 1646:                value->condition ? "zerodivcond" : "zerodiv",
       66: 1647:                errmsg.str(), CWE369, value->isInconclusive());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
call    5 never executed
        -: 1648:}
        -: 1649:
        -: 1650://---------------------------------------------------------------------------
        -: 1651:// Check for NaN (not-a-number) in an arithmetic expression, e.g.
        -: 1652:// double d = 1.0 / 0.0 + 100.0;
        -: 1653://---------------------------------------------------------------------------
        -: 1654:
function _ZN10CheckOther30checkNanInArithmeticExpressionEv called 927 returned 100% blocks executed 95%
      927: 1655:void CheckOther::checkNanInArithmeticExpression()
        -: 1656:{
      927: 1657:    if (!mSettings->isEnabled(Settings::STYLE))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1658:        return;
    29119: 1659:    for (const Token *tok = mTokenizer->tokens(); tok; tok = tok->next()) {
call    0 returned 100%
branch  1 taken 97% (fallthrough)
branch  2 taken 3%
call    3 returned 100%
    28192: 1660:        if (tok->str() != "/")
call    0 returned 100%
call    1 returned 100%
branch  2 taken 99% (fallthrough)
branch  3 taken 1%
    28130: 1661:            continue;
       62: 1662:        if (!Token::Match(tok->astParent(), "[+-]"))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 94% (fallthrough)
branch  3 taken 6%
       58: 1663:            continue;
        4: 1664:        if (Token::simpleMatch(tok->astOperand2(), "0.0"))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        4: 1665:            nanInArithmeticExpressionError(tok);
call    0 returned 100%
        -: 1666:    }
        -: 1667:}
        -: 1668:
function _ZN10CheckOther30nanInArithmeticExpressionErrorEPK5Token called 4 returned 100% blocks executed 100%
        4: 1669:void CheckOther::nanInArithmeticExpressionError(const Token *tok)
        -: 1670:{
        4: 1671:    reportError(tok, Severity::style, "nanInArithmeticExpression",
call    0 returned 100%
        -: 1672:                "Using NaN/Inf in a computation.\n"
        -: 1673:                "Using NaN/Inf in a computation. "
        -: 1674:                "Although nothing bad really happens, it is suspicious.", CWE369, false);
        4: 1675:}
        -: 1676:
        -: 1677://---------------------------------------------------------------------------
        -: 1678:// Creating instance of classes which are destroyed immediately
        -: 1679://---------------------------------------------------------------------------
function _ZN10CheckOther24checkMisusedScopedObjectEv called 927 returned 100% blocks executed 91%
      927: 1680:void CheckOther::checkMisusedScopedObject()
        -: 1681:{
        -: 1682:    // Skip this check for .c files
      927: 1683:    if (mTokenizer->isC())
call    0 returned 100%
branch  1 taken 2% (fallthrough)
branch  2 taken 98%
       22: 1684:        return;
        -: 1685:
      905: 1686:    if (!mSettings->isEnabled(Settings::STYLE))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1687:        return;
        -: 1688:
      905: 1689:    const SymbolDatabase * const symbolDatabase = mTokenizer->getSymbolDatabase();
call    0 returned 100%
     1864: 1690:    for (const Scope * scope : symbolDatabase->functionScopes) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 51% (fallthrough)
branch  4 taken 49%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
    18362: 1691:        for (const Token *tok = scope->bodyStart; tok && tok != scope->bodyEnd; tok = tok->next()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 95% (fallthrough)
branch  3 taken 5%
call    4 returned 100%
    52122: 1692:            if ((tok->next()->type() || (tok->next()->function() && tok->next()->function()->isConstructor())) // TODO: The rhs of || should be removed; It is a workaround for a symboldatabase bug
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 1% (fallthrough)
branch  5 taken 99%
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
branch  9 taken 4% (fallthrough)
branch 10 taken 96%
branch 11 taken 1% (fallthrough)
branch 12 taken 99%
       94: 1693:                && Token::Match(tok, "[;{}] %name% (")
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 15% (fallthrough)
branch  4 taken 85%
       14: 1694:                && Token::Match(tok->linkAt(2), ") ; !!}")
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
branch  6 taken 43% (fallthrough)
branch  7 taken 57%
    17410: 1695:                && (!tok->next()->function() || // is not a function on this scope
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 17% (fallthrough)
branch  5 taken 83%
branch  6 taken 100% (fallthrough)
branch  7 taken 0%
        1: 1696:                    tok->next()->function()->isConstructor())) { // or is function in this scope and it's a ctor
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        6: 1697:                tok = tok->next();
call    0 returned 100%
        6: 1698:                misusedScopeObjectError(tok, tok->str());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
        6: 1699:                tok = tok->next();
call    0 returned 100%
        -: 1700:            }
        -: 1701:        }
        -: 1702:    }
        -: 1703:}
        -: 1704:
function _ZN10CheckOther23misusedScopeObjectErrorEPK5TokenRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 6 returned 100% blocks executed 58%
        6: 1705:void CheckOther::misusedScopeObjectError(const Token *tok, const std::string& varname)
        -: 1706:{
       12: 1707:    reportError(tok, Severity::style,
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -: 1708:                "unusedScopedObject",
       12: 1709:                "$symbol:" + varname + "\n"
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
call    5 returned 100%
call    6 never executed
call    7 never executed
        -: 1710:                "Instance of '$symbol' object is destroyed immediately.", CWE563, false);
        6: 1711:}
        -: 1712:
function _ZL26getSingleExpressionInBlockPK5Token called 14 returned 100% blocks executed 82%
       14: 1713:static const Token * getSingleExpressionInBlock(const Token * tok)
        -: 1714:{
       14: 1715:    if (!tok)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1716:        return nullptr;
       14: 1717:    const Token * top = tok->astTop();
call    0 returned 100%
       14: 1718:    if (!top)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1719:        return nullptr;
       14: 1720:    const Token * nextExpression = nextAfterAstRightmostLeaf(top);
call    0 returned 100%
       14: 1721:    if (!Token::simpleMatch(nextExpression, "; }"))
call    0 returned 100%
branch  1 taken 57% (fallthrough)
branch  2 taken 43%
        8: 1722:        return nullptr;
        6: 1723:    return top;
        -: 1724:}
        -: 1725:
        -: 1726://-----------------------------------------------------------------------------
        -: 1727:// check for duplicate code in if and else branches
        -: 1728:// if (a) { b = true; } else { b = true; }
        -: 1729://-----------------------------------------------------------------------------
function _ZN10CheckOther20checkDuplicateBranchEv called 927 returned 100% blocks executed 84%
      927: 1730:void CheckOther::checkDuplicateBranch()
        -: 1731:{
        -: 1732:    // This is inconclusive since in practice most warnings are noise:
        -: 1733:    // * There can be unfixed low-priority todos. The code is fine as it
        -: 1734:    //   is but it could be possible to enhance it. Writing a warning
        -: 1735:    //   here is noise since the code is fine (see cppcheck, abiword, ..)
        -: 1736:    // * There can be overspecified code so some conditions can't be true
        -: 1737:    //   and their conditional code is a duplicate of the condition that
        -: 1738:    //   is always true just in case it would be false. See for instance
        -: 1739:    //   abiword.
      927: 1740:    if (!mSettings->isEnabled(Settings::STYLE) || !mSettings->inconclusive)
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 11% (fallthrough)
branch  4 taken 89%
branch  5 taken 11% (fallthrough)
branch  6 taken 89%
      101: 1741:        return;
        -: 1742:
      826: 1743:    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
call    0 returned 100%
        -: 1744:
     3154: 1745:    for (const Scope & scope : symbolDatabase->scopeList) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 74% (fallthrough)
branch  4 taken 26%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
     2328: 1746:        if (scope.type != Scope::eIf)
branch  0 taken 88% (fallthrough)
branch  1 taken 12%
     2044: 1747:            continue;
        -: 1748:
        -: 1749:        // check all the code in the function for if (..) else
      284: 1750:        if (Token::simpleMatch(scope.bodyEnd, "} else {")) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 6% (fallthrough)
branch  4 taken 94%
        -: 1751:            // Make sure there are no macros (different macros might be expanded
        -: 1752:            // to the same code)
       18: 1753:            bool macro = false;
      283: 1754:            for (const Token *tok = scope.bodyStart; tok != scope.bodyEnd->linkAt(2); tok = tok->next()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 94% (fallthrough)
branch  4 taken 6%
call    5 returned 100%
      266: 1755:                if (tok->isExpandedMacro()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 1% (fallthrough)
branch  4 taken 99%
        1: 1756:                    macro = true;
        1: 1757:                    break;
        -: 1758:                }
        -: 1759:            }
       18: 1760:            if (macro)
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
       17: 1761:                continue;
        -: 1762:
        -: 1763:            // save if branch code
       19: 1764:            const std::string branch1 = scope.bodyStart->next()->stringifyList(scope.bodyEnd);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 never executed
        -: 1765:
       17: 1766:            if (branch1.empty())
call    0 returned 100%
branch  1 taken 24% (fallthrough)
branch  2 taken 76%
        4: 1767:                continue;
        -: 1768:
        -: 1769:            // save else branch code
       15: 1770:            const std::string branch2 = scope.bodyEnd->tokAt(3)->stringifyList(scope.bodyEnd->linkAt(2));
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 12%
branch 11 taken 88%
call   12 never executed
        -: 1771:
       15: 1772:            ErrorPath errorPath;
call    0 returned 100%
call    1 returned 100%
branch  2 taken 15%
branch  3 taken 85%
call    4 never executed
        -: 1773:            // check for duplicates
       19: 1774:            if (branch1 == branch2) {
call    0 returned 100%
branch  1 taken 46% (fallthrough)
branch  2 taken 54%
        6: 1775:                duplicateBranchError(scope.classDef, scope.bodyEnd->next(), errorPath);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 never executed
        6: 1776:                continue;
        -: 1777:            }
        -: 1778:
        -: 1779:            // check for duplicates using isSameExpression
        7: 1780:            const Token * branchTop1 = getSingleExpressionInBlock(scope.bodyStart->next());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
        7: 1781:            const Token * branchTop2 = getSingleExpressionInBlock(scope.bodyEnd->tokAt(3));
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        7: 1782:            if (!branchTop1 || !branchTop2)
branch  0 taken 43% (fallthrough)
branch  1 taken 57%
branch  2 taken 33% (fallthrough)
branch  3 taken 67%
        5: 1783:                continue;
        2: 1784:            if (branchTop1->str() != branchTop2->str())
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####: 1785:                continue;
        4: 1786:            if (isSameExpression(mTokenizer->isCPP(), false, branchTop1->astOperand1(), branchTop2->astOperand1(), mSettings->library, true, true, &errorPath) &&
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
branch  6 taken 100% (fallthrough)
branch  7 taken 0%
branch  8 taken 50% (fallthrough)
branch  9 taken 50%
branch 10 taken 50% (fallthrough)
branch 11 taken 50%
        2: 1787:                isSameExpression(mTokenizer->isCPP(), false, branchTop1->astOperand2(), branchTop2->astOperand2(), mSettings->library, true, true, &errorPath))
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        1: 1788:                duplicateBranchError(scope.classDef, scope.bodyEnd->next(), errorPath);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 returned 100%
branch  9 taken 15%
branch 10 taken 85%
call   11 never executed
        -: 1789:        }
        -: 1790:    }
        -: 1791:}
        -: 1792:
function _ZN10CheckOther20duplicateBranchErrorEPK5TokenS2_NSt7__debug4listISt4pairIS2_NSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEESaISC_EEE called 7 returned 100% blocks executed 64%
        7: 1793:void CheckOther::duplicateBranchError(const Token *tok1, const Token *tok2, ErrorPath errors)
        -: 1794:{
        7: 1795:    errors.emplace_back(tok2, "");
call    0 returned 100%
        7: 1796:    errors.emplace_back(tok1, "");
call    0 returned 100%
        -: 1797:
        7: 1798:    reportError(errors, Severity::style, "duplicateBranch", "Found duplicate branches for 'if' and 'else'.\n"
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
        -: 1799:                "Finding the same code in an 'if' and related 'else' branch is suspicious and "
        -: 1800:                "might indicate a cut and paste or logic error. Please examine this code "
        -: 1801:                "carefully to determine if it is correct.", CWE398, true);
        7: 1802:}
        -: 1803:
        -: 1804:
        -: 1805://-----------------------------------------------------------------------------
        -: 1806:// Check for a free() of an invalid address
        -: 1807:// char* p = malloc(100);
        -: 1808:// free(p + 10);
        -: 1809://-----------------------------------------------------------------------------
function _ZN10CheckOther16checkInvalidFreeEv called 927 returned 100% blocks executed 72%
      927: 1810:void CheckOther::checkInvalidFree()
        -: 1811:{
     1854: 1812:    std::map<int, bool> inconclusive;
call    0 returned 100%
call    1 returned 100%
call    2 never executed
     1854: 1813:    std::map<int, std::string> allocation;
call    0 returned 100%
call    1 returned 100%
call    2 never executed
        -: 1814:
      927: 1815:    const bool printInconclusive = mSettings->inconclusive;
      927: 1816:    const SymbolDatabase* symbolDatabase = mTokenizer->getSymbolDatabase();
call    0 returned 100%
     1908: 1817:    for (const Scope * scope : symbolDatabase->functionScopes) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 51% (fallthrough)
branch  4 taken 49%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
    17815: 1818:        for (const Token* tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
call    0 returned 100%
branch  1 taken 94% (fallthrough)
branch  2 taken 6%
call    3 returned 100%
        -: 1819:
        -: 1820:            // Keep track of which variables were assigned addresses to newly-allocated memory
    16834: 1821:            if (Token::Match(tok, "%var% = malloc|g_malloc|new")) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 1% (fallthrough)
branch  4 taken 99%
       16: 1822:                allocation.insert(std::make_pair(tok->varId(), tok->strAt(2)));
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
branch  8 taken 100% (fallthrough)
branch  9 taken 0% (throw)
call   10 returned 100%
call   11 returned 100%
call   12 never executed
       16: 1823:                inconclusive.insert(std::make_pair(tok->varId(), false));
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
        -: 1824:            }
        -: 1825:
        -: 1826:            // If a previously-allocated pointer is incremented or decremented, any subsequent
        -: 1827:            // free involving pointer arithmetic may or may not be invalid, so we should only
        -: 1828:            // report an inconclusive result.
    33647: 1829:            else if (Token::Match(tok, "%var% = %name% +|-") &&
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 18% (fallthrough)
branch  4 taken 82%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
    33642: 1830:                     tok->varId() == tok->tokAt(2)->varId() &&
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 0% (fallthrough)
branch  8 taken 100%
    16824: 1831:                     allocation.find(tok->varId()) != allocation.end()) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
call    5 returned 100%
branch  6 taken 1% (fallthrough)
branch  7 taken 99%
call    8 returned 100%
branch  9 taken 1% (fallthrough)
branch 10 taken 99%
call   11 returned 100%
branch 12 never executed
branch 13 never executed
call   14 never executed
branch 15 never executed
branch 16 never executed
call   17 never executed
    #####: 1832:                if (printInconclusive)
branch  0 never executed
branch  1 never executed
    #####: 1833:                    inconclusive[tok->varId()] = true;
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -: 1834:                else {
    #####: 1835:                    allocation.erase(tok->varId());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1836:                    inconclusive.erase(tok->varId());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -: 1837:                }
        -: 1838:            }
        -: 1839:
        -: 1840:            // If a previously-allocated pointer is assigned a completely new value,
        -: 1841:            // we can't know if any subsequent free() on that pointer is valid or not.
    16818: 1842:            else if (Token::Match(tok, "%var% =")) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 4% (fallthrough)
branch  4 taken 96%
      747: 1843:                allocation.erase(tok->varId());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
      747: 1844:                inconclusive.erase(tok->varId());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
        -: 1845:            }
        -: 1846:
        -: 1847:            // If a variable that was previously assigned a newly-allocated memory location is
        -: 1848:            // added or subtracted from when used to free the memory, report an error.
    48208: 1849:            else if (Token::Match(tok, "free|g_free|delete ( %any% +|-") ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 99% (fallthrough)
branch  4 taken 1%
branch  5 taken 1% (fallthrough)
branch  6 taken 99%
    32136: 1850:                     Token::Match(tok, "delete [ ] ( %any% +|-") ||
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
branch  5 taken 1% (fallthrough)
branch  6 taken 99%
    16065: 1851:                     Token::Match(tok, "delete %any% +|- %any%")) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -: 1852:
       21: 1853:                const int varIndex = tok->strAt(1) == "(" ? 2 :
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 38% (fallthrough)
branch  5 taken 62%
       21: 1854:                                     tok->strAt(3) == "(" ? 4 : 1;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 13% (fallthrough)
branch  5 taken 88%
       13: 1855:                const int var1 = tok->tokAt(varIndex)->varId();
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
       13: 1856:                const int var2 = tok->tokAt(varIndex + 2)->varId();
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
       26: 1857:                const std::map<int, bool>::const_iterator alloc1 = inconclusive.find(var1);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
call    6 never executed
       26: 1858:                const std::map<int, bool>::const_iterator alloc2 = inconclusive.find(var2);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
call    6 never executed
       13: 1859:                if (alloc1 != inconclusive.end()) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 54% (fallthrough)
branch  4 taken 46%
        7: 1860:                    invalidFreeError(tok, allocation[var1], alloc1->second);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
        6: 1861:                } else if (alloc2 != inconclusive.end()) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 17% (fallthrough)
branch  4 taken 83%
        1: 1862:                    invalidFreeError(tok, allocation[var2], alloc2->second);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
        -: 1863:                }
        -: 1864:            }
        -: 1865:
        -: 1866:            // If the previously-allocated variable is passed in to another function
        -: 1867:            // as a parameter, it might be modified, so we shouldn't report an error
        -: 1868:            // if it is later used to free memory
    16058: 1869:            else if (Token::Match(tok, "%name% (") && !mSettings->library.isFunctionConst(tok->str(), true)) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 7% (fallthrough)
branch  4 taken 93%
call    5 returned 100%
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
branch  9 taken 98% (fallthrough)
branch 10 taken 2%
branch 11 taken 7% (fallthrough)
branch 12 taken 93%
     1179: 1870:                const Token* tok2 = Token::findmatch(tok->next(), "%var%", tok->linkAt(1));
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
     3017: 1871:                while (tok2 != nullptr) {
branch  0 taken 44% (fallthrough)
branch  1 taken 56%
      919: 1872:                    allocation.erase(tok->varId());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
      919: 1873:                    inconclusive.erase(tok2->varId());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
      919: 1874:                    tok2 = Token::findmatch(tok2->next(), "%var%", tok->linkAt(1));
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
        -: 1875:                }
        -: 1876:            }
        -: 1877:        }
        -: 1878:    }
      927: 1879:}
        -: 1880:
function _ZN10CheckOther16invalidFreeErrorEPK5TokenRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEb called 8 returned 100% blocks executed 54%
        8: 1881:void CheckOther::invalidFreeError(const Token *tok, const std::string &allocation, bool inconclusive)
        -: 1882:{
       16: 1883:    std::string alloc = allocation;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
call    4 never executed
        8: 1884:    if (alloc != "new")
call    0 returned 100%
branch  1 taken 50% (fallthrough)
branch  2 taken 50%
        4: 1885:        alloc += "()";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       16: 1886:    std::string deallocated = (alloc == "new") ? "deleted" : "freed";
call    0 returned 100%
call    1 returned 100%
branch  2 taken 50% (fallthrough)
branch  3 taken 50%
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 returned 100%
call    9 never executed
        8: 1887:    reportError(tok, Severity::error, "invalidFree", "Mismatching address is " + deallocated + ". The address you get from " + alloc + " must be " + deallocated + " without offset.", CWE(0U), inconclusive);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
branch  8 taken 100% (fallthrough)
branch  9 taken 0% (throw)
call   10 returned 100%
branch 11 taken 100% (fallthrough)
branch 12 taken 0% (throw)
call   13 returned 100%
branch 14 taken 100% (fallthrough)
branch 15 taken 0% (throw)
call   16 returned 100%
branch 17 taken 100% (fallthrough)
branch 18 taken 0% (throw)
call   19 returned 100%
branch 20 taken 100% (fallthrough)
branch 21 taken 0% (throw)
call   22 returned 100%
call   23 returned 100%
call   24 returned 100%
call   25 returned 100%
call   26 returned 100%
call   27 returned 100%
call   28 never executed
call   29 never executed
call   30 never executed
call   31 never executed
call   32 never executed
call   33 never executed
        8: 1888:}
call    0 never executed
        -: 1889:
        -: 1890:
        -: 1891://---------------------------------------------------------------------------
        -: 1892:// check for the same expression on both sides of an operator
        -: 1893:// (x == x), (x && x), (x || x)
        -: 1894:// (x.y == x.y), (x.y && x.y), (x.y || x.y)
        -: 1895://---------------------------------------------------------------------------
        -: 1896:
        -: 1897:namespace {
function _ZN12_GLOBAL__N_18notconstEPK8Function called 1126 returned 100% blocks executed 100%
     1126: 1898:    bool notconst(const Function* func)
        -: 1899:    {
     1126: 1900:        return !func->isConst();
call    0 returned 100%
        -: 1901:    }
        -: 1902:
function _ZN12_GLOBAL__N_117getConstFunctionsEPK14SymbolDatabaseRNSt7__debug4listIPK8FunctionSaIS7_EEE called 927 returned 100% blocks executed 69%
      927: 1903:    void getConstFunctions(const SymbolDatabase *symbolDatabase, std::list<const Function*> &constFunctions)
        -: 1904:    {
     3570: 1905:        for (const Scope &scope : symbolDatabase->scopeList) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 74% (fallthrough)
branch  4 taken 26%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
        -: 1906:            // only add const functions that do not have a non-const overloaded version
        -: 1907:            // since it is pretty much impossible to tell which is being called.
        -: 1908:            typedef std::map<std::string, std::list<const Function*> > StringFunctionMap;
     5286: 1909:            StringFunctionMap functionsByName;
call    0 returned 100%
call    1 returned 100%
call    2 never executed
     3779: 1910:            for (const Function &func : scope.functionList) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 30% (fallthrough)
branch  4 taken 70%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
call   11 never executed
     1136: 1911:                functionsByName[func.tokenDef->str()].push_back(&func);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
        -: 1912:            }
     3769: 1913:            for (StringFunctionMap::iterator it = functionsByName.begin();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 never executed
     3769: 1914:                 it != functionsByName.end(); ++it) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 30% (fallthrough)
branch  4 taken 70%
     2252: 1915:                const std::list<const Function*>::const_iterator nc = std::find_if(it->second.begin(), it->second.end(), notconst);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 returned 100%
call    9 returned 100%
call   10 returned 100%
call   11 returned 100%
call   12 never executed
     1126: 1916:                if (nc == it->second.end()) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 2% (fallthrough)
branch  5 taken 98%
        -: 1917:                    // ok to add all of them
       22: 1918:                    constFunctions.splice(constFunctions.end(), it->second);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
        -: 1919:                }
        -: 1920:            }
        -: 1921:        }
      927: 1922:    }
        -: 1923:}
        -: 1924:
function _ZN10CheckOther24checkDuplicateExpressionEv called 927 returned 100% blocks executed 84%
      927: 1925:void CheckOther::checkDuplicateExpression()
        -: 1926:{
      927: 1927:    const bool styleEnabled = mSettings->isEnabled(Settings::STYLE);
call    0 returned 100%
      927: 1928:    const bool warningEnabled = mSettings->isEnabled(Settings::WARNING);
call    0 returned 100%
      927: 1929:    if (!styleEnabled && !warningEnabled)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
    #####: 1930:        return;
        -: 1931:
        -: 1932:    // Parse all executing scopes..
      927: 1933:    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
call    0 returned 100%
        -: 1934:
     1854: 1935:    std::list<const Function*> constFunctions;
call    0 returned 100%
call    1 returned 100%
call    2 never executed
      927: 1936:    getConstFunctions(symbolDatabase, constFunctions);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -: 1937:
     1908: 1938:    for (const Scope *scope : symbolDatabase->functionScopes) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 51% (fallthrough)
branch  4 taken 49%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
    18796: 1939:        for (const Token *tok = scope->bodyStart; tok != scope->bodyEnd; tok = tok->next()) {
branch  0 taken 95% (fallthrough)
branch  1 taken 5%
call    2 returned 100%
    17815: 1940:            if (tok->str() == "=" && Token::Match(tok->astOperand1(), "%var%")) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 5% (fallthrough)
branch  3 taken 95%
call    4 returned 100%
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0% (throw)
branch  8 taken 85% (fallthrough)
branch  9 taken 15%
branch 10 taken 4% (fallthrough)
branch 11 taken 96%
      698: 1941:                const Token * endStatement = Token::findsimplematch(tok, ";");
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
      698: 1942:                if (Token::Match(endStatement, "; %type% %var% ;")) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 13% (fallthrough)
branch  4 taken 87%
       92: 1943:                    endStatement = endStatement->tokAt(4);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -: 1944:                }
      698: 1945:                if (Token::Match(endStatement, "%var% %assign%")) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 12% (fallthrough)
branch  4 taken 88%
       86: 1946:                    const Token * nextAssign = endStatement->tokAt(1);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       86: 1947:                    const Token * var1 = tok->astOperand1();
call    0 returned 100%
       86: 1948:                    const Token * var2 = nextAssign->astOperand1();
call    0 returned 100%
      258: 1949:                    if (var1 && var2 &&
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 98% (fallthrough)
branch  3 taken 2%
branch  4 taken 22% (fallthrough)
branch  5 taken 78%
      170: 1950:                        Token::Match(var1->previous(), ";|{|} %var%") &&
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
      168: 1951:                        Token::Match(var2->previous(), ";|{|} %var%") &&
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
branch  4 taken 95% (fallthrough)
branch  5 taken 5%
      244: 1952:                        var2->valueType() && var1->valueType() &&
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
      160: 1953:                        var2->valueType()->originalTypeName == var1->valueType()->originalTypeName &&
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 96% (fallthrough)
branch  4 taken 4%
      157: 1954:                        var2->valueType()->pointer == var1->valueType()->pointer &&
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
      154: 1955:                        var2->valueType()->constness == var1->valueType()->constness &&
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
      154: 1956:                        var2->varId() != var1->varId() && (
call    0 returned 100%
call    1 returned 100%
branch  2 taken 84% (fallthrough)
branch  3 taken 16%
      142: 1957:                            tok->astOperand2()->isArithmeticalOp() ||
call    0 returned 100%
call    1 returned 100%
branch  2 taken 91% (fallthrough)
branch  3 taken 9%
      124: 1958:                            tok->astOperand2()->str() == "." ||
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 29% (fallthrough)
branch  4 taken 71%
       59: 1959:                            Token::Match(tok->astOperand2()->previous(), "%name% (")
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
       35: 1960:                        ) &&
branch  0 taken 97% (fallthrough)
branch  1 taken 3%
       69: 1961:                        tok->next()->tokType() != Token::eType &&
call    0 returned 100%
call    1 returned 100%
branch  2 taken 62% (fallthrough)
branch  3 taken 38%
       55: 1962:                        isSameExpression(mTokenizer->isCPP(), true, tok->next(), nextAssign->next(), mSettings->library, true, false) &&
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
branch  6 taken 90% (fallthrough)
branch  7 taken 10%
      164: 1963:                        isSameExpression(mTokenizer->isCPP(), true, tok->astOperand2(), nextAssign->astOperand2(), mSettings->library, true, false) &&
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0% (throw)
branch  8 taken 100% (fallthrough)
branch  9 taken 0%
      143: 1964:                        tok->astOperand2()->expressionString() == nextAssign->astOperand2()->expressionString()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0% (throw)
call    8 returned 100%
branch  9 taken 22% (fallthrough)
branch 10 taken 78%
call   11 returned 100%
branch 12 taken 22% (fallthrough)
branch 13 taken 78%
call   14 returned 100%
branch 15 never executed
branch 16 never executed
call   17 never executed
branch 18 never executed
branch 19 never executed
call   20 never executed
       19: 1965:                        bool assigned = false;
       19: 1966:                        const Scope * varScope = var1->scope() ? var1->scope() : scope;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
       99: 1967:                        for (const Token *assignTok = Token::findsimplematch(var2, ";"); assignTok && assignTok != varScope->bodyEnd; assignTok = assignTok->next()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 81% (fallthrough)
branch  6 taken 19%
call    7 returned 100%
       80: 1968:                            if (Token::Match(assignTok, "%varid% = %var%", var1->varId()) && Token::Match(assignTok, "%var% = %varid%", var2->varId())) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
branch  4 taken 1% (fallthrough)
branch  5 taken 99%
call    6 returned 100%
call    7 returned 100%
branch  8 taken 100% (fallthrough)
branch  9 taken 0% (throw)
branch 10 taken 100% (fallthrough)
branch 11 taken 0%
branch 12 taken 1% (fallthrough)
branch 13 taken 99%
        1: 1969:                                assigned = true;
        -: 1970:                            }
       80: 1971:                            if (Token::Match(assignTok, "%varid% = %var%", var2->varId()) && Token::Match(assignTok, "%var% = %varid%", var1->varId())) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
branch  4 taken 3% (fallthrough)
branch  5 taken 98%
call    6 returned 100%
call    7 returned 100%
branch  8 taken 100% (fallthrough)
branch  9 taken 0% (throw)
branch 10 taken 100% (fallthrough)
branch 11 taken 0%
branch 12 taken 3% (fallthrough)
branch 13 taken 98%
        2: 1972:                                assigned = true;
        -: 1973:                            }
        -: 1974:                        }
       19: 1975:                        if (!assigned && !isUniqueExpression(tok->astOperand2()))
branch  0 taken 84% (fallthrough)
branch  1 taken 16%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
branch  6 taken 50% (fallthrough)
branch  7 taken 50%
branch  8 taken 42% (fallthrough)
branch  9 taken 58%
        8: 1976:                            duplicateAssignExpressionError(var1, var2, false);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       11: 1977:                        else if (mSettings->inconclusive)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       11: 1978:                            duplicateAssignExpressionError(var1, var2, true);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -: 1979:                    }
        -: 1980:                }
        -: 1981:            }
    35545: 1982:            ErrorPath errorPath;
call    0 returned 100%
call    1 never executed
    17815: 1983:            if (tok->isOp() && tok->astOperand1() && !Token::Match(tok, "+|*|<<|>>|+=|*=|<<=|>>=")) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 12% (fallthrough)
branch  4 taken 88%
call    5 returned 100%
branch  6 taken 98% (fallthrough)
branch  7 taken 2%
call    8 returned 100%
branch  9 taken 100% (fallthrough)
branch 10 taken 0% (throw)
branch 11 taken 86% (fallthrough)
branch 12 taken 14%
branch 13 taken 10% (fallthrough)
branch 14 taken 90%
     1770: 1984:                if (Token::Match(tok, "==|!=|-") && astIsFloat(tok->astOperand1(), true))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 14% (fallthrough)
branch  4 taken 86%
call    5 returned 100%
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
branch  9 taken 35% (fallthrough)
branch 10 taken 65%
branch 11 taken 5% (fallthrough)
branch 12 taken 95%
       85: 1985:                    continue;
     1685: 1986:                if (isSameExpression(mTokenizer->isCPP(), true, tok->astOperand1(), tok->astOperand2(), mSettings->library, true, true, &errorPath)) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
branch  6 taken 4% (fallthrough)
branch  7 taken 96%
       66: 1987:                    if (isWithoutSideEffects(mTokenizer->isCPP(), tok->astOperand1())) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
branch  5 taken 95% (fallthrough)
branch  6 taken 5%
       63: 1988:                        const bool assignment = tok->str() == "=";
call    0 returned 100%
call    1 returned 100%
       63: 1989:                        if (assignment && warningEnabled)
branch  0 taken 14% (fallthrough)
branch  1 taken 86%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        9: 1990:                            selfAssignmentError(tok, tok->astOperand1()->expressionString());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 never executed
       54: 1991:                        else if (styleEnabled) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       54: 1992:                            if (mTokenizer->isCPP() && mSettings->standards.cpp==Standards::CPP11 && tok->str() == "==") {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
branch  9 taken 0% (fallthrough)
branch 10 taken 100%
    #####: 1993:                                const Token* parent = tok->astParent();
call    0 never executed
    #####: 1994:                                while (parent && parent->astParent()) {
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 1995:                                    parent = parent->astParent();
call    0 never executed
        -: 1996:                                }
    #####: 1997:                                if (parent && parent->previous() && parent->previous()->str() == "static_assert") {
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
    #####: 1998:                                    continue;
        -: 1999:                                }
        -: 2000:                            }
       54: 2001:                            duplicateExpressionError(tok->astOperand1(), tok->astOperand2(), tok, errorPath);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0% (throw)
call    8 returned 100%
call    9 never executed
        -: 2002:                        }
        -: 2003:                    }
     1619: 2004:                } else if (tok->str() == "=" && Token::simpleMatch(tok->astOperand2(), "=") && isSameExpression(mTokenizer->isCPP(), false, tok->astOperand1(), tok->astOperand2()->astOperand1(), mSettings->library, true, false)) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 50% (fallthrough)
branch  3 taken 50%
call    4 returned 100%
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0% (throw)
branch  8 taken 1% (fallthrough)
branch  9 taken 99%
call   10 returned 100%
call   11 returned 100%
call   12 returned 100%
call   13 returned 100%
call   14 returned 100%
branch 15 taken 100% (fallthrough)
branch 16 taken 0% (throw)
branch 17 taken 50% (fallthrough)
branch 18 taken 50%
branch 19 taken 1% (fallthrough)
branch 20 taken 99%
        2: 2005:                    if (warningEnabled && isWithoutSideEffects(mTokenizer->isCPP(), tok->astOperand1())) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
branch  7 taken 100% (fallthrough)
branch  8 taken 0%
branch  9 taken 100% (fallthrough)
branch 10 taken 0%
        2: 2006:                        selfAssignmentError(tok, tok->astOperand1()->expressionString());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 never executed
        -: 2007:                    }
     3234: 2008:                } else if (styleEnabled &&
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
branch  2 taken 1% (fallthrough)
branch  3 taken 99%
     1633: 2009:                           isOppositeExpression(mTokenizer->isCPP(), tok->astOperand1(), tok->astOperand2(), mSettings->library, false, true, &errorPath) &&
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
branch  6 taken 81% (fallthrough)
branch  7 taken 19%
     1646: 2010:                           !Token::Match(tok, "=|-|-=|/|/=") &&
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
branch  5 taken 100% (fallthrough)
branch  6 taken 0%
       13: 2011:                           isWithoutSideEffects(mTokenizer->isCPP(), tok->astOperand1())) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
       13: 2012:                    oppositeExpressionError(tok, errorPath);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 never executed
     1604: 2013:                } else if (!Token::Match(tok, "[-/%]")) { // These operators are not associative
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 94% (fallthrough)
branch  4 taken 6%
     1513: 2014:                    if (styleEnabled && tok->astOperand2() && tok->str() == tok->astOperand1()->str() && isSameExpression(mTokenizer->isCPP(), true, tok->astOperand2(), tok->astOperand1()->astOperand2(), mSettings->library, true, true, &errorPath) && isWithoutSideEffects(mTokenizer->isCPP(), tok->astOperand2()))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 82% (fallthrough)
branch  4 taken 18%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
branch  9 taken 2% (fallthrough)
branch 10 taken 98%
call   11 returned 100%
call   12 returned 100%
call   13 returned 100%
call   14 returned 100%
call   15 returned 100%
branch 16 taken 100% (fallthrough)
branch 17 taken 0% (throw)
branch 18 taken 20% (fallthrough)
branch 19 taken 80%
call   20 returned 100%
call   21 returned 100%
call   22 returned 100%
branch 23 taken 100% (fallthrough)
branch 24 taken 0% (throw)
branch 25 taken 75% (fallthrough)
branch 26 taken 25%
branch 27 taken 1% (fallthrough)
branch 28 taken 99%
        3: 2015:                        duplicateExpressionError(tok->astOperand2(), tok->astOperand1()->astOperand2(), tok, errorPath);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
call   10 never executed
     1510: 2016:                    else if (tok->astOperand2() && isConstExpression(tok->astOperand1(), mSettings->library, true, mTokenizer->isCPP())) {
call    0 returned 100%
branch  1 taken 82% (fallthrough)
branch  2 taken 18%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0% (throw)
branch  8 taken 97% (fallthrough)
branch  9 taken 3%
branch 10 taken 80% (fallthrough)
branch 11 taken 20%
     1202: 2017:                        const Token *ast1 = tok->astOperand1();
call    0 returned 100%
     1238: 2018:                        while (ast1 && tok->str() == ast1->str()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
branch  5 taken 1% (fallthrough)
branch  6 taken 99%
branch  7 taken 1% (fallthrough)
branch  8 taken 99%
       39: 2019:                            if (isSameExpression(mTokenizer->isCPP(), true, ast1->astOperand1(), tok->astOperand2(), mSettings->library, true, true, &errorPath) &&
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
branch  6 taken 67% (fallthrough)
branch  7 taken 33%
branch  8 taken 11% (fallthrough)
branch  9 taken 89%
       20: 2020:                                isWithoutSideEffects(mTokenizer->isCPP(), ast1->astOperand1()) &&
branch  0 taken 17% (fallthrough)
branch  1 taken 83%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
branch  7 taken 100% (fallthrough)
branch  8 taken 0%
        2: 2021:                                isWithoutSideEffects(mTokenizer->isCPP(), ast1->astOperand2()))
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
        -: 2022:                                // Probably the message should be changed to 'duplicate expressions X in condition or something like that'.
        2: 2023:                                duplicateExpressionError(ast1->astOperand1(), tok->astOperand2(), tok, errorPath);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0% (throw)
call    8 returned 100%
call    9 never executed
       18: 2024:                            ast1 = ast1->astOperand1();
call    0 returned 100%
        -: 2025:                        }
        -: 2026:                    }
        -: 2027:                }
    16045: 2028:            } else if (styleEnabled && tok->astOperand1() && tok->astOperand2() && tok->str() == ":" && tok->astParent() && tok->astParent()->str() == "?") {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 17% (fallthrough)
branch  4 taken 83%
call    5 returned 100%
branch  6 taken 70% (fallthrough)
branch  7 taken 30%
call    8 returned 100%
call    9 returned 100%
branch 10 taken 3% (fallthrough)
branch 11 taken 97%
call   12 returned 100%
branch 13 taken 98% (fallthrough)
branch 14 taken 2%
call   15 returned 100%
call   16 returned 100%
call   17 returned 100%
branch 18 taken 88% (fallthrough)
branch 19 taken 12%
branch 20 taken 1% (fallthrough)
branch 21 taken 99%
       43: 2029:                if (!tok->astOperand1()->values().empty() && !tok->astOperand2()->values().empty() && isEqualKnownValue(tok->astOperand1(), tok->astOperand2()))
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 58% (fallthrough)
branch  4 taken 42%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
branch  8 taken 92% (fallthrough)
branch  9 taken 8%
call   10 returned 100%
call   11 returned 100%
call   12 returned 100%
branch 13 taken 100% (fallthrough)
branch 14 taken 0% (throw)
branch 15 taken 39% (fallthrough)
branch 16 taken 61%
branch 17 taken 21% (fallthrough)
branch 18 taken 79%
        9: 2030:                    duplicateValueTernaryError(tok);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       34: 2031:                else if (isSameExpression(mTokenizer->isCPP(), true, tok->astOperand1(), tok->astOperand2(), mSettings->library, false, true, &errorPath))
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
branch  6 taken 6% (fallthrough)
branch  7 taken 94%
        2: 2032:                    duplicateExpressionTernaryError(tok, errorPath);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 returned 100%
branch  8 taken 99%
branch  9 taken 1%
call   10 never executed
        -: 2033:            }
        -: 2034:        }
        -: 2035:    }
        -: 2036:}
        -: 2037:
function _ZN10CheckOther23oppositeExpressionErrorEPK5TokenNSt7__debug4listISt4pairIS2_NSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEESaISC_EEE called 13 returned 100% blocks executed 48%
       13: 2038:void CheckOther::oppositeExpressionError(const Token *opTok, ErrorPath errors)
        -: 2039:{
       13: 2040:    errors.emplace_back(opTok, "");
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -: 2041:
       26: 2042:    const std::string& op = opTok ? opTok->str() : "&&";
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 never executed
call    7 never executed
branch  8 never executed
branch  9 never executed
branch 10 taken 0% (fallthrough)
branch 11 taken 100%
call   12 never executed
call   13 returned 100%
branch 14 never executed
branch 15 never executed
call   16 never executed
call   17 never executed
        -: 2043:
       13: 2044:    reportError(errors, Severity::style, "oppositeExpression", "Opposite expression on both sides of \'" + op + "\'.\n"
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
call   10 returned 100%
call   11 never executed
call   12 never executed
        -: 2045:                "Finding the opposite expression on both sides of an operator is suspicious and might "
        -: 2046:                "indicate a cut and paste or logic error. Please examine this code carefully to "
        -: 2047:                "determine if it is correct.", CWE398, false);
       13: 2048:}
        -: 2049:
function _ZN10CheckOther24duplicateExpressionErrorEPK5TokenS2_S2_NSt7__debug4listISt4pairIS2_NSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEESaISC_EEE called 59 returned 100% blocks executed 52%
       59: 2050:void CheckOther::duplicateExpressionError(const Token *tok1, const Token *tok2, const Token *opTok, ErrorPath errors)
        -: 2051:{
       59: 2052:    errors.emplace_back(opTok, "");
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -: 2053:
      118: 2054:    const std::string& expr1 = tok1 ? tok1->expressionString() : "x";
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
call    5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
branch  9 taken 0% (fallthrough)
branch 10 taken 100%
call   11 never executed
call   12 returned 100%
branch 13 never executed
branch 14 never executed
call   15 never executed
call   16 never executed
      118: 2055:    const std::string& expr2 = tok2 ? tok2->expressionString() : "x";
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
call    5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
branch  9 taken 0% (fallthrough)
branch 10 taken 100%
call   11 never executed
call   12 returned 100%
branch 13 never executed
branch 14 never executed
call   15 never executed
call   16 never executed
        -: 2056:
      118: 2057:    const std::string& op = opTok ? opTok->str() : "&&";
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 never executed
call    7 never executed
branch  8 never executed
branch  9 never executed
branch 10 taken 0% (fallthrough)
branch 11 taken 100%
call   12 never executed
call   13 returned 100%
branch 14 never executed
branch 15 never executed
call   16 never executed
call   17 never executed
call   18 never executed
      118: 2058:    std::string msg = "Same expression on both sides of \'" + op + "\'";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 returned 100%
call    8 never executed
call    9 never executed
      118: 2059:    std::string id = "duplicateExpression";
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
call    5 returned 100%
call    6 never executed
call    7 never executed
       59: 2060:    if (expr1 != expr2) {
call    0 returned 100%
branch  1 taken 44% (fallthrough)
branch  2 taken 56%
       26: 2061:        id = "knownConditionTrueFalse";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       52: 2062:        std::string exprMsg = "The expression \'" + expr1 + " " + op +  " " + expr2 + "\' is always ";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
branch 13 taken 100% (fallthrough)
branch 14 taken 0% (throw)
call   15 returned 100%
branch 16 taken 100% (fallthrough)
branch 17 taken 0% (throw)
call   18 returned 100%
call   19 returned 100%
call   20 returned 100%
call   21 returned 100%
call   22 returned 100%
call   23 returned 100%
call   24 never executed
call   25 never executed
call   26 never executed
call   27 never executed
call   28 never executed
       26: 2063:        if (Token::Match(opTok, "==|>=|<="))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 4% (fallthrough)
branch  4 taken 96%
        1: 2064:            msg = exprMsg + "true";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
call    4 returned 100%
       25: 2065:        else if (Token::Match(opTok, "!=|>|<"))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 76% (fallthrough)
branch  4 taken 24%
       19: 2066:            msg = exprMsg + "false";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
call    4 returned 100%
       26: 2067:        if (!Token::Match(tok1, "%num%|NULL|nullptr") && !Token::Match(tok2, "%num%|NULL|nullptr"))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0% (throw)
branch  8 taken 42% (fallthrough)
branch  9 taken 58%
branch 10 taken 42% (fallthrough)
branch 11 taken 58%
       11: 2068:            msg += " because '" + expr1 + "' and '" + expr2 + "' represent the same value";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
branch 13 taken 100% (fallthrough)
branch 14 taken 0% (throw)
call   15 returned 100%
call   16 returned 100%
call   17 returned 100%
call   18 returned 100%
call   19 never executed
call   20 never executed
call   21 never executed
call   22 never executed
        -: 2069:    }
        -: 2070:
       59: 2071:    reportError(errors, Severity::style, id.c_str(), msg + ".\n"
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 never executed
        -: 2072:                "Finding the same expression on both sides of an operator is suspicious and might "
        -: 2073:                "indicate a cut and paste or logic error. Please examine this code carefully to "
        -: 2074:                "determine if it is correct.", CWE398, false);
       59: 2075:}
        -: 2076:
function _ZN10CheckOther30duplicateAssignExpressionErrorEPK5TokenS2_b called 19 returned 100% blocks executed 42%
       19: 2077:void CheckOther::duplicateAssignExpressionError(const Token *tok1, const Token *tok2, bool inconclusive)
        -: 2078:{
       38: 2079:    const std::list<const Token *> toks = { tok2, tok1 };
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
call    5 returned 100%
call    6 never executed
        -: 2080:
       38: 2081:    const std::string& var1 = tok1 ? tok1->str() : "x";
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 never executed
call    7 never executed
branch  8 never executed
branch  9 never executed
branch 10 taken 0% (fallthrough)
branch 11 taken 100%
call   12 never executed
call   13 returned 100%
branch 14 never executed
branch 15 never executed
call   16 never executed
call   17 never executed
       38: 2082:    const std::string& var2 = tok2 ? tok2->str() : "x";
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 never executed
call    7 never executed
branch  8 never executed
branch  9 never executed
branch 10 taken 0% (fallthrough)
branch 11 taken 100%
call   12 never executed
call   13 returned 100%
branch 14 never executed
branch 15 never executed
call   16 never executed
call   17 never executed
        -: 2083:
       38: 2084:    reportError(toks, Severity::style, "duplicateAssignExpression",
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       38: 2085:                "Same expression used in consecutive assignments of '" + var1 + "' and '" + var2 + "'.\n"
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
call   13 returned 100%
call   14 returned 100%
call   15 returned 100%
call   16 never executed
call   17 never executed
call   18 never executed
call   19 never executed
       38: 2086:                "Finding variables '" + var1 + "' and '" + var2 + "' that are assigned the same expression "
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
call   13 returned 100%
call   14 returned 100%
call   15 returned 100%
call   16 never executed
call   17 never executed
call   18 never executed
call   19 never executed
        -: 2087:                "is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to "
        -: 2088:                "determine if it is correct.", CWE398, inconclusive);
       19: 2089:}
call    0 never executed
        -: 2090:
function _ZN10CheckOther31duplicateExpressionTernaryErrorEPK5TokenNSt7__debug4listISt4pairIS2_NSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEESaISC_EEE called 2 returned 100% blocks executed 62%
        2: 2091:void CheckOther::duplicateExpressionTernaryError(const Token *tok, ErrorPath errors)
        -: 2092:{
        2: 2093:    errors.emplace_back(tok, "");
call    0 returned 100%
        2: 2094:    reportError(errors, Severity::style, "duplicateExpressionTernary", "Same expression in both branches of ternary operator.\n"
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
        -: 2095:                "Finding the same expression in both branches of ternary operator is suspicious as "
        -: 2096:                "the same code is executed regardless of the condition.", CWE398, false);
        2: 2097:}
        -: 2098:
function _ZN10CheckOther26duplicateValueTernaryErrorEPK5Token called 9 returned 100% blocks executed 100%
        9: 2099:void CheckOther::duplicateValueTernaryError(const Token *tok)
        -: 2100:{
        9: 2101:    reportError(tok, Severity::style, "duplicateValueTernary", "Same value in both branches of ternary operator.\n"
call    0 returned 100%
        -: 2102:                "Finding the same value in both branches of ternary operator is suspicious as "
        -: 2103:                "the same code is executed regardless of the condition.", CWE398, false);
        9: 2104:}
        -: 2105:
function _ZN10CheckOther19selfAssignmentErrorEPK5TokenRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 12 returned 100% blocks executed 58%
       12: 2106:void CheckOther::selfAssignmentError(const Token *tok, const std::string &varname)
        -: 2107:{
       24: 2108:    reportError(tok, Severity::warning,
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -: 2109:                "selfAssignment",
       24: 2110:                "$symbol:" + varname + "\n"
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
call    5 returned 100%
call    6 never executed
call    7 never executed
        -: 2111:                "Redundant assignment of '$symbol' to itself.", CWE398, false);
       12: 2112:}
        -: 2113:
        -: 2114://-----------------------------------------------------------------------------
        -: 2115:// Check is a comparison of two variables leads to condition, which is
        -: 2116:// always true or false.
        -: 2117:// For instance: int a = 1; if(isless(a,a)){...}
        -: 2118:// In this case isless(a,a) always evaluates to false.
        -: 2119://
        -: 2120:// Reference:
        -: 2121:// - http://www.cplusplus.com/reference/cmath/
        -: 2122://-----------------------------------------------------------------------------
function _ZN10CheckOther42checkComparisonFunctionIsAlwaysTrueOrFalseEv called 927 returned 100% blocks executed 90%
      927: 2123:void CheckOther::checkComparisonFunctionIsAlwaysTrueOrFalse()
        -: 2124:{
      927: 2125:    if (!mSettings->isEnabled(Settings::WARNING))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2126:        return;
        -: 2127:
      927: 2128:    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
call    0 returned 100%
     1908: 2129:    for (const Scope * scope : symbolDatabase->functionScopes) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 51% (fallthrough)
branch  4 taken 49%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
    17815: 2130:        for (const Token* tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
call    0 returned 100%
branch  1 taken 94% (fallthrough)
branch  2 taken 6%
call    3 returned 100%
    16834: 2131:            if (tok->isName() && Token::Match(tok, "isgreater|isless|islessgreater|isgreaterequal|islessequal ( %var% , %var% )")) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 36% (fallthrough)
branch  4 taken 64%
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0% (throw)
branch  8 taken 1% (fallthrough)
branch  9 taken 99%
branch 10 taken 1% (fallthrough)
branch 11 taken 99%
       10: 2132:                const int varidLeft = tok->tokAt(2)->varId();// get the left varid
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
       10: 2133:                const int varidRight = tok->tokAt(4)->varId();// get the right varid
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
        -: 2134:                // compare varids: if they are not zero but equal
        -: 2135:                // --> the comparison function is called with the same variables
       10: 2136:                if (varidLeft == varidRight) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        5: 2137:                    const std::string& functionName = tok->str(); // store function name
call    0 returned 100%
        5: 2138:                    const std::string& varNameLeft = tok->strAt(2); // get the left variable name
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        5: 2139:                    if (functionName == "isgreater" || functionName == "isless" || functionName == "islessgreater") {
call    0 returned 100%
branch  1 taken 80% (fallthrough)
branch  2 taken 20%
call    3 returned 100%
branch  4 taken 75% (fallthrough)
branch  5 taken 25%
call    6 returned 100%
branch  7 taken 33% (fallthrough)
branch  8 taken 67%
branch  9 taken 60% (fallthrough)
branch 10 taken 40%
        -: 2140:                        // e.g.: isgreater(x,x) --> (x)>(x) --> false
        3: 2141:                        checkComparisonFunctionIsAlwaysTrueOrFalseError(tok, functionName, varNameLeft, false);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -: 2142:                    } else { // functionName == "isgreaterequal" || functionName == "islessequal"
        -: 2143:                        // e.g.: isgreaterequal(x,x) --> (x)>=(x) --> true
        2: 2144:                        checkComparisonFunctionIsAlwaysTrueOrFalseError(tok, functionName, varNameLeft, true);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -: 2145:                    }
        -: 2146:                }
        -: 2147:            }
        -: 2148:        }
        -: 2149:    }
        -: 2150:}
function _ZN10CheckOther47checkComparisonFunctionIsAlwaysTrueOrFalseErrorEPK5TokenRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESA_b called 5 returned 100% blocks executed 47%
        5: 2151:void CheckOther::checkComparisonFunctionIsAlwaysTrueOrFalseError(const Token* tok, const std::string &functionName, const std::string &varName, const bool result)
        -: 2152:{
       10: 2153:    const std::string strResult = result ? "true" : "false";
call    0 returned 100%
branch  1 taken 40% (fallthrough)
branch  2 taken 60%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 returned 100%
call    8 never executed
        5: 2154:    const struct CWE cweResult = result ? CWE571 : CWE570;
branch  0 taken 40% (fallthrough)
branch  1 taken 60%
        -: 2155:
       10: 2156:    reportError(tok, Severity::warning, "comparisonFunctionIsAlwaysTrueOrFalse",
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       10: 2157:                "$symbol:" + functionName + "\n"
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 returned 100%
call    8 never executed
call    9 never executed
       10: 2158:                "Comparison of two identical variables with $symbol(" + varName + "," + varName + ") always evaluates to " + strResult + ".\n"
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
branch 13 taken 100% (fallthrough)
branch 14 taken 0% (throw)
call   15 returned 100%
branch 16 taken 100% (fallthrough)
branch 17 taken 0% (throw)
call   18 returned 100%
call   19 returned 100%
call   20 returned 100%
call   21 returned 100%
call   22 returned 100%
call   23 returned 100%
call   24 never executed
call   25 never executed
call   26 never executed
call   27 never executed
call   28 never executed
call   29 never executed
       10: 2159:                "The function $symbol is designed to compare two variables. Calling this function with one variable (" + varName + ") "
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 returned 100%
call    8 never executed
call    9 never executed
       10: 2160:                "for both parameters leads to a statement which is always " + strResult + ".", cweResult, false);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 returned 100%
call    8 never executed
call    9 never executed
        5: 2161:}
call    0 never executed
        -: 2162:
        -: 2163://---------------------------------------------------------------------------
        -: 2164:// Check testing sign of unsigned variables and pointers.
        -: 2165://---------------------------------------------------------------------------
function _ZN10CheckOther27checkSignOfUnsignedVariableEv called 927 returned 100% blocks executed 88%
      927: 2166:void CheckOther::checkSignOfUnsignedVariable()
        -: 2167:{
      927: 2168:    if (!mSettings->isEnabled(Settings::STYLE))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2169:        return;
        -: 2170:
      927: 2171:    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
call    0 returned 100%
        -: 2172:
     1908: 2173:    for (const Scope * scope : symbolDatabase->functionScopes) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 51% (fallthrough)
branch  4 taken 49%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
        -: 2174:        // check all the code in the function
    17815: 2175:        for (const Token *tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
call    0 returned 100%
branch  1 taken 94% (fallthrough)
branch  2 taken 6%
call    3 returned 100%
    16834: 2176:            if (!tok->isComparisonOp() || !tok->astOperand1() || !tok->astOperand2())
call    0 returned 100%
branch  1 taken 2% (fallthrough)
branch  2 taken 98%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
call    6 returned 100%
branch  7 taken 0% (fallthrough)
branch  8 taken 100%
branch  9 taken 98% (fallthrough)
branch 10 taken 2%
    16444: 2177:                continue;
        -: 2178:
      390: 2179:            const ValueFlow::Value *v1 = tok->astOperand1()->getValue(0);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
      390: 2180:            const ValueFlow::Value *v2 = tok->astOperand2()->getValue(0);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
        -: 2181:
      390: 2182:            if (Token::Match(tok, "<|<=") && v2 && v2->isKnown()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 25% (fallthrough)
branch  4 taken 75%
branch  5 taken 47% (fallthrough)
branch  6 taken 53%
call    7 returned 100%
branch  8 taken 94% (fallthrough)
branch  9 taken 6%
branch 10 taken 11% (fallthrough)
branch 11 taken 89%
       44: 2183:                const ValueType* vt = tok->astOperand1()->valueType();
call    0 returned 100%
call    1 returned 100%
       44: 2184:                if (vt && vt->pointer)
branch  0 taken 91% (fallthrough)
branch  1 taken 9%
branch  2 taken 13% (fallthrough)
branch  3 taken 88%
        5: 2185:                    pointerLessThanZeroError(tok, v2);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       44: 2186:                if (vt && vt->sign == ValueType::UNSIGNED)
branch  0 taken 91% (fallthrough)
branch  1 taken 9%
branch  2 taken 28% (fallthrough)
branch  3 taken 73%
       11: 2187:                    unsignedLessThanZeroError(tok, v2, tok->astOperand1()->expressionString());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 never executed
      346: 2188:            } else if (Token::Match(tok, ">|>=") && v1 && v1->isKnown()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 23% (fallthrough)
branch  4 taken 77%
branch  5 taken 31% (fallthrough)
branch  6 taken 69%
call    7 returned 100%
branch  8 taken 80% (fallthrough)
branch  9 taken 20%
branch 10 taken 6% (fallthrough)
branch 11 taken 94%
       20: 2189:                const ValueType* vt = tok->astOperand2()->valueType();
call    0 returned 100%
call    1 returned 100%
       20: 2190:                if (vt && vt->pointer)
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
branch  2 taken 6% (fallthrough)
branch  3 taken 94%
        1: 2191:                    pointerLessThanZeroError(tok, v1);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       20: 2192:                if (vt && vt->sign == ValueType::UNSIGNED)
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
branch  2 taken 33% (fallthrough)
branch  3 taken 67%
        6: 2193:                    unsignedLessThanZeroError(tok, v1, tok->astOperand2()->expressionString());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 never executed
      326: 2194:            } else if (Token::simpleMatch(tok, ">=") && v2 && v2->isKnown()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 9% (fallthrough)
branch  4 taken 91%
branch  5 taken 79% (fallthrough)
branch  6 taken 21%
call    7 returned 100%
branch  8 taken 100% (fallthrough)
branch  9 taken 0%
branch 10 taken 7% (fallthrough)
branch 11 taken 93%
       22: 2195:                const ValueType* vt = tok->astOperand1()->valueType();
call    0 returned 100%
call    1 returned 100%
       22: 2196:                if (vt && vt->pointer)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 23% (fallthrough)
branch  3 taken 77%
        5: 2197:                    pointerPositiveError(tok, v2);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       22: 2198:                if (vt && vt->sign == ValueType::UNSIGNED)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 36% (fallthrough)
branch  3 taken 64%
        8: 2199:                    unsignedPositiveError(tok, v2, tok->astOperand1()->expressionString());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 never executed
      304: 2200:            } else if (Token::simpleMatch(tok, "<=") && v1 && v1->isKnown()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 5% (fallthrough)
branch  4 taken 95%
branch  5 taken 63% (fallthrough)
branch  6 taken 38%
call    7 returned 100%
branch  8 taken 100% (fallthrough)
branch  9 taken 0%
branch 10 taken 3% (fallthrough)
branch 11 taken 97%
       10: 2201:                const ValueType* vt = tok->astOperand2()->valueType();
call    0 returned 100%
call    1 returned 100%
       10: 2202:                if (vt && vt->pointer)
branch  0 taken 70% (fallthrough)
branch  1 taken 30%
branch  2 taken 14% (fallthrough)
branch  3 taken 86%
        1: 2203:                    pointerPositiveError(tok, v1);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       10: 2204:                if (vt && vt->sign == ValueType::UNSIGNED)
branch  0 taken 70% (fallthrough)
branch  1 taken 30%
branch  2 taken 29% (fallthrough)
branch  3 taken 71%
        2: 2205:                    unsignedPositiveError(tok, v1, tok->astOperand2()->expressionString());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 never executed
        -: 2206:            }
        -: 2207:        }
        -: 2208:    }
        -: 2209:}
        -: 2210:
function _ZN10CheckOther25unsignedLessThanZeroErrorEPK5TokenPKN9ValueFlow5ValueERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 17 returned 100% blocks executed 48%
       17: 2211:void CheckOther::unsignedLessThanZeroError(const Token *tok, const ValueFlow::Value * v, const std::string &varname)
        -: 2212:{
       34: 2213:    reportError(getErrorPath(tok, v, "Unsigned less than zero"), Severity::style, "unsignedLessThanZero",
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
branch  8 taken 100% (fallthrough)
branch  9 taken 0% (throw)
call   10 returned 100%
call   11 returned 100%
call   12 returned 100%
call   13 never executed
call   14 never executed
call   15 never executed
       34: 2214:                "$symbol:" + varname + "\n"
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
call    5 returned 100%
call    6 never executed
call    7 never executed
        -: 2215:                "Checking if unsigned expression '$symbol' is less than zero.\n"
        -: 2216:                "The unsigned expression '$symbol' will never be negative so it "
        -: 2217:                "is either pointless or an error to check if it is.", CWE570, false);
       17: 2218:}
        -: 2219:
function _ZN10CheckOther24pointerLessThanZeroErrorEPK5TokenPKN9ValueFlow5ValueE called 6 returned 100% blocks executed 48%
        6: 2220:void CheckOther::pointerLessThanZeroError(const Token *tok, const ValueFlow::Value *v)
        -: 2221:{
        6: 2222:    reportError(getErrorPath(tok, v, "Pointer less than zero"), Severity::style, "pointerLessThanZero",
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0% (throw)
call    8 returned 100%
branch  9 taken 100% (fallthrough)
branch 10 taken 0% (throw)
call   11 returned 100%
branch 12 taken 100% (fallthrough)
branch 13 taken 0% (throw)
call   14 returned 100%
call   15 returned 100%
call   16 returned 100%
call   17 returned 100%
call   18 returned 100%
call   19 never executed
call   20 never executed
call   21 never executed
call   22 never executed
call   23 never executed
        -: 2223:                "A pointer can not be negative so it is either pointless or an error to check if it is.", CWE570, false);
        6: 2224:}
        -: 2225:
function _ZN10CheckOther21unsignedPositiveErrorEPK5TokenPKN9ValueFlow5ValueERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 10 returned 100% blocks executed 48%
       10: 2226:void CheckOther::unsignedPositiveError(const Token *tok, const ValueFlow::Value * v, const std::string &varname)
        -: 2227:{
       20: 2228:    reportError(getErrorPath(tok, v, "Unsigned positive"), Severity::style, "unsignedPositive",
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
branch  8 taken 100% (fallthrough)
branch  9 taken 0% (throw)
call   10 returned 100%
call   11 returned 100%
call   12 returned 100%
call   13 never executed
call   14 never executed
call   15 never executed
       20: 2229:                "$symbol:" + varname + "\n"
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
call    5 returned 100%
call    6 never executed
call    7 never executed
        -: 2230:                "Unsigned expression '$symbol' can't be negative so it is unnecessary to test it.", CWE570, false);
       10: 2231:}
        -: 2232:
function _ZN10CheckOther20pointerPositiveErrorEPK5TokenPKN9ValueFlow5ValueE called 6 returned 100% blocks executed 48%
        6: 2233:void CheckOther::pointerPositiveError(const Token *tok, const ValueFlow::Value * v)
        -: 2234:{
        6: 2235:    reportError(getErrorPath(tok, v, "Pointer positive"), Severity::style, "pointerPositive",
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0% (throw)
call    8 returned 100%
branch  9 taken 100% (fallthrough)
branch 10 taken 0% (throw)
call   11 returned 100%
branch 12 taken 100% (fallthrough)
branch 13 taken 0% (throw)
call   14 returned 100%
call   15 returned 100%
call   16 returned 100%
call   17 returned 100%
call   18 returned 100%
call   19 never executed
call   20 never executed
call   21 never executed
call   22 never executed
call   23 never executed
        -: 2236:                "A pointer can not be negative so it is either pointless or an error to check if it is not.", CWE570, false);
        6: 2237:}
        -: 2238:
        -: 2239:/* check if a constructor in given class scope takes a reference */
function _ZL25constructorTakesReferencePK5Scope called 3 returned 100% blocks executed 89%
        3: 2240:static bool constructorTakesReference(const Scope * const classScope)
        -: 2241:{
        6: 2242:    for (const Function &constructor : classScope->functionList) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 67% (fallthrough)
branch  4 taken 33%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
branch  8 taken 67%
branch  9 taken 33%
call   10 returned 100%
branch 11 taken 67%
branch 12 taken 33%
call   13 never executed
call   14 never executed
        4: 2243:        if (constructor.isConstructor()) {
call    0 returned 100%
branch  1 taken 75% (fallthrough)
branch  2 taken 25%
        4: 2244:            for (int argnr = 0U; argnr < constructor.argCount(); argnr++) {
call    0 returned 100%
branch  1 taken 50% (fallthrough)
branch  2 taken 50%
        2: 2245:                const Variable * const argVar = constructor.getArgumentVar(argnr);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        2: 2246:                if (argVar && argVar->isReference()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 50% (fallthrough)
branch  4 taken 50%
branch  5 taken 50% (fallthrough)
branch  6 taken 50%
        1: 2247:                    return true;
        -: 2248:                }
        -: 2249:            }
        -: 2250:        }
        -: 2251:    }
        2: 2252:    return false;
        -: 2253:}
        -: 2254:
        -: 2255://---------------------------------------------------------------------------
        -: 2256:// This check rule works for checking the "const A a = getA()" usage when getA() returns "const A &" or "A &".
        -: 2257:// In most scenarios, "const A & a = getA()" will be more efficient.
        -: 2258://---------------------------------------------------------------------------
function _ZN10CheckOther18checkRedundantCopyEv called 927 returned 100% blocks executed 93%
      927: 2259:void CheckOther::checkRedundantCopy()
        -: 2260:{
      927: 2261:    if (!mSettings->isEnabled(Settings::PERFORMANCE) || mTokenizer->isC() || !mSettings->inconclusive)
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 98% (fallthrough)
branch  5 taken 2%
branch  6 taken 11% (fallthrough)
branch  7 taken 89%
branch  8 taken 13% (fallthrough)
branch  9 taken 87%
      123: 2262:        return;
        -: 2263:
      804: 2264:    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
call    0 returned 100%
        -: 2265:
     2992: 2266:    for (const Variable* var : symbolDatabase->variableList()) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 73% (fallthrough)
branch  5 taken 27%
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 returned 100%
call   10 never executed
call   11 never executed
     2188: 2267:        if (!var || var->isReference() || !var->isConst() || var->isPointer() || (!var->type() && !var->isStlType())) // bailout if var is of standard type, if it is a pointer or non-const
branch  0 taken 61% (fallthrough)
branch  1 taken 39%
call    2 returned 100%
branch  3 taken 92% (fallthrough)
branch  4 taken 8%
call    5 returned 100%
branch  6 taken 6% (fallthrough)
branch  7 taken 94%
call    8 returned 100%
branch  9 taken 99% (fallthrough)
branch 10 taken 1%
call   11 returned 100%
branch 12 taken 75% (fallthrough)
branch 13 taken 25%
call   14 returned 100%
branch 15 taken 65% (fallthrough)
branch 16 taken 35%
branch 17 taken 98% (fallthrough)
branch 18 taken 2%
     2151: 2268:            continue;
        -: 2269:
       37: 2270:        const Token* startTok = var->nameToken();
call    0 returned 100%
       37: 2271:        if (startTok->strAt(1) == "=") // %type% %name% = ... ;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 84% (fallthrough)
branch  5 taken 16%
        -: 2272:            ;
       59: 2273:        else if (startTok->strAt(1) == "(" && var->isClass() && var->typeScope()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 10% (fallthrough)
branch  5 taken 90%
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0%
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0%
branch 12 taken 10% (fallthrough)
branch 13 taken 90%
        -: 2274:            // Object is instantiated. Warn if constructor takes arguments by value.
        3: 2275:            if (constructorTakesReference(var->typeScope()))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
branch  4 taken 33% (fallthrough)
branch  5 taken 67%
        1: 2276:                continue;
        -: 2277:        } else
       28: 2278:            continue;
        -: 2279:
        8: 2280:        const Token* tok = startTok->next()->astOperand2();
call    0 returned 100%
call    1 returned 100%
        8: 2281:        if (!tok)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2282:            continue;
        8: 2283:        if (!Token::Match(tok->previous(), "%name% ("))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
branch  4 taken 38% (fallthrough)
branch  5 taken 63%
        3: 2284:            continue;
        5: 2285:        if (!Token::Match(tok->link(), ") )| ;")) // bailout for usage like "const A a = getA()+3"
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
    #####: 2286:            continue;
        -: 2287:
        5: 2288:        const Function* func = tok->previous()->function();
call    0 returned 100%
call    1 returned 100%
        5: 2289:        if (func && func->tokenDef->strAt(-1) == "&") {
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0%
branch  8 taken 80% (fallthrough)
branch  9 taken 20%
        4: 2290:            redundantCopyError(startTok, startTok->str());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
        -: 2291:        }
        -: 2292:    }
        -: 2293:}
function _ZN10CheckOther18redundantCopyErrorEPK5TokenRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 4 returned 100% blocks executed 58%
        4: 2294:void CheckOther::redundantCopyError(const Token *tok,const std::string& varname)
        -: 2295:{
        8: 2296:    reportError(tok, Severity::performance, "redundantCopyLocalConst",
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        8: 2297:                "$symbol:" + varname + "\n"
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
call    5 returned 100%
call    6 never executed
call    7 never executed
        -: 2298:                "Use const reference for '$symbol' to avoid unnecessary data copying.\n"
        -: 2299:                "The const variable '$symbol' is assigned a copy of the data. You can avoid "
        -: 2300:                "the unnecessary data copying by converting '$symbol' to const reference.",
        -: 2301:                CWE398,
        -: 2302:                true); // since #5618 that check became inconclusive
        4: 2303:}
        -: 2304:
        -: 2305://---------------------------------------------------------------------------
        -: 2306:// Checking for shift by negative values
        -: 2307://---------------------------------------------------------------------------
        -: 2308:
function _ZL10isNegativePK5TokenPK8Settings called 24 returned 100% blocks executed 100%
       24: 2309:static bool isNegative(const Token *tok, const Settings *settings)
        -: 2310:{
       24: 2311:    return tok->valueType() && tok->valueType()->sign == ValueType::SIGNED && tok->getValueLE(-1LL, settings);
call    0 returned 100%
branch  1 taken 96% (fallthrough)
branch  2 taken 4%
call    3 returned 100%
branch  4 taken 91% (fallthrough)
branch  5 taken 9%
call    6 returned 100%
branch  7 taken 48% (fallthrough)
branch  8 taken 52%
        -: 2312:}
        -: 2313:
function _ZN10CheckOther25checkNegativeBitwiseShiftEv called 927 returned 100% blocks executed 100%
      927: 2314:void CheckOther::checkNegativeBitwiseShift()
        -: 2315:{
      927: 2316:    const bool portability = mSettings->isEnabled(Settings::PORTABILITY);
call    0 returned 100%
        -: 2317:
    29119: 2318:    for (const Token* tok = mTokenizer->tokens(); tok; tok = tok->next()) {
call    0 returned 100%
branch  1 taken 97% (fallthrough)
branch  2 taken 3%
call    3 returned 100%
    28192: 2319:        if (!tok->astOperand1() || !tok->astOperand2())
call    0 returned 100%
branch  1 taken 23% (fallthrough)
branch  2 taken 77%
call    3 returned 100%
branch  4 taken 28% (fallthrough)
branch  5 taken 72%
branch  6 taken 84% (fallthrough)
branch  7 taken 16%
    23595: 2320:            continue;
        -: 2321:
     4597: 2322:        if (!Token::Match(tok, "<<|>>|<<=|>>="))
call    0 returned 100%
branch  1 taken 99% (fallthrough)
branch  2 taken 1%
     4542: 2323:            continue;
        -: 2324:
        -: 2325:        // don't warn if lhs is a class. this is an overloaded operator then
       55: 2326:        if (mTokenizer->isCPP()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
       55: 2327:            const ValueType * lhsType = tok->astOperand1()->valueType();
call    0 returned 100%
call    1 returned 100%
       55: 2328:            if (!lhsType || !lhsType->isIntegral())
branch  0 taken 27% (fallthrough)
branch  1 taken 73%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
branch  5 taken 73% (fallthrough)
branch  6 taken 27%
       40: 2329:                continue;
        -: 2330:        }
        -: 2331:
        -: 2332:        // bailout if operation is protected by ?:
       15: 2333:        bool ternary = false;
       43: 2334:        for (const Token *parent = tok; parent; parent = parent->astParent()) {
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
call    2 returned 100%
       29: 2335:            if (Token::Match(parent, "?|:")) {
call    0 returned 100%
branch  1 taken 3% (fallthrough)
branch  2 taken 97%
        1: 2336:                ternary = true;
        1: 2337:                break;
        -: 2338:            }
        -: 2339:        }
       15: 2340:        if (ternary)
branch  0 taken 7% (fallthrough)
branch  1 taken 93%
        1: 2341:            continue;
        -: 2342:
        -: 2343:        // Get negative rhs value. preferably a value which doesn't have 'condition'.
       14: 2344:        if (portability && isNegative(tok->astOperand1(), mSettings))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 29% (fallthrough)
branch  5 taken 71%
branch  6 taken 29% (fallthrough)
branch  7 taken 71%
        4: 2345:            negativeBitwiseShiftError(tok, 1);
call    0 returned 100%
       10: 2346:        else if (isNegative(tok->astOperand2(), mSettings))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 60% (fallthrough)
branch  3 taken 40%
        6: 2347:            negativeBitwiseShiftError(tok, 2);
call    0 returned 100%
        -: 2348:    }
      927: 2349:}
        -: 2350:
        -: 2351:
function _ZN10CheckOther25negativeBitwiseShiftErrorEPK5Tokeni called 10 returned 100% blocks executed 100%
       10: 2352:void CheckOther::negativeBitwiseShiftError(const Token *tok, int op)
        -: 2353:{
       10: 2354:    if (op == 1)
branch  0 taken 40% (fallthrough)
branch  1 taken 60%
        -: 2355:        // LHS - this is used by intention in various software, if it
        -: 2356:        // is used often in a project and works as expected then this is
        -: 2357:        // a portability issue
        4: 2358:        reportError(tok, Severity::portability, "shiftNegativeLHS", "Shifting a negative value is technically undefined behaviour", CWE758, false);
call    0 returned 100%
        -: 2359:    else // RHS
        6: 2360:        reportError(tok, Severity::error, "shiftNegative", "Shifting by a negative value is undefined behaviour", CWE758, false);
call    0 returned 100%
       10: 2361:}
        -: 2362:
        -: 2363://---------------------------------------------------------------------------
        -: 2364:// Check for incompletely filled buffers.
        -: 2365://---------------------------------------------------------------------------
function _ZN10CheckOther24checkIncompleteArrayFillEv called 927 returned 100% blocks executed 91%
      927: 2366:void CheckOther::checkIncompleteArrayFill()
        -: 2367:{
      927: 2368:    if (!mSettings->inconclusive)
branch  0 taken 11% (fallthrough)
branch  1 taken 89%
      101: 2369:        return;
      826: 2370:    const bool printWarning = mSettings->isEnabled(Settings::WARNING);
call    0 returned 100%
      826: 2371:    const bool printPortability = mSettings->isEnabled(Settings::PORTABILITY);
call    0 returned 100%
      826: 2372:    if (!printPortability && !printWarning)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
    #####: 2373:        return;
        -: 2374:
      826: 2375:    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
call    0 returned 100%
        -: 2376:
     1696: 2377:    for (const Scope * scope : symbolDatabase->functionScopes) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 51% (fallthrough)
branch  4 taken 49%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
    15629: 2378:        for (const Token* tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
call    0 returned 100%
branch  1 taken 94% (fallthrough)
branch  2 taken 6%
call    3 returned 100%
    14759: 2379:            if (Token::Match(tok, "memset|memcpy|memmove ( %var% ,") && Token::Match(tok->linkAt(1)->tokAt(-2), ", %num% )")) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 1% (fallthrough)
branch  4 taken 99%
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0% (throw)
call    8 returned 100%
branch  9 taken 100% (fallthrough)
branch 10 taken 0% (throw)
call   11 returned 100%
branch 12 taken 100% (fallthrough)
branch 13 taken 0% (throw)
branch 14 taken 100% (fallthrough)
branch 15 taken 0%
branch 16 taken 1% (fallthrough)
branch 17 taken 99%
        8: 2380:                const Variable *var = tok->tokAt(2)->variable();
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
        8: 2381:                if (!var || !var->isArray() || var->dimensions().empty() || !var->dimension(0))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 returned 100%
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0%
call    9 returned 100%
branch 10 taken 0% (fallthrough)
branch 11 taken 100%
branch 12 taken 0% (fallthrough)
branch 13 taken 100%
    #####: 2382:                    continue;
        -: 2383:
        8: 2384:                if (MathLib::toLongNumber(tok->linkAt(1)->strAt(-1)) == var->dimension(0)) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0%
        8: 2385:                    int size = mTokenizer->sizeOfType(var->typeStartToken());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
        8: 2386:                    if (size == 0 && var->valueType()->pointer)
branch  0 taken 38% (fallthrough)
branch  1 taken 63%
call    2 returned 100%
branch  3 taken 33% (fallthrough)
branch  4 taken 67%
branch  5 taken 13% (fallthrough)
branch  6 taken 88%
        1: 2387:                        size = mSettings->sizeof_pointer;
        8: 2388:                    if ((size != 1 && size != 100 && size != 0) || var->isPointer()) {
branch  0 taken 75% (fallthrough)
branch  1 taken 25%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 33% (fallthrough)
branch  5 taken 67%
call    6 returned 100%
branch  7 taken 0% (fallthrough)
branch  8 taken 100%
branch  9 taken 50% (fallthrough)
branch 10 taken 50%
        4: 2389:                        if (printWarning)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        4: 2390:                            incompleteArrayFillError(tok, var->name(), tok->str(), false);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
        4: 2391:                    } else if (var->valueType()->type == ValueType::Type::BOOL && printPortability) // sizeof(bool) is not 1 on all platforms
call    0 returned 100%
branch  1 taken 25% (fallthrough)
branch  2 taken 75%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 25% (fallthrough)
branch  6 taken 75%
        1: 2392:                        incompleteArrayFillError(tok, var->name(), tok->str(), true);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
        -: 2393:                }
        -: 2394:            }
        -: 2395:        }
        -: 2396:    }
        -: 2397:}
        -: 2398:
function _ZN10CheckOther24incompleteArrayFillErrorEPK5TokenRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESA_b called 5 returned 100% blocks executed 43%
        5: 2399:void CheckOther::incompleteArrayFillError(const Token* tok, const std::string& buffer, const std::string& function, bool boolean)
        -: 2400:{
        5: 2401:    if (boolean)
branch  0 taken 20% (fallthrough)
branch  1 taken 80%
        2: 2402:        reportError(tok, Severity::portability, "incompleteArrayFill",
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        2: 2403:                    "$symbol:" + buffer + "\n"
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
call    5 returned 100%
call    6 never executed
call    7 never executed
call    8 never executed
        2: 2404:                    "$symbol:" + function + "\n"
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 returned 100%
call    8 never executed
call    9 never executed
        2: 2405:                    "Array '" + buffer + "' might be filled incompletely. Did you forget to multiply the size given to '" + function + "()' with 'sizeof(*" + buffer + ")'?\n"
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
branch 13 taken 100% (fallthrough)
branch 14 taken 0% (throw)
call   15 returned 100%
branch 16 taken 100% (fallthrough)
branch 17 taken 0% (throw)
call   18 returned 100%
call   19 returned 100%
call   20 returned 100%
call   21 returned 100%
call   22 returned 100%
call   23 returned 100%
call   24 never executed
call   25 never executed
call   26 never executed
call   27 never executed
call   28 never executed
call   29 never executed
        2: 2406:                    "The array '" + buffer + "' is filled incompletely. The function '" + function + "()' needs the size given in bytes, but the type 'bool' is larger than 1 on some platforms. Did you forget to multiply the size with 'sizeof(*" + buffer + ")'?", CWE131, true);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
branch 13 taken 100% (fallthrough)
branch 14 taken 0% (throw)
call   15 returned 100%
branch 16 taken 100% (fallthrough)
branch 17 taken 0% (throw)
call   18 returned 100%
call   19 returned 100%
call   20 returned 100%
call   21 returned 100%
call   22 returned 100%
call   23 returned 100%
call   24 never executed
call   25 never executed
call   26 never executed
call   27 never executed
call   28 never executed
call   29 never executed
        -: 2407:    else
        8: 2408:        reportError(tok, Severity::warning, "incompleteArrayFill",
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        8: 2409:                    "$symbol:" + buffer + "\n"
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
call    5 returned 100%
call    6 never executed
call    7 never executed
        8: 2410:                    "$symbol:" + function + "\n"
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 returned 100%
call    8 never executed
call    9 never executed
        8: 2411:                    "Array '" + buffer + "' is filled incompletely. Did you forget to multiply the size given to '" + function + "()' with 'sizeof(*" + buffer + ")'?\n"
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
branch 13 taken 100% (fallthrough)
branch 14 taken 0% (throw)
call   15 returned 100%
branch 16 taken 100% (fallthrough)
branch 17 taken 0% (throw)
call   18 returned 100%
call   19 returned 100%
call   20 returned 100%
call   21 returned 100%
call   22 returned 100%
call   23 returned 100%
call   24 never executed
call   25 never executed
call   26 never executed
call   27 never executed
call   28 never executed
call   29 never executed
        8: 2412:                    "The array '" + buffer + "' is filled incompletely. The function '" + function + "()' needs the size given in bytes, but an element of the given array is larger than one byte. Did you forget to multiply the size with 'sizeof(*" + buffer + ")'?", CWE131, true);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
branch 13 taken 100% (fallthrough)
branch 14 taken 0% (throw)
call   15 returned 100%
branch 16 taken 100% (fallthrough)
branch 17 taken 0% (throw)
call   18 returned 100%
call   19 returned 100%
call   20 returned 100%
call   21 returned 100%
call   22 returned 100%
call   23 returned 100%
call   24 never executed
call   25 never executed
call   26 never executed
call   27 never executed
call   28 never executed
call   29 never executed
        5: 2413:}
        -: 2414:
        -: 2415://---------------------------------------------------------------------------
        -: 2416:// Detect NULL being passed to variadic function.
        -: 2417://---------------------------------------------------------------------------
        -: 2418:
function _ZN10CheckOther18checkVarFuncNullUBEv called 927 returned 100% blocks executed 73%
      927: 2419:void CheckOther::checkVarFuncNullUB()
        -: 2420:{
      927: 2421:    if (!mSettings->isEnabled(Settings::PORTABILITY))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2422:        return;
        -: 2423:
      927: 2424:    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
call    0 returned 100%
     1908: 2425:    for (const Scope * scope : symbolDatabase->functionScopes) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 51% (fallthrough)
branch  4 taken 49%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
    18796: 2426:        for (const Token* tok = scope->bodyStart; tok != scope->bodyEnd; tok = tok->next()) {
branch  0 taken 95% (fallthrough)
branch  1 taken 5%
call    2 returned 100%
        -: 2427:            // Is NULL passed to a function?
    17815: 2428:            if (Token::Match(tok,"[(,] NULL [,)]")) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 1% (fallthrough)
branch  4 taken 99%
        -: 2429:                // Locate function name in this function call.
        3: 2430:                const Token *ftok = tok;
        3: 2431:                int argnr = 1;
        3: 2432:                while (ftok && ftok->str() != "(") {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
    #####: 2433:                    if (ftok->str() == ")")
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2434:                        ftok = ftok->link();
call    0 never executed
    #####: 2435:                    else if (ftok->str() == ",")
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2436:                        ++argnr;
    #####: 2437:                    ftok = ftok->previous();
call    0 never executed
        -: 2438:                }
        3: 2439:                ftok = ftok ? ftok->previous() : nullptr;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
        3: 2440:                if (ftok && ftok->isName()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
branch  5 taken 100% (fallthrough)
branch  6 taken 0%
branch  7 taken 100% (fallthrough)
branch  8 taken 0%
        -: 2441:                    // If this is a variadic function then report error
        3: 2442:                    const Function *f = ftok->function();
call    0 returned 100%
        3: 2443:                    if (f && f->argCount() <= argnr) {
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
call    2 returned 100%
branch  3 taken 50% (fallthrough)
branch  4 taken 50%
branch  5 taken 33% (fallthrough)
branch  6 taken 67%
        1: 2444:                        const Token *tok2 = f->argDef;
        1: 2445:                        tok2 = tok2 ? tok2->link() : nullptr; // goto ')'
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
        1: 2446:                        if (tok2 && Token::simpleMatch(tok2->tokAt(-1), "..."))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0% (throw)
branch  8 taken 100% (fallthrough)
branch  9 taken 0%
branch 10 taken 100% (fallthrough)
branch 11 taken 0%
        1: 2447:                            varFuncNullUBError(tok);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -: 2448:                    }
        -: 2449:                }
        -: 2450:            }
        -: 2451:        }
        -: 2452:    }
        -: 2453:}
        -: 2454:
function _ZN10CheckOther18varFuncNullUBErrorEPK5Token called 1 returned 100% blocks executed 100%
        1: 2455:void CheckOther::varFuncNullUBError(const Token *tok)
        -: 2456:{
        1: 2457:    reportError(tok,
call    0 returned 100%
        -: 2458:                Severity::portability,
        -: 2459:                "varFuncNullUB",
        -: 2460:                "Passing NULL after the last typed argument to a variadic function leads to undefined behaviour.\n"
        -: 2461:                "Passing NULL after the last typed argument to a variadic function leads to undefined behaviour.\n"
        -: 2462:                "The C99 standard, in section 7.15.1.1, states that if the type used by va_arg() is not compatible with the type of the actual next argument (as promoted according to the default argument promotions), the behavior is undefined.\n"
        -: 2463:                "The value of the NULL macro is an implementation-defined null pointer constant (7.17), which can be any integer constant expression with the value 0, or such an expression casted to (void*) (6.3.2.3). This includes values like 0, 0L, or even 0LL.\n"
        -: 2464:                "In practice on common architectures, this will cause real crashes if sizeof(int) != sizeof(void*), and NULL is defined to 0 or any other null pointer constant that promotes to int.\n"
        -: 2465:                "To reproduce you might be able to use this little code example on 64bit platforms. If the output includes \"ERROR\", the sentinel had only 4 out of 8 bytes initialized to zero and was not detected as the final argument to stop argument processing via va_arg(). Changing the 0 to (void*)0 or 0L will make the \"ERROR\" output go away.\n"
        -: 2466:                "#include <stdarg.h>\n"
        -: 2467:                "#include <stdio.h>\n"
        -: 2468:                "\n"
        -: 2469:                "void f(char *s, ...) {\n"
        -: 2470:                "    va_list ap;\n"
        -: 2471:                "    va_start(ap,s);\n"
        -: 2472:                "    for (;;) {\n"
        -: 2473:                "        char *p = va_arg(ap,char*);\n"
        -: 2474:                "        printf(\"%018p, %s\\n\", p, (long)p & 255 ? p : \"\");\n"
        -: 2475:                "        if(!p) break;\n"
        -: 2476:                "    }\n"
        -: 2477:                "    va_end(ap);\n"
        -: 2478:                "}\n"
        -: 2479:                "\n"
        -: 2480:                "void g() {\n"
        -: 2481:                "    char *s2 = \"x\";\n"
        -: 2482:                "    char *s3 = \"ERROR\";\n"
        -: 2483:                "\n"
        -: 2484:                "    // changing 0 to 0L for the 7th argument (which is intended to act as sentinel) makes the error go away on x86_64\n"
        -: 2485:                "    f(\"first\", s2, s2, s2, s2, s2, 0, s3, (char*)0);\n"
        -: 2486:                "}\n"
        -: 2487:                "\n"
        -: 2488:                "void h() {\n"
        -: 2489:                "    int i;\n"
        -: 2490:                "    volatile unsigned char a[1000];\n"
        -: 2491:                "    for (i = 0; i<sizeof(a); i++)\n"
        -: 2492:                "        a[i] = -1;\n"
        -: 2493:                "}\n"
        -: 2494:                "\n"
        -: 2495:                "int main() {\n"
        -: 2496:                "    h();\n"
        -: 2497:                "    g();\n"
        -: 2498:                "    return 0;\n"
        -: 2499:                "}", CWE475, false);
        1: 2500:}
        -: 2501:
function _ZN10CheckOther23checkRedundantPointerOpEv called 927 returned 100% blocks executed 68%
      927: 2502:void CheckOther::checkRedundantPointerOp()
        -: 2503:{
      927: 2504:    if (!mSettings->isEnabled(Settings::STYLE))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2505:        return;
        -: 2506:
    29119: 2507:    for (const Token *tok = mTokenizer->tokens(); tok; tok = tok->next()) {
call    0 returned 100%
branch  1 taken 97% (fallthrough)
branch  2 taken 3%
call    3 returned 100%
    28192: 2508:        if (!tok->isUnaryOp("&") || !tok->astOperand1()->isUnaryOp("*"))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
branch  7 taken 1% (fallthrough)
branch  8 taken 99%
call    9 returned 100%
call   10 returned 100%
call   11 returned 100%
branch 12 taken 100% (fallthrough)
branch 13 taken 0% (throw)
call   14 returned 100%
branch 15 taken 100% (fallthrough)
branch 16 taken 0% (throw)
branch 17 taken 95% (fallthrough)
branch 18 taken 5%
branch 19 taken 1% (fallthrough)
branch 20 taken 99%
call   21 returned 100%
branch 22 taken 1% (fallthrough)
branch 23 taken 99%
call   24 returned 100%
branch 25 taken 100% (fallthrough)
branch 26 taken 0%
call   27 returned 100%
branch 28 taken 100% (fallthrough)
branch 29 taken 0%
call   30 returned 100%
branch 31 taken 99% (fallthrough)
branch 32 taken 1%
branch 33 never executed
branch 34 never executed
call   35 never executed
branch 36 never executed
branch 37 never executed
call   38 never executed
branch 39 never executed
branch 40 never executed
call   41 never executed
branch 42 never executed
branch 43 never executed
call   44 never executed
    28188: 2509:            continue;
        -: 2510:
        -: 2511:        // variable
        4: 2512:        const Token *varTok = tok->astOperand1()->astOperand1();
call    0 returned 100%
call    1 returned 100%
        4: 2513:        if (!varTok || varTok->isExpandedMacro())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
    #####: 2514:            continue;
        -: 2515:
        4: 2516:        const Variable *var = varTok->variable();
call    0 returned 100%
        4: 2517:        if (!var || !var->isPointer())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
    #####: 2518:            continue;
        -: 2519:
        4: 2520:        redundantPointerOpError(tok, var->name(), false);
call    0 returned 100%
call    1 returned 100%
        -: 2521:    }
        -: 2522:}
        -: 2523:
function _ZN10CheckOther23redundantPointerOpErrorEPK5TokenRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEb called 4 returned 100% blocks executed 58%
        4: 2524:void CheckOther::redundantPointerOpError(const Token* tok, const std::string &varname, bool inconclusive)
        -: 2525:{
        8: 2526:    reportError(tok, Severity::style, "redundantPointerOp",
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        8: 2527:                "$symbol:" + varname + "\n"
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
call    5 returned 100%
call    6 never executed
call    7 never executed
        -: 2528:                "Redundant pointer operation on '$symbol' - it's already a pointer.", CWE398, inconclusive);
        4: 2529:}
        -: 2530:
function _ZN10CheckOther25checkInterlockedDecrementEv called 927 returned 100% blocks executed 99%
      927: 2531:void CheckOther::checkInterlockedDecrement()
        -: 2532:{
      927: 2533:    if (!mSettings->isWindowsPlatform()) {
call    0 returned 100%
branch  1 taken 97% (fallthrough)
branch  2 taken 3%
      899: 2534:        return;
        -: 2535:    }
        -: 2536:
      968: 2537:    for (const Token *tok = mTokenizer->tokens(); tok; tok = tok->next()) {
call    0 returned 100%
branch  1 taken 97% (fallthrough)
branch  2 taken 3%
call    3 returned 100%
      940: 2538:        if (tok->isName() && Token::Match(tok, "InterlockedDecrement ( & %name% ) ; if ( %name%|!|0")) {
call    0 returned 100%
branch  1 taken 35% (fallthrough)
branch  2 taken 65%
call    3 returned 100%
branch  4 taken 6% (fallthrough)
branch  5 taken 94%
branch  6 taken 2% (fallthrough)
branch  7 taken 98%
       20: 2539:            const Token* interlockedVarTok = tok->tokAt(3);
call    0 returned 100%
       20: 2540:            const Token* checkStartTok =  interlockedVarTok->tokAt(5);
call    0 returned 100%
       64: 2541:            if ((Token::Match(checkStartTok, "0 %comp% %name% )") && checkStartTok->strAt(2) == interlockedVarTok->str()) ||
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 50% (fallthrough)
branch  5 taken 50%
branch  6 taken 13% (fallthrough)
branch  7 taken 88%
branch  8 taken 50% (fallthrough)
branch  9 taken 50%
       33: 2542:                (Token::Match(checkStartTok, "! %name% )") && checkStartTok->strAt(1) == interlockedVarTok->str()) ||
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 50% (fallthrough)
branch  5 taken 50%
branch  6 taken 13% (fallthrough)
branch  7 taken 87%
       61: 2543:                (Token::Match(checkStartTok, "%name% )") && checkStartTok->str() == interlockedVarTok->str()) ||
branch  0 taken 40% (fallthrough)
branch  1 taken 60%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
branch  6 taken 50% (fallthrough)
branch  7 taken 50%
branch  8 taken 57% (fallthrough)
branch  9 taken 43%
       22: 2544:                (Token::Match(checkStartTok, "%name% %comp% 0 )") && checkStartTok->str() == interlockedVarTok->str())) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 50% (fallthrough)
branch  5 taken 50%
       10: 2545:                raceAfterInterlockedDecrementError(checkStartTok);
call    0 returned 100%
        -: 2546:            }
      920: 2547:        } else if (Token::Match(tok, "if ( ::| InterlockedDecrement ( & %name%")) {
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 99%
        6: 2548:            const Token* condEnd = tok->next()->link();
call    0 returned 100%
call    1 returned 100%
        6: 2549:            const Token* funcTok = tok->tokAt(2);
call    0 returned 100%
        6: 2550:            const Token* firstAccessTok = funcTok->str() == "::" ? funcTok->tokAt(4) : funcTok->tokAt(3);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 50% (fallthrough)
branch  3 taken 50%
call    4 returned 100%
call    5 returned 100%
        6: 2551:            if (condEnd && condEnd->next() && condEnd->next()->link()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 returned 100%
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0%
branch  9 taken 100% (fallthrough)
branch 10 taken 0%
        6: 2552:                const Token* ifEndTok = condEnd->next()->link();
call    0 returned 100%
call    1 returned 100%
        6: 2553:                if (Token::Match(ifEndTok, "} return %name%")) {
call    0 returned 100%
branch  1 taken 33% (fallthrough)
branch  2 taken 67%
        2: 2554:                    const Token* secondAccessTok = ifEndTok->tokAt(2);
call    0 returned 100%
        2: 2555:                    if (secondAccessTok->str() == firstAccessTok->str()) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
        2: 2556:                        raceAfterInterlockedDecrementError(secondAccessTok);
call    0 returned 100%
        -: 2557:                    }
        4: 2558:                } else if (Token::Match(ifEndTok, "} else { return %name%")) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        4: 2559:                    const Token* secondAccessTok = ifEndTok->tokAt(4);
call    0 returned 100%
        4: 2560:                    if (secondAccessTok->str() == firstAccessTok->str()) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
        4: 2561:                        raceAfterInterlockedDecrementError(secondAccessTok);
call    0 returned 100%
        -: 2562:                    }
        -: 2563:                }
        -: 2564:            }
        -: 2565:        }
        -: 2566:    }
        -: 2567:}
        -: 2568:
function _ZN10CheckOther34raceAfterInterlockedDecrementErrorEPK5Token called 16 returned 100% blocks executed 100%
       16: 2569:void CheckOther::raceAfterInterlockedDecrementError(const Token* tok)
        -: 2570:{
       16: 2571:    reportError(tok, Severity::error, "raceAfterInterlockedDecrement",
call    0 returned 100%
        -: 2572:                "Race condition: non-interlocked access after InterlockedDecrement(). Use InterlockedDecrement() return value instead.", CWE362, false);
       16: 2573:}
        -: 2574:
function _ZN10CheckOther16checkUnusedLabelEv called 927 returned 100% blocks executed 80%
      927: 2575:void CheckOther::checkUnusedLabel()
        -: 2576:{
      927: 2577:    if (!mSettings->isEnabled(Settings::STYLE) && !mSettings->isEnabled(Settings::WARNING))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
    #####: 2578:        return;
        -: 2579:
      927: 2580:    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
call    0 returned 100%
     1908: 2581:    for (const Scope * scope : symbolDatabase->functionScopes) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 51% (fallthrough)
branch  4 taken 49%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
    18731: 2582:        for (const Token* tok = scope->bodyStart; tok != scope->bodyEnd; tok = tok->next()) {
branch  0 taken 95% (fallthrough)
branch  1 taken 5%
call    2 returned 100%
    17750: 2583:            if (!tok->scope()->isExecutable())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 1% (fallthrough)
branch  3 taken 99%
       11: 2584:                tok = tok->scope()->bodyEnd;
call    0 returned 100%
        -: 2585:
    17750: 2586:            if (Token::Match(tok, "{|}|; %name% :") && tok->strAt(1) != "default") {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 1% (fallthrough)
branch  4 taken 99%
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0% (throw)
call    8 returned 100%
branch  9 taken 60% (fallthrough)
branch 10 taken 40%
branch 11 taken 1% (fallthrough)
branch 12 taken 99%
       12: 2587:                if (!Token::findsimplematch(scope->bodyStart->next(), ("goto " + tok->strAt(1)).c_str(), scope->bodyEnd->previous()))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 returned 100%
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
branch 13 taken 50% (fallthrough)
branch 14 taken 50%
call   15 never executed
        6: 2588:                    unusedLabelError(tok->next(), tok->next()->scope()->type == Scope::eSwitch);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        -: 2589:            }
        -: 2590:        }
        -: 2591:    }
        -: 2592:}
        -: 2593:
function _ZN10CheckOther16unusedLabelErrorEPK5Tokenb called 6 returned 100% blocks executed 66%
        6: 2594:void CheckOther::unusedLabelError(const Token* tok, bool inSwitch)
        -: 2595:{
        6: 2596:    if (inSwitch) {
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
        2: 2597:        if (!tok || mSettings->isEnabled(Settings::WARNING))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 100% (fallthrough)
branch  6 taken 0%
        4: 2598:            reportError(tok, Severity::warning, "unusedLabelSwitch",
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        4: 2599:                        "$symbol:" + (tok ? tok->str() : emptyString) + "\n"
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
call   11 never executed
        -: 2600:                        "Label '$symbol' is not used. Should this be a 'case' of the enclosing switch()?", CWE398, false);
        -: 2601:    } else {
        4: 2602:        if (!tok || mSettings->isEnabled(Settings::STYLE))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 100% (fallthrough)
branch  6 taken 0%
        8: 2603:            reportError(tok, Severity::style, "unusedLabel",
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        8: 2604:                        "$symbol:" + (tok ? tok->str() : emptyString) + "\n"
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
        -: 2605:                        "Label '$symbol' is not used.", CWE398, false);
        -: 2606:    }
        6: 2607:}
        -: 2608:
        -: 2609:
function _ZN10CheckOther20checkEvaluationOrderEv called 927 returned 100% blocks executed 89%
      927: 2610:void CheckOther::checkEvaluationOrder()
        -: 2611:{
        -: 2612:    // This checker is not written according to C++11 sequencing rules
      927: 2613:    if (mTokenizer->isCPP() && mSettings->standards.cpp >= Standards::CPP11)
call    0 returned 100%
branch  1 taken 98% (fallthrough)
branch  2 taken 2%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 98% (fallthrough)
branch  6 taken 2%
      905: 2614:        return;
        -: 2615:
       22: 2616:    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
call    0 returned 100%
       44: 2617:    for (const Scope * functionScope : symbolDatabase->functionScopes) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 50% (fallthrough)
branch  4 taken 50%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
      422: 2618:        for (const Token* tok = functionScope->bodyStart; tok != functionScope->bodyEnd; tok = tok->next()) {
branch  0 taken 95% (fallthrough)
branch  1 taken 5%
call    2 returned 100%
      400: 2619:            if (!Token::Match(tok, "++|--") && !tok->isAssignmentOp())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 97% (fallthrough)
branch  4 taken 3%
call    5 returned 100%
branch  6 taken 95% (fallthrough)
branch  7 taken 5%
branch  8 taken 92% (fallthrough)
branch  9 taken 8%
      367: 2620:                continue;
       33: 2621:            if (!tok->astOperand1())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2622:                continue;
       40: 2623:            for (const Token *tok2 = tok;; tok2 = tok2->astParent()) {
call    0 returned 100%
        -: 2624:                // If ast parent is a sequence point then break
       40: 2625:                const Token * const parent = tok2->astParent();
call    0 returned 100%
       40: 2626:                if (!parent)
branch  0 taken 40% (fallthrough)
branch  1 taken 60%
       49: 2627:                    break;
       24: 2628:                if (Token::Match(parent, "%oror%|&&|?|:|;"))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####: 2629:                    break;
       24: 2630:                if (parent->str() == ",") {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 50% (fallthrough)
branch  3 taken 50%
       12: 2631:                    const Token *par = parent;
       46: 2632:                    while (Token::simpleMatch(par,","))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 59% (fallthrough)
branch  4 taken 41%
       17: 2633:                        par = par->astParent();
call    0 returned 100%
        -: 2634:                    // not function or in a while clause => break
       12: 2635:                    if (!(par && par->str() == "(" && par->astOperand2() && par->strAt(-1) != "while"))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
call    6 returned 100%
branch  7 taken 92% (fallthrough)
branch  8 taken 8%
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
branch 13 taken 36% (fallthrough)
branch 14 taken 64%
branch 15 taken 42% (fallthrough)
branch 16 taken 58%
        5: 2636:                        break;
        -: 2637:                    // control flow (if|while|etc) => break
        7: 2638:                    if (Token::simpleMatch(par->link(),") {"))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
    #####: 2639:                        break;
        -: 2640:                    // sequence point in function argument: dostuff((1,2),3) => break
        7: 2641:                    par = par->next();
call    0 returned 100%
       25: 2642:                    while (par && (par->previous() != parent))
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
call    2 returned 100%
branch  3 taken 60% (fallthrough)
branch  4 taken 40%
branch  5 taken 56% (fallthrough)
branch  6 taken 44%
        9: 2643:                        par = par->nextArgument();
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        7: 2644:                    if (!par)
branch  0 taken 14% (fallthrough)
branch  1 taken 86%
        1: 2645:                        break;
        -: 2646:                }
       18: 2647:                if (parent->str() == "(" && parent->astOperand2())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 22% (fallthrough)
branch  3 taken 78%
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0%
branch  7 taken 22% (fallthrough)
branch  8 taken 78%
        4: 2648:                    break;
        -: 2649:
        -: 2650:                // self assignment..
       39: 2651:                if (tok2 == tok &&
branch  0 taken 18% (fallthrough)
branch  1 taken 82%
branch  2 taken 7% (fallthrough)
branch  3 taken 93%
       13: 2652:                    tok->str() == "=" &&
call    0 returned 100%
call    1 returned 100%
branch  2 taken 50% (fallthrough)
branch  3 taken 50%
       17: 2653:                    parent->str() == "=" &&
branch  0 taken 79% (fallthrough)
branch  1 taken 21%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
        1: 2654:                    isSameExpression(mTokenizer->isCPP(), false, tok->astOperand1(), parent->astOperand1(), mSettings->library, true, false)) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        2: 2655:                    if (mSettings->isEnabled(Settings::WARNING) &&
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 100% (fallthrough)
branch  6 taken 0%
        1: 2656:                        isSameExpression(mTokenizer->isCPP(), true, tok->astOperand1(), parent->astOperand1(), mSettings->library, true, false))
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        1: 2657:                        selfAssignmentError(parent, tok->astOperand1()->expressionString());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 never executed
        1: 2658:                    break;
        -: 2659:                }
        -: 2660:
        -: 2661:                // Is expression used?
       13: 2662:                bool foundError = false;
       13: 2663:                visitAstNodes((parent->astOperand1() != tok2) ? parent->astOperand1() : parent->astOperand2(),
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 38% (fallthrough)
branch  5 taken 62%
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
branch  9 taken 100% (fallthrough)
branch 10 taken 0% (throw)
call   11 returned 100%
call   12 never executed
function _ZZN10CheckOther20checkEvaluationOrderEvENKUlPK5TokenE_clES2_ called 20 returned 100% blocks executed 100%
       20: 2664:                [&](const Token *tok3) {
       20: 2665:                    if (tok3->str() == "&" && !tok3->astOperand2())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 5% (fallthrough)
branch  3 taken 95%
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0%
branch  7 taken 5% (fallthrough)
branch  8 taken 95%
        1: 2666:                        return ChildrenToVisit::none; // don't handle address-of for now
       19: 2667:                    if (tok3->str() == "(" && Token::simpleMatch(tok3->previous(), "sizeof"))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 11% (fallthrough)
branch  3 taken 89%
call    4 returned 100%
call    5 returned 100%
branch  6 taken 50% (fallthrough)
branch  7 taken 50%
branch  8 taken 5% (fallthrough)
branch  9 taken 95%
        1: 2668:                        return ChildrenToVisit::none; // don't care about sizeof usage
       18: 2669:                    if (isSameExpression(mTokenizer->isCPP(), false, tok->astOperand1(), tok3, mSettings->library, true, false))
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 33% (fallthrough)
branch  4 taken 67%
        6: 2670:                        foundError = true;
       18: 2671:                    return foundError ? ChildrenToVisit::done : ChildrenToVisit::op1_and_op2;
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
        -: 2672:                });
        -: 2673:
       13: 2674:                if (foundError) {
branch  0 taken 46% (fallthrough)
branch  1 taken 54%
        6: 2675:                    unknownEvaluationOrder(parent);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        6: 2676:                    break;
        -: 2677:                }
        7: 2678:            }
        -: 2679:        }
        -: 2680:    }
        -: 2681:}
        -: 2682:
function _ZN10CheckOther22unknownEvaluationOrderEPK5Token called 6 returned 100% blocks executed 44%
        6: 2683:void CheckOther::unknownEvaluationOrder(const Token* tok)
        -: 2684:{
       12: 2685:    reportError(tok, Severity::error, "unknownEvaluationOrder",
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       12: 2686:                "Expression '" + (tok ? tok->expressionString() : std::string("x = x++;")) + "' depends on order of evaluation of side effects", CWE768, false);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
call    5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
branch 13 taken 100% (fallthrough)
branch 14 taken 0% (throw)
call   15 returned 100%
call   16 returned 100%
call   17 returned 100%
branch 18 taken 0% (fallthrough)
branch 19 taken 100%
call   20 never executed
call   21 never executed
call   22 never executed
call   23 never executed
branch 24 never executed
branch 25 never executed
call   26 never executed
        6: 2687:}
        -: 2688:
function _ZN10CheckOther26checkAccessOfMovedVariableEv called 927 returned 100% blocks executed 87%
      927: 2689:void CheckOther::checkAccessOfMovedVariable()
        -: 2690:{
      927: 2691:    if (!mTokenizer->isCPP() || mSettings->standards.cpp < Standards::CPP11 || !mSettings->isEnabled(Settings::WARNING))
call    0 returned 100%
branch  1 taken 98% (fallthrough)
branch  2 taken 2%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 returned 100%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
branch  8 taken 2% (fallthrough)
branch  9 taken 98%
       22: 2692:        return;
     1810: 2693:    CheckUninitVar checkUninitVar(mTokenizer, mSettings, mErrorLogger);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
call    4 never executed
      905: 2694:    const bool reportInconclusive = mSettings->inconclusive;
      905: 2695:    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
call    0 returned 100%
     1864: 2696:    for (const Scope * scope : symbolDatabase->functionScopes) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 51% (fallthrough)
branch  4 taken 49%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
      959: 2697:        const Token * scopeStart = scope->bodyStart;
      959: 2698:        if (scope->function) {
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
      955: 2699:            const Token * memberInitializationStart = scope->function->constructorMemberInitialization();
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
      955: 2700:            if (memberInitializationStart)
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
       12: 2701:                scopeStart = memberInitializationStart;
        -: 2702:        }
    17551: 2703:        for (const Token* tok = scopeStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
call    0 returned 100%
branch  1 taken 95% (fallthrough)
branch  2 taken 5%
call    3 returned 100%
    16592: 2704:            const ValueFlow::Value * movedValue = tok->getMovedValue();
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
    16592: 2705:            if (!movedValue || movedValue->moveKind == ValueFlow::Value::MoveKind::NonMovedVariable)
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    33142: 2706:                continue;
       21: 2707:            if (movedValue->isInconclusive() && !reportInconclusive)
call    0 returned 100%
branch  1 taken 5% (fallthrough)
branch  2 taken 95%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
    #####: 2708:                continue;
        -: 2709:
       21: 2710:            bool inconclusive = false;
       21: 2711:            bool accessOfMoved = false;
       21: 2712:            if (tok->strAt(1) == ".") {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 10% (fallthrough)
branch  5 taken 90%
        2: 2713:                if (tok->next()->originalName() == "->")
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
        2: 2714:                    accessOfMoved = true;
        -: 2715:                else
    #####: 2716:                    inconclusive = true;
        -: 2717:            } else {
       19: 2718:                const bool isVariableChanged = isVariableChangedByFunctionCall(tok, 0, mSettings, &inconclusive);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       19: 2719:                accessOfMoved = !isVariableChanged && checkUninitVar.isVariableUsage(tok, false, CheckUninitVar::NO_ALLOC);
branch  0 taken 95% (fallthrough)
branch  1 taken 5%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
branch  5 taken 89% (fallthrough)
branch  6 taken 11%
       19: 2720:                if (inconclusive) {
branch  0 taken 37% (fallthrough)
branch  1 taken 63%
        7: 2721:                    accessOfMoved = !isMovedParameterAllowedForInconclusiveFunction(tok);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        7: 2722:                    if (accessOfMoved)
branch  0 taken 86% (fallthrough)
branch  1 taken 14%
        6: 2723:                        inconclusive = false;
        -: 2724:                }
        -: 2725:            }
       21: 2726:            if (accessOfMoved || (inconclusive && reportInconclusive))
branch  0 taken 14% (fallthrough)
branch  1 taken 86%
branch  2 taken 33% (fallthrough)
branch  3 taken 67%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
       19: 2727:                accessMovedError(tok, tok->str(), movedValue, inconclusive || movedValue->isInconclusive());
branch  0 taken 95% (fallthrough)
branch  1 taken 5%
call    2 returned 100%
branch  3 taken 6% (fallthrough)
branch  4 taken 94%
call    5 returned 100%
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
        -: 2728:        }
        -: 2729:    }
        -: 2730:}
        -: 2731:
function _ZN10CheckOther46isMovedParameterAllowedForInconclusiveFunctionEPK5Token called 7 returned 100% blocks executed 55%
        7: 2732:bool CheckOther::isMovedParameterAllowedForInconclusiveFunction(const Token * tok)
        -: 2733:{
        7: 2734:    if (Token::simpleMatch(tok->tokAt(-4), "std :: move ("))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 86% (fallthrough)
branch  3 taken 14%
        6: 2735:        return false;
        1: 2736:    const Token * tokAtM2 = tok->tokAt(-2);
call    0 returned 100%
        1: 2737:    if (Token::simpleMatch(tokAtM2, "> (") && tokAtM2->link()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
    #####: 2738:        const Token * leftAngle = tokAtM2->link();
call    0 never executed
    #####: 2739:        if (Token::simpleMatch(leftAngle->tokAt(-3), "std :: forward <"))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2740:            return false;
        -: 2741:    }
        1: 2742:    return true;
        -: 2743:}
        -: 2744:
function _ZN10CheckOther16accessMovedErrorEPK5TokenRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEPKN9ValueFlow5ValueEb called 19 returned 100% blocks executed 54%
       19: 2745:void CheckOther::accessMovedError(const Token *tok, const std::string &varname, const ValueFlow::Value *value, bool inconclusive)
        -: 2746:{
       19: 2747:    if (!tok) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2748:        reportError(tok, Severity::warning, "accessMoved", "Access of moved variable 'v'.", CWE672, false);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2749:        reportError(tok, Severity::warning, "accessForwarded", "Access of forwarded variable 'v'.", CWE672, false);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2750:        return;
call    0 never executed
        -: 2751:    }
        -: 2752:
       19: 2753:    const char * errorId = nullptr;
       38: 2754:    std::string kindString;
call    0 returned 100%
call    1 never executed
       19: 2755:    switch (value->moveKind) {
branch  0 taken 95%
branch  1 taken 5%
branch  2 taken 0%
       18: 2756:    case ValueFlow::Value::MoveKind::MovedVariable:
       18: 2757:        errorId = "accessMoved";
       18: 2758:        kindString = "moved";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       18: 2759:        break;
        1: 2760:    case ValueFlow::Value::MoveKind::ForwardedVariable:
        1: 2761:        errorId = "accessForwarded";
        1: 2762:        kindString = "forwarded";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1: 2763:        break;
    #####: 2764:    default:
    #####: 2765:        return;
        -: 2766:    }
       38: 2767:    const std::string errmsg("$symbol:" + varname + "\nAccess of " + kindString + " variable '$symbol'.");
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
call   13 returned 100%
call   14 returned 100%
call   15 returned 100%
call   16 returned 100%
branch 17 taken 100%
branch 18 taken 0%
call   19 never executed
call   20 never executed
call   21 never executed
       38: 2768:    const ErrorPath errorPath = getErrorPath(tok, value, errmsg);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
call    4 never executed
       19: 2769:    reportError(errorPath, Severity::warning, errorId, errmsg, CWE672, inconclusive);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -: 2770:}
        -: 2771:
        -: 2772:
        -: 2773:
function _ZN10CheckOther26checkFuncArgNamesDifferentEv called 927 returned 100% blocks executed 88%
      927: 2774:void CheckOther::checkFuncArgNamesDifferent()
        -: 2775:{
      927: 2776:    const bool style = mSettings->isEnabled(Settings::STYLE);
call    0 returned 100%
      927: 2777:    const bool inconclusive = mSettings->inconclusive;
      927: 2778:    const bool warning = mSettings->isEnabled(Settings::WARNING);
call    0 returned 100%
        -: 2779:
      927: 2780:    if (!(warning || (style && inconclusive)))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 2781:        return;
        -: 2782:
      927: 2783:    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
call    0 returned 100%
        -: 2784:    // check every function
     1908: 2785:    for (const Scope *scope : symbolDatabase->functionScopes) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 51% (fallthrough)
branch  4 taken 49%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
call   11 never executed
      981: 2786:        const Function * function = scope->function;
        -: 2787:        // only check functions with arguments
      981: 2788:        if (!function || function->argCount() == 0)
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
call    2 returned 100%
branch  3 taken 49% (fallthrough)
branch  4 taken 51%
branch  5 taken 49% (fallthrough)
branch  6 taken 51%
     1447: 2789:            continue;
        -: 2790:
        -: 2791:        // only check functions with separate declarations and definitions
      503: 2792:        if (function->argDef == function->arg)
branch  0 taken 97% (fallthrough)
branch  1 taken 3%
      486: 2793:            continue;
        -: 2794:
        -: 2795:        // get the function argument name tokens
       29: 2796:        std::vector<const Token *>  declarations(function->argCount());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
call    5 returned 100%
call    6 never executed
call    7 never executed
       29: 2797:        std::vector<const Token *>  definitions(function->argCount());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
call    5 returned 100%
call    6 returned 100%
branch  7 taken 71%
branch  8 taken 29%
call    9 never executed
       17: 2798:        const Token * decl = function->argDef->next();
call    0 returned 100%
       60: 2799:        for (int j = 0; j < function->argCount(); ++j) {
call    0 returned 100%
branch  1 taken 72% (fallthrough)
branch  2 taken 28%
       43: 2800:            declarations[j] = nullptr;
call    0 returned 100%
       43: 2801:            definitions[j] = nullptr;
call    0 returned 100%
        -: 2802:            // get the definition
       43: 2803:            const Variable * variable = function->getArgumentVar(j);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       43: 2804:            if (variable) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       43: 2805:                definitions[j] = variable->nameToken();
call    0 returned 100%
call    1 returned 100%
        -: 2806:            }
        -: 2807:            // get the declaration (search for first token with varId)
      211: 2808:            while (decl && !Token::Match(decl, ",|)|;")) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
branch  5 taken 75% (fallthrough)
branch  6 taken 25%
branch  7 taken 75% (fallthrough)
branch  8 taken 25%
        -: 2809:                // skip everything after the assignment because
        -: 2810:                // it could also have a varId or be the first
        -: 2811:                // token with a varId if there is no name token
       95: 2812:                if (decl->str() == "=") {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 12% (fallthrough)
branch  3 taken 88%
       11: 2813:                    decl = decl->nextArgument();
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       11: 2814:                    break;
        -: 2815:                }
        -: 2816:                // skip over template
       84: 2817:                if (decl->link())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2818:                    decl = decl->link();
call    0 never executed
       84: 2819:                else if (decl->varId())
call    0 returned 100%
branch  1 taken 49% (fallthrough)
branch  2 taken 51%
       41: 2820:                    declarations[j] = decl;
call    0 returned 100%
       84: 2821:                decl = decl->next();
call    0 returned 100%
        -: 2822:            }
       43: 2823:            if (Token::simpleMatch(decl, ","))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 44% (fallthrough)
branch  4 taken 56%
       19: 2824:                decl = decl->next();
call    0 returned 100%
        -: 2825:        }
        -: 2826:        // check for different argument order
       17: 2827:        if (warning) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       17: 2828:            bool order_different = false;
       60: 2829:            for (int j = 0; j < function->argCount(); ++j) {
call    0 returned 100%
branch  1 taken 72% (fallthrough)
branch  2 taken 28%
       43: 2830:                if (!declarations[j] || !definitions[j] || declarations[j]->str() == definitions[j]->str())
call    0 returned 100%
branch  1 taken 95% (fallthrough)
branch  2 taken 5%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 returned 100%
call   10 returned 100%
branch 11 taken 59% (fallthrough)
branch 12 taken 41%
branch 13 taken 60% (fallthrough)
branch 14 taken 40%
       26: 2831:                    continue;
        -: 2832:
       50: 2833:                for (int k = 0; k < function->argCount(); ++k) {
call    0 returned 100%
branch  1 taken 82% (fallthrough)
branch  2 taken 18%
       41: 2834:                    if (j != k && definitions[k] && declarations[j]->str() == definitions[k]->str()) {
branch  0 taken 71% (fallthrough)
branch  1 taken 29%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 returned 100%
branch 10 taken 28% (fallthrough)
branch 11 taken 72%
branch 12 taken 20% (fallthrough)
branch 13 taken 80%
        8: 2835:                        order_different = true;
        8: 2836:                        break;
        -: 2837:                    }
        -: 2838:                }
        -: 2839:            }
       22: 2840:            if (order_different) {
branch  0 taken 29% (fallthrough)
branch  1 taken 71%
        5: 2841:                funcArgOrderDifferent(function->name(), function->argDef->next(), function->arg->next(), declarations, definitions);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        5: 2842:                continue;
        -: 2843:            }
        -: 2844:        }
        -: 2845:        // check for different argument names
       12: 2846:        if (style && inconclusive) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 75% (fallthrough)
branch  3 taken 25%
       30: 2847:            for (int j = 0; j < function->argCount(); ++j) {
call    0 returned 100%
branch  1 taken 70% (fallthrough)
branch  2 taken 30%
call    3 returned 100%
branch  4 taken 71%
branch  5 taken 29%
       21: 2848:                if (declarations[j] && definitions[j] && declarations[j]->str() != definitions[j]->str())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 returned 100%
call   10 returned 100%
branch 11 taken 43% (fallthrough)
branch 12 taken 57%
branch 13 taken 43% (fallthrough)
branch 14 taken 57%
        9: 2849:                    funcArgNamesDifferent(function->name(), j, declarations[j], definitions[j]);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        -: 2850:            }
        -: 2851:        }
        -: 2852:    }
        -: 2853:}
        -: 2854:
function _ZN10CheckOther21funcArgNamesDifferentERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEiPK5TokenSA_ called 9 returned 100% blocks executed 41%
        9: 2855:void CheckOther::funcArgNamesDifferent(const std::string & functionName, nonneg int index,
        -: 2856:                                       const Token* declaration, const Token* definition)
        -: 2857:{
       18: 2858:    std::list<const Token *> tokens = { declaration,definition };
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
call    5 returned 100%
call    6 never executed
       18: 2859:    reportError(tokens, Severity::style, "funcArgNamesDifferent",
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       18: 2860:                "$symbol:" + functionName + "\n"
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 returned 100%
call    8 never executed
call    9 never executed
       36: 2861:                "Function '$symbol' argument " + MathLib::toString(index + 1) + " names different: declaration '" +
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
call   13 returned 100%
call   14 returned 100%
call   15 returned 100%
call   16 never executed
call   17 never executed
call   18 never executed
call   19 never executed
       36: 2862:                (declaration ? declaration->str() : std::string("A")) + "' definition '" +
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 never executed
call    7 never executed
branch  8 never executed
branch  9 never executed
call   10 returned 100%
branch 11 taken 100% (fallthrough)
branch 12 taken 0% (throw)
call   13 returned 100%
branch 14 taken 100% (fallthrough)
branch 15 taken 0% (throw)
call   16 returned 100%
call   17 returned 100%
call   18 returned 100%
branch 19 taken 0% (fallthrough)
branch 20 taken 100%
call   21 never executed
call   22 never executed
call   23 never executed
call   24 never executed
branch 25 never executed
branch 26 never executed
call   27 never executed
       36: 2863:                (definition ? definition->str() : std::string("B")) + "'.", CWE628, true);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 never executed
call    7 never executed
branch  8 never executed
branch  9 never executed
call   10 returned 100%
branch 11 taken 100% (fallthrough)
branch 12 taken 0% (throw)
call   13 returned 100%
call   14 returned 100%
branch 15 taken 0% (fallthrough)
branch 16 taken 100%
call   17 never executed
call   18 never executed
call   19 never executed
branch 20 never executed
branch 21 never executed
call   22 never executed
        9: 2864:}
call    0 never executed
        -: 2865:
function _ZN10CheckOther21funcArgOrderDifferentERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEPK5TokenSA_RKNSt7__debug6vectorISA_SaISA_EEESG_ called 5 returned 100% blocks executed 76%
        5: 2866:void CheckOther::funcArgOrderDifferent(const std::string & functionName,
        -: 2867:                                       const Token* declaration, const Token* definition,
        -: 2868:                                       const std::vector<const Token *> & declarations,
        -: 2869:                                       const std::vector<const Token *> & definitions)
        -: 2870:{
        -: 2871:    std::list<const Token *> tokens = {
        5: 2872:        declarations.size() ? declarations[0] ? declarations[0] : declaration : nullptr,
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 60% (fallthrough)
branch  5 taken 40%
call    6 returned 100%
        5: 2873:        definitions.size() ? definitions[0] ? definitions[0] : definition : nullptr
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
call    6 returned 100%
       15: 2874:    };
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
call    5 returned 100%
call    6 never executed
call    7 never executed
       10: 2875:    std::string msg = "$symbol:" + functionName + "\nFunction '$symbol' argument order different: declaration '";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 returned 100%
call    8 never executed
       20: 2876:    for (int i = 0; i < declarations.size(); ++i) {
call    0 returned 100%
branch  1 taken 75% (fallthrough)
branch  2 taken 25%
       15: 2877:        if (i != 0)
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
       10: 2878:            msg += ", ";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       15: 2879:        if (declarations[i])
call    0 returned 100%
branch  1 taken 87% (fallthrough)
branch  2 taken 13%
       13: 2880:            msg += declarations[i]->str();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
        -: 2881:    }
        5: 2882:    msg += "' definition '";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       20: 2883:    for (int i = 0; i < definitions.size(); ++i) {
call    0 returned 100%
branch  1 taken 75% (fallthrough)
branch  2 taken 25%
       15: 2884:        if (i != 0)
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
       10: 2885:            msg += ", ";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       15: 2886:        if (definitions[i])
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
       15: 2887:            msg += definitions[i]->str();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
        -: 2888:    }
        5: 2889:    msg += "'";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        5: 2890:    reportError(tokens, Severity::warning, "funcArgOrderDifferent", msg, CWE683, false);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 never executed
        5: 2891:}
call    0 never executed
        -: 2892:
function _ZL12findShadowedPK5ScopeRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEi called 1302 returned 100% blocks executed 98%
     1302: 2893:static const Token *findShadowed(const Scope *scope, const std::string &varname, int linenr)
        -: 2894:{
     1302: 2895:    if (!scope)
branch  0 taken 48% (fallthrough)
branch  1 taken 52%
      628: 2896:        return nullptr;
      684: 2897:    for (const Variable &var : scope->varlist) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 2% (fallthrough)
branch  4 taken 98%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
branch  8 taken 99%
branch  9 taken 1%
call   10 returned 100%
branch 11 taken 99%
branch 12 taken 1%
       11: 2898:        if (scope->isExecutable() && var.nameToken()->linenr() > linenr)
call    0 returned 100%
branch  1 taken 64% (fallthrough)
branch  2 taken 36%
call    3 returned 100%
call    4 returned 100%
branch  5 taken 14% (fallthrough)
branch  6 taken 86%
branch  7 taken 9% (fallthrough)
branch  8 taken 91%
        1: 2899:            continue;
       10: 2900:        if (var.name() == varname)
call    0 returned 100%
call    1 returned 100%
branch  2 taken 10% (fallthrough)
branch  3 taken 90%
        1: 2901:            return var.nameToken();
call    0 returned 100%
        -: 2902:    }
     1571: 2903:    for (const Function &f : scope->functionList) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 57% (fallthrough)
branch  4 taken 43%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
branch  8 taken 99%
branch  9 taken 1%
call   10 returned 100%
branch 11 taken 99%
branch 12 taken 1%
      902: 2904:        if (f.name() == varname)
call    0 returned 100%
call    1 returned 100%
branch  2 taken 1% (fallthrough)
branch  3 taken 99%
        4: 2905:            return f.tokenDef;
        -: 2906:    }
      669: 2907:    if (scope->type == Scope::eLambda)
branch  0 taken 0%
branch  1 taken 100%
    #####: 2908:        return nullptr;
      669: 2909:    return findShadowed(scope->nestedIn, varname, linenr);
call    0 returned 100%
        -: 2910:}
        -: 2911:
function _ZN10CheckOther20checkShadowVariablesEv called 927 returned 100% blocks executed 77%
      927: 2912:void CheckOther::checkShadowVariables()
        -: 2913:{
      927: 2914:    if (!mSettings->isEnabled(Settings::STYLE))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2915:        return;
      927: 2916:    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
call    0 returned 100%
     3570: 2917:    for (const Scope & scope : symbolDatabase->scopeList) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 74% (fallthrough)
branch  4 taken 26%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
     2643: 2918:        if (!scope.isExecutable() || scope.type == Scope::eLambda)
call    0 returned 100%
branch  1 taken 59% (fallthrough)
branch  2 taken 41%
branch  3 taken 1% (fallthrough)
branch  4 taken 99%
branch  5 taken 42% (fallthrough)
branch  6 taken 58%
     1099: 2919:            continue;
     1544: 2920:        const Scope *functionScope = &scope;
     2808: 2921:        while (functionScope && functionScope->type != Scope::ScopeType::eFunction && functionScope->type != Scope::ScopeType::eLambda)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 29% (fallthrough)
branch  3 taken 71%
branch  4 taken 99% (fallthrough)
branch  5 taken 1%
      632: 2922:            functionScope = functionScope->nestedIn;
     2178: 2923:        for (const Variable &var : scope.varlist) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 29% (fallthrough)
branch  4 taken 71%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
      634: 2924:            if (var.nameToken() && var.nameToken()->isExpandedMacro()) // #8903
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
branch  7 taken 0% (fallthrough)
branch  8 taken 100%
branch  9 taken 0% (fallthrough)
branch 10 taken 100%
    #####: 2925:                continue;
        -: 2926:
      634: 2927:            if (functionScope && functionScope->type == Scope::ScopeType::eFunction && functionScope->function) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 99% (fallthrough)
branch  5 taken 1%
      633: 2928:                bool shadowArg = false;
      847: 2929:                for (const Variable &arg : functionScope->function->argumentList) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 25% (fallthrough)
branch  4 taken 75%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
      215: 2930:                    if (arg.nameToken() && var.name() == arg.name()) {
call    0 returned 100%
branch  1 taken 99% (fallthrough)
branch  2 taken 1%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
branch  6 taken 1% (fallthrough)
branch  7 taken 99%
branch  8 taken 1% (fallthrough)
branch  9 taken 99%
        1: 2931:                        shadowError(var.nameToken(), arg.nameToken(), "argument");
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
call    5 returned 100%
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
call   10 returned 100%
call   11 never executed
call   12 never executed
        1: 2932:                        shadowArg = true;
        1: 2933:                        break;
        -: 2934:                    }
        -: 2935:                }
      633: 2936:                if (shadowArg)
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        1: 2937:                    continue;
        -: 2938:            }
        -: 2939:
      633: 2940:            const Token *shadowed = findShadowed(scope.nestedIn, var.name(), var.nameToken()->linenr());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
      633: 2941:            if (!shadowed)
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
      628: 2942:                continue;
        5: 2943:            if (scope.type == Scope::eFunction && scope.className == var.name())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 40% (fallthrough)
branch  5 taken 60%
branch  6 taken 40% (fallthrough)
branch  7 taken 60%
        2: 2944:                continue;
        3: 2945:            shadowError(var.nameToken(), shadowed, (shadowed->varId() != 0) ? "variable" : "function");
call    0 returned 100%
call    1 returned 100%
branch  2 taken 33% (fallthrough)
branch  3 taken 67%
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 returned 100%
branch  9 taken 100% (fallthrough)
branch 10 taken 0% (throw)
call   11 returned 100%
call   12 returned 100%
call   13 never executed
call   14 never executed
        -: 2946:        }
        -: 2947:    }
        -: 2948:}
        -: 2949:
function _ZN10CheckOther11shadowErrorEPK5TokenS2_NSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 4 returned 100% blocks executed 53%
        4: 2950:void CheckOther::shadowError(const Token *var, const Token *shadowed, std::string type)
        -: 2951:{
        8: 2952:    ErrorPath errorPath;
call    0 returned 100%
call    1 returned 100%
call    2 never executed
        4: 2953:    errorPath.push_back(ErrorPathItem(shadowed, "Shadowed declaration"));
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 never executed
        4: 2954:    errorPath.push_back(ErrorPathItem(var, "Shadow variable"));
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 never executed
call    8 never executed
        4: 2955:    const std::string &varname = var ? var->str() : type;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
        8: 2956:    const std::string Type = char(std::toupper(type[0])) + type.substr(1);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
call   10 returned 100%
call   11 never executed
call   12 never executed
        8: 2957:    const std::string id = "shadow" + Type;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
call    4 never executed
        8: 2958:    const std::string message = "$symbol:" + varname + "\nLocal variable \'$symbol\' shadows outer " + type;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
call   10 returned 100%
call   11 returned 100%
call   12 never executed
call   13 never executed
        4: 2959:    reportError(errorPath, Severity::style, id.c_str(), message, CWE398, false);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
        4: 2960:}
        -: 2961:
function _ZL20isVariableExpressionPK5Token called 19 returned 100% blocks executed 94%
       19: 2962:static bool isVariableExpression(const Token* tok)
        -: 2963:{
       19: 2964:    if (Token::Match(tok, "%var%"))
call    0 returned 100%
branch  1 taken 74% (fallthrough)
branch  2 taken 26%
       14: 2965:        return true;
        5: 2966:    if (Token::simpleMatch(tok, "."))
call    0 returned 100%
branch  1 taken 20% (fallthrough)
branch  2 taken 80%
        2: 2967:        return isVariableExpression(tok->astOperand1()) &&
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
        2: 2968:               isVariableExpression(tok->astOperand2());
call    0 returned 100%
call    1 returned 100%
        4: 2969:    return false;
        -: 2970:}
        -: 2971:
function _ZN10CheckOther18checkConstArgumentEv called 927 returned 100% blocks executed 92%
      927: 2972:void CheckOther::checkConstArgument()
        -: 2973:{
      927: 2974:    if (!mSettings->isEnabled(Settings::STYLE))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2975:        return;
      927: 2976:    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
call    0 returned 100%
     1908: 2977:    for (const Scope *functionScope : symbolDatabase->functionScopes) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 51% (fallthrough)
branch  4 taken 49%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
    18796: 2978:        for (const Token *tok = functionScope->bodyStart; tok != functionScope->bodyEnd; tok = tok->next()) {
branch  0 taken 95% (fallthrough)
branch  1 taken 5%
call    2 returned 100%
    17815: 2979:            if (!Token::simpleMatch(tok->astParent(), "("))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
branch  4 taken 88% (fallthrough)
branch  5 taken 12%
    15614: 2980:                continue;
     2201: 2981:            if (!Token::Match(tok->astParent()->previous(), "%name%"))
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
branch  5 taken 3% (fallthrough)
branch  6 taken 97%
       77: 2982:                continue;
     2124: 2983:            if (Token::Match(tok->astParent()->previous(), "if|while|switch|sizeof"))
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
branch  5 taken 45% (fallthrough)
branch  6 taken 55%
      954: 2984:                continue;
     1170: 2985:            if (tok == tok->astParent()->previous())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 49% (fallthrough)
branch  3 taken 51%
      573: 2986:                continue;
      597: 2987:            if (!tok->hasKnownIntValue())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 90% (fallthrough)
branch  4 taken 10%
      535: 2988:                continue;
       62: 2989:            if (Token::Match(tok, "++|--"))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 2% (fallthrough)
branch  4 taken 98%
        1: 2990:                continue;
       61: 2991:            if (isConstVarExpression(tok))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 72% (fallthrough)
branch  4 taken 28%
       44: 2992:                continue;
       17: 2993:            const Token * tok2 = tok;
       17: 2994:            if (isCPPCast(tok2))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 6% (fallthrough)
branch  4 taken 94%
        1: 2995:                tok2 = tok2->astOperand2();
call    0 returned 100%
       17: 2996:            if (isVariableExpression(tok2))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 76% (fallthrough)
branch  4 taken 24%
       13: 2997:                continue;
        4: 2998:            constArgumentError(tok, tok->astParent()->previous(), &tok->values().front());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
        -: 2999:        }
        -: 3000:    }
        -: 3001:}
        -: 3002:
function _ZN10CheckOther18constArgumentErrorEPK5TokenS2_PKN9ValueFlow5ValueE called 4 returned 100% blocks executed 44%
        4: 3003:void CheckOther::constArgumentError(const Token *tok, const Token *ftok, const ValueFlow::Value *value)
        -: 3004:{
        4: 3005:    MathLib::bigint intvalue = value ? value->intvalue : 0;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        8: 3006:    const std::string expr = tok ? tok->expressionString() : std::string("x");
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
call    5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
branch  9 taken 0% (fallthrough)
branch 10 taken 100%
call   11 never executed
call   12 returned 100%
branch 13 never executed
branch 14 never executed
call   15 never executed
call   16 never executed
        8: 3007:    const std::string fun = ftok ? ftok->str() : std::string("f");
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 never executed
call    7 never executed
branch  8 never executed
branch  9 never executed
branch 10 taken 0% (fallthrough)
branch 11 taken 100%
call   12 never executed
call   13 returned 100%
branch 14 never executed
branch 15 never executed
call   16 never executed
call   17 never executed
call   18 never executed
        -: 3008:
        8: 3009:    const std::string errmsg = "Argument '" + expr + "' to function " + fun + " is always " + std::to_string(intvalue);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
branch 13 taken 100% (fallthrough)
branch 14 taken 0% (throw)
call   15 returned 100%
branch 16 taken 100% (fallthrough)
branch 17 taken 0% (throw)
call   18 returned 100%
call   19 returned 100%
call   20 returned 100%
call   21 returned 100%
call   22 returned 100%
call   23 returned 100%
call   24 never executed
call   25 never executed
call   26 never executed
call   27 never executed
call   28 never executed
        8: 3010:    const ErrorPath errorPath = getErrorPath(tok, value, errmsg);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
call    4 never executed
        4: 3011:    reportError(errorPath, Severity::style, "constArgument", errmsg, CWE570, false);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        4: 3012:}
        -: 3013:
function _ZN10CheckOther20checkComparePointersEv called 927 returned 100% blocks executed 86%
      927: 3014:void CheckOther::checkComparePointers()
        -: 3015:{
      927: 3016:    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
call    0 returned 100%
     1908: 3017:    for (const Scope *functionScope : symbolDatabase->functionScopes) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 51% (fallthrough)
branch  4 taken 49%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
    18796: 3018:        for (const Token *tok = functionScope->bodyStart; tok != functionScope->bodyEnd; tok = tok->next()) {
branch  0 taken 95% (fallthrough)
branch  1 taken 5%
call    2 returned 100%
    17815: 3019:            if (!Token::Match(tok, "<|>|<=|>=|-"))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 99% (fallthrough)
branch  4 taken 1%
    35370: 3020:                continue;
      253: 3021:            const Token *tok1 = tok->astOperand1();
call    0 returned 100%
      253: 3022:            const Token *tok2 = tok->astOperand2();
call    0 returned 100%
      253: 3023:            if (!astIsPointer(tok1) || !astIsPointer(tok2))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 14% (fallthrough)
branch  4 taken 86%
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0% (throw)
branch  8 taken 34% (fallthrough)
branch  9 taken 66%
branch 10 taken 91% (fallthrough)
branch 11 taken 9%
      230: 3024:                continue;
       30: 3025:            ValueFlow::Value v1 = getLifetimeObjValue(tok1);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 never executed
       30: 3026:            ValueFlow::Value v2 = getLifetimeObjValue(tok2);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 30%
branch  5 taken 70%
call    6 never executed
       23: 3027:            if (!v1.isLocalLifetimeValue() || !v2.isLocalLifetimeValue())
call    0 returned 100%
branch  1 taken 43% (fallthrough)
branch  2 taken 57%
call    3 returned 100%
branch  4 taken 10% (fallthrough)
branch  5 taken 90%
branch  6 taken 61% (fallthrough)
branch  7 taken 39%
       14: 3028:                continue;
        9: 3029:            const Variable *var1 = v1.tokvalue->variable();
call    0 returned 100%
        9: 3030:            const Variable *var2 = v2.tokvalue->variable();
call    0 returned 100%
        9: 3031:            if (!var1 || !var2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 3032:                continue;
        9: 3033:            if (v1.tokvalue->varId() == v2.tokvalue->varId())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 11% (fallthrough)
branch  3 taken 89%
        1: 3034:                continue;
        8: 3035:            if (var1->isReference() || var2->isReference())
call    0 returned 100%
branch  1 taken 88% (fallthrough)
branch  2 taken 13%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
branch  6 taken 13% (fallthrough)
branch  7 taken 88%
        1: 3036:                continue;
        7: 3037:            if (var1->isRValueReference() || var2->isRValueReference())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
    #####: 3038:                continue;
        7: 3039:            comparePointersError(tok, &v1, &v2);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 30%
branch  5 taken 70%
        -: 3040:        }
        -: 3041:    }
      927: 3042:}
        -: 3043:
function _ZN10CheckOther20comparePointersErrorEPK5TokenPKN9ValueFlow5ValueES6_ called 7 returned 100% blocks executed 56%
        7: 3044:void CheckOther::comparePointersError(const Token *tok, const ValueFlow::Value *v1, const ValueFlow::Value *v2)
        -: 3045:{
       14: 3046:    ErrorPath errorPath;
call    0 returned 100%
call    1 returned 100%
call    2 never executed
       14: 3047:    std::string verb = "Comparing";
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
call    5 returned 100%
call    6 never executed
        7: 3048:    if (Token::simpleMatch(tok, "-"))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 14% (fallthrough)
branch  4 taken 86%
        1: 3049:        verb = "Subtracting";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        7: 3050:    if (v1) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        7: 3051:        errorPath.emplace_back(v1->tokvalue->variable()->nameToken(), "Variable declared here.");
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
        7: 3052:        errorPath.insert(errorPath.end(), v1->errorPath.begin(), v1->errorPath.end());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 returned 100%
call    9 returned 100%
call   10 returned 100%
call   11 returned 100%
call   12 never executed
call   13 never executed
call   14 never executed
call   15 never executed
        -: 3053:    }
        7: 3054:    if (v2) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        7: 3055:        errorPath.emplace_back(v2->tokvalue->variable()->nameToken(), "Variable declared here.");
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
        7: 3056:        errorPath.insert(errorPath.end(), v2->errorPath.begin(), v2->errorPath.end());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
call    8 returned 100%
call    9 returned 100%
call   10 returned 100%
call   11 returned 100%
call   12 never executed
call   13 never executed
call   14 never executed
call   15 never executed
        -: 3057:    }
        7: 3058:    errorPath.emplace_back(tok, "");
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       14: 3059:    reportError(
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       14: 3060:        errorPath, Severity::error, "comparePointers", verb + " pointers that point to different objects", CWE570, false);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
call    4 never executed
function _GLOBAL__sub_I__ZN10CheckOther25checkCastIntToCharAndBackEv called 1 returned 100% blocks executed 100%
function _Z41__static_initialization_and_destruction_0ii called 1 returned 100% blocks executed 100%
       10: 3061:}
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 never executed
